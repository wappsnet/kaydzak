/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./wp-content/themes/wappsnet/assets/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/global-offset/index.es5.js":
/*!*************************************************!*\
  !*** ./node_modules/global-offset/index.es5.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = globalOffset;\nfunction globalOffset(el) {\n  var _el$getBoundingClient = el.getBoundingClientRect(),\n      top = _el$getBoundingClient.top,\n      left = _el$getBoundingClient.left;\n\n  var _window = window,\n      pageYOffset = _window.pageYOffset,\n      pageXOffset = _window.pageXOffset;\n\n  return {\n    top: top + pageYOffset,\n    left: left + pageXOffset\n  };\n}\nmodule.exports = exports[\"default\"];\n\n//# sourceURL=webpack:///./node_modules/global-offset/index.es5.js?");

/***/ }),

/***/ "./node_modules/hammerjs/hammer.js":
/*!*****************************************!*\
  !*** ./node_modules/hammerjs/hammer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n    'use strict';\n\n    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n    var TEST_ELEMENT = document.createElement('div');\n\n    var TYPE_FUNCTION = 'function';\n\n    var round = Math.round;\n    var abs = Math.abs;\n    var now = Date.now;\n\n    /**\n     * set a timeout with a given scope\n     * @param {Function} fn\n     * @param {Number} timeout\n     * @param {Object} context\n     * @returns {number}\n     */\n    function setTimeoutContext(fn, timeout, context) {\n        return setTimeout(bindFn(fn, context), timeout);\n    }\n\n    /**\n     * if the argument is an array, we want to execute the fn on each entry\n     * if it aint an array we don't want to do a thing.\n     * this is used by all the methods that accept a single and array argument.\n     * @param {*|Array} arg\n     * @param {String} fn\n     * @param {Object} [context]\n     * @returns {Boolean}\n     */\n    function invokeArrayArg(arg, fn, context) {\n        if (Array.isArray(arg)) {\n            each(arg, context[fn], context);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * walk objects and arrays\n     * @param {Object} obj\n     * @param {Function} iterator\n     * @param {Object} context\n     */\n    function each(obj, iterator, context) {\n        var i;\n\n        if (!obj) {\n            return;\n        }\n\n        if (obj.forEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length !== undefined) {\n            i = 0;\n            while (i < obj.length) {\n                iterator.call(context, obj[i], i, obj);\n                i++;\n            }\n        } else {\n            for (i in obj) {\n                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n            }\n        }\n    }\n\n    /**\n     * wrap a method with a deprecation warning and stack trace\n     * @param {Function} method\n     * @param {String} name\n     * @param {String} message\n     * @returns {Function} A new function wrapping the supplied method.\n     */\n    function deprecate(method, name, message) {\n        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n        return function () {\n            var e = new Error('get-stack-trace');\n            var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n            var log = window.console && (window.console.warn || window.console.log);\n            if (log) {\n                log.call(window.console, deprecationMessage, stack);\n            }\n            return method.apply(this, arguments);\n        };\n    }\n\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} target\n     * @param {...Object} objects_to_assign\n     * @returns {Object} target\n     */\n    var assign;\n    if (typeof Object.assign !== 'function') {\n        assign = function assign(target) {\n            if (target === undefined || target === null) {\n                throw new TypeError('Cannot convert undefined or null to object');\n            }\n\n            var output = Object(target);\n            for (var index = 1; index < arguments.length; index++) {\n                var source = arguments[index];\n                if (source !== undefined && source !== null) {\n                    for (var nextKey in source) {\n                        if (source.hasOwnProperty(nextKey)) {\n                            output[nextKey] = source[nextKey];\n                        }\n                    }\n                }\n            }\n            return output;\n        };\n    } else {\n        assign = Object.assign;\n    }\n\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} dest\n     * @param {Object} src\n     * @param {Boolean} [merge=false]\n     * @returns {Object} dest\n     */\n    var extend = deprecate(function extend(dest, src, merge) {\n        var keys = Object.keys(src);\n        var i = 0;\n        while (i < keys.length) {\n            if (!merge || merge && dest[keys[i]] === undefined) {\n                dest[keys[i]] = src[keys[i]];\n            }\n            i++;\n        }\n        return dest;\n    }, 'extend', 'Use `assign`.');\n\n    /**\n     * merge the values from src in the dest.\n     * means that properties that exist in dest will not be overwritten by src\n     * @param {Object} dest\n     * @param {Object} src\n     * @returns {Object} dest\n     */\n    var merge = deprecate(function merge(dest, src) {\n        return extend(dest, src, true);\n    }, 'merge', 'Use `assign`.');\n\n    /**\n     * simple class inheritance\n     * @param {Function} child\n     * @param {Function} base\n     * @param {Object} [properties]\n     */\n    function inherit(child, base, properties) {\n        var baseP = base.prototype,\n            childP;\n\n        childP = child.prototype = Object.create(baseP);\n        childP.constructor = child;\n        childP._super = baseP;\n\n        if (properties) {\n            assign(childP, properties);\n        }\n    }\n\n    /**\n     * simple function bind\n     * @param {Function} fn\n     * @param {Object} context\n     * @returns {Function}\n     */\n    function bindFn(fn, context) {\n        return function boundFn() {\n            return fn.apply(context, arguments);\n        };\n    }\n\n    /**\n     * let a boolean value also be a function that must return a boolean\n     * this first item in args will be used as the context\n     * @param {Boolean|Function} val\n     * @param {Array} [args]\n     * @returns {Boolean}\n     */\n    function boolOrFn(val, args) {\n        if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == TYPE_FUNCTION) {\n            return val.apply(args ? args[0] || undefined : undefined, args);\n        }\n        return val;\n    }\n\n    /**\n     * use the val2 when val1 is undefined\n     * @param {*} val1\n     * @param {*} val2\n     * @returns {*}\n     */\n    function ifUndefined(val1, val2) {\n        return val1 === undefined ? val2 : val1;\n    }\n\n    /**\n     * addEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n    function addEventListeners(target, types, handler) {\n        each(splitStr(types), function (type) {\n            target.addEventListener(type, handler, false);\n        });\n    }\n\n    /**\n     * removeEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n    function removeEventListeners(target, types, handler) {\n        each(splitStr(types), function (type) {\n            target.removeEventListener(type, handler, false);\n        });\n    }\n\n    /**\n     * find if a node is in the given parent\n     * @method hasParent\n     * @param {HTMLElement} node\n     * @param {HTMLElement} parent\n     * @return {Boolean} found\n     */\n    function hasParent(node, parent) {\n        while (node) {\n            if (node == parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    }\n\n    /**\n     * small indexOf wrapper\n     * @param {String} str\n     * @param {String} find\n     * @returns {Boolean} found\n     */\n    function inStr(str, find) {\n        return str.indexOf(find) > -1;\n    }\n\n    /**\n     * split string on whitespace\n     * @param {String} str\n     * @returns {Array} words\n     */\n    function splitStr(str) {\n        return str.trim().split(/\\s+/g);\n    }\n\n    /**\n     * find if a array contains the object using indexOf or a simple polyFill\n     * @param {Array} src\n     * @param {String} find\n     * @param {String} [findByKey]\n     * @return {Boolean|Number} false when not found, or the index\n     */\n    function inArray(src, find, findByKey) {\n        if (src.indexOf && !findByKey) {\n            return src.indexOf(find);\n        } else {\n            var i = 0;\n            while (i < src.length) {\n                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n                    return i;\n                }\n                i++;\n            }\n            return -1;\n        }\n    }\n\n    /**\n     * convert array-like objects to real arrays\n     * @param {Object} obj\n     * @returns {Array}\n     */\n    function toArray(obj) {\n        return Array.prototype.slice.call(obj, 0);\n    }\n\n    /**\n     * unique array with objects based on a key (like 'id') or just by the array's value\n     * @param {Array} src [{id:1},{id:2},{id:1}]\n     * @param {String} [key]\n     * @param {Boolean} [sort=False]\n     * @returns {Array} [{id:1},{id:2}]\n     */\n    function uniqueArray(src, key, sort) {\n        var results = [];\n        var values = [];\n        var i = 0;\n\n        while (i < src.length) {\n            var val = key ? src[i][key] : src[i];\n            if (inArray(values, val) < 0) {\n                results.push(src[i]);\n            }\n            values[i] = val;\n            i++;\n        }\n\n        if (sort) {\n            if (!key) {\n                results = results.sort();\n            } else {\n                results = results.sort(function sortUniqueArray(a, b) {\n                    return a[key] > b[key];\n                });\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * get the prefixed property\n     * @param {Object} obj\n     * @param {String} property\n     * @returns {String|Undefined} prefixed\n     */\n    function prefixed(obj, property) {\n        var prefix, prop;\n        var camelProp = property[0].toUpperCase() + property.slice(1);\n\n        var i = 0;\n        while (i < VENDOR_PREFIXES.length) {\n            prefix = VENDOR_PREFIXES[i];\n            prop = prefix ? prefix + camelProp : property;\n\n            if (prop in obj) {\n                return prop;\n            }\n            i++;\n        }\n        return undefined;\n    }\n\n    /**\n     * get a unique id\n     * @returns {number} uniqueId\n     */\n    var _uniqueId = 1;\n    function uniqueId() {\n        return _uniqueId++;\n    }\n\n    /**\n     * get the window object of an element\n     * @param {HTMLElement} element\n     * @returns {DocumentView|Window}\n     */\n    function getWindowForElement(element) {\n        var doc = element.ownerDocument || element;\n        return doc.defaultView || doc.parentWindow || window;\n    }\n\n    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\n    var SUPPORT_TOUCH = 'ontouchstart' in window;\n    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\n    var INPUT_TYPE_TOUCH = 'touch';\n    var INPUT_TYPE_PEN = 'pen';\n    var INPUT_TYPE_MOUSE = 'mouse';\n    var INPUT_TYPE_KINECT = 'kinect';\n\n    var COMPUTE_INTERVAL = 25;\n\n    var INPUT_START = 1;\n    var INPUT_MOVE = 2;\n    var INPUT_END = 4;\n    var INPUT_CANCEL = 8;\n\n    var DIRECTION_NONE = 1;\n    var DIRECTION_LEFT = 2;\n    var DIRECTION_RIGHT = 4;\n    var DIRECTION_UP = 8;\n    var DIRECTION_DOWN = 16;\n\n    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\n    var PROPS_XY = ['x', 'y'];\n    var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n    /**\n     * create new input type manager\n     * @param {Manager} manager\n     * @param {Function} callback\n     * @returns {Input}\n     * @constructor\n     */\n    function Input(manager, callback) {\n        var self = this;\n        this.manager = manager;\n        this.callback = callback;\n        this.element = manager.element;\n        this.target = manager.options.inputTarget;\n\n        // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n        // so when disabled the input events are completely bypassed.\n        this.domHandler = function (ev) {\n            if (boolOrFn(manager.options.enable, [manager])) {\n                self.handler(ev);\n            }\n        };\n\n        this.init();\n    }\n\n    Input.prototype = {\n        /**\n         * should handle the inputEvent data and trigger the callback\n         * @virtual\n         */\n        handler: function handler() {},\n\n        /**\n         * bind the events\n         */\n        init: function init() {\n            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n        },\n\n        /**\n         * unbind the events\n         */\n        destroy: function destroy() {\n            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n        }\n    };\n\n    /**\n     * create new input type manager\n     * called by the Manager constructor\n     * @param {Hammer} manager\n     * @returns {Input}\n     */\n    function createInputInstance(manager) {\n        var Type;\n        var inputClass = manager.options.inputClass;\n\n        if (inputClass) {\n            Type = inputClass;\n        } else if (SUPPORT_POINTER_EVENTS) {\n            Type = PointerEventInput;\n        } else if (SUPPORT_ONLY_TOUCH) {\n            Type = TouchInput;\n        } else if (!SUPPORT_TOUCH) {\n            Type = MouseInput;\n        } else {\n            Type = TouchMouseInput;\n        }\n        return new Type(manager, inputHandler);\n    }\n\n    /**\n     * handle input events\n     * @param {Manager} manager\n     * @param {String} eventType\n     * @param {Object} input\n     */\n    function inputHandler(manager, eventType, input) {\n        var pointersLen = input.pointers.length;\n        var changedPointersLen = input.changedPointers.length;\n        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n\n        input.isFirst = !!isFirst;\n        input.isFinal = !!isFinal;\n\n        if (isFirst) {\n            manager.session = {};\n        }\n\n        // source event is the normalized value of the domEvents\n        // like 'touchstart, mouseup, pointerdown'\n        input.eventType = eventType;\n\n        // compute scale, rotation etc\n        computeInputData(manager, input);\n\n        // emit secret event\n        manager.emit('hammer.input', input);\n\n        manager.recognize(input);\n        manager.session.prevInput = input;\n    }\n\n    /**\n     * extend the data with some usable properties like scale, rotate, velocity etc\n     * @param {Object} manager\n     * @param {Object} input\n     */\n    function computeInputData(manager, input) {\n        var session = manager.session;\n        var pointers = input.pointers;\n        var pointersLength = pointers.length;\n\n        // store the first input to calculate the distance and direction\n        if (!session.firstInput) {\n            session.firstInput = simpleCloneInputData(input);\n        }\n\n        // to compute scale and rotation we need to store the multiple touches\n        if (pointersLength > 1 && !session.firstMultiple) {\n            session.firstMultiple = simpleCloneInputData(input);\n        } else if (pointersLength === 1) {\n            session.firstMultiple = false;\n        }\n\n        var firstInput = session.firstInput;\n        var firstMultiple = session.firstMultiple;\n        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n        var center = input.center = getCenter(pointers);\n        input.timeStamp = now();\n        input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n        input.angle = getAngle(offsetCenter, center);\n        input.distance = getDistance(offsetCenter, center);\n\n        computeDeltaXY(session, input);\n        input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n        input.overallVelocityX = overallVelocity.x;\n        input.overallVelocityY = overallVelocity.y;\n        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n\n        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n\n        computeIntervalInputData(session, input);\n\n        // find the correct target\n        var target = manager.element;\n        if (hasParent(input.srcEvent.target, target)) {\n            target = input.srcEvent.target;\n        }\n        input.target = target;\n    }\n\n    function computeDeltaXY(session, input) {\n        var center = input.center;\n        var offset = session.offsetDelta || {};\n        var prevDelta = session.prevDelta || {};\n        var prevInput = session.prevInput || {};\n\n        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n            prevDelta = session.prevDelta = {\n                x: prevInput.deltaX || 0,\n                y: prevInput.deltaY || 0\n            };\n\n            offset = session.offsetDelta = {\n                x: center.x,\n                y: center.y\n            };\n        }\n\n        input.deltaX = prevDelta.x + (center.x - offset.x);\n        input.deltaY = prevDelta.y + (center.y - offset.y);\n    }\n\n    /**\n     * velocity is calculated every x ms\n     * @param {Object} session\n     * @param {Object} input\n     */\n    function computeIntervalInputData(session, input) {\n        var last = session.lastInterval || input,\n            deltaTime = input.timeStamp - last.timeStamp,\n            velocity,\n            velocityX,\n            velocityY,\n            direction;\n\n        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n            var deltaX = input.deltaX - last.deltaX;\n            var deltaY = input.deltaY - last.deltaY;\n\n            var v = getVelocity(deltaTime, deltaX, deltaY);\n            velocityX = v.x;\n            velocityY = v.y;\n            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n            direction = getDirection(deltaX, deltaY);\n\n            session.lastInterval = input;\n        } else {\n            // use latest velocity info if it doesn't overtake a minimum period\n            velocity = last.velocity;\n            velocityX = last.velocityX;\n            velocityY = last.velocityY;\n            direction = last.direction;\n        }\n\n        input.velocity = velocity;\n        input.velocityX = velocityX;\n        input.velocityY = velocityY;\n        input.direction = direction;\n    }\n\n    /**\n     * create a simple clone from the input used for storage of firstInput and firstMultiple\n     * @param {Object} input\n     * @returns {Object} clonedInputData\n     */\n    function simpleCloneInputData(input) {\n        // make a simple copy of the pointers because we will get a reference if we don't\n        // we only need clientXY for the calculations\n        var pointers = [];\n        var i = 0;\n        while (i < input.pointers.length) {\n            pointers[i] = {\n                clientX: round(input.pointers[i].clientX),\n                clientY: round(input.pointers[i].clientY)\n            };\n            i++;\n        }\n\n        return {\n            timeStamp: now(),\n            pointers: pointers,\n            center: getCenter(pointers),\n            deltaX: input.deltaX,\n            deltaY: input.deltaY\n        };\n    }\n\n    /**\n     * get the center of all the pointers\n     * @param {Array} pointers\n     * @return {Object} center contains `x` and `y` properties\n     */\n    function getCenter(pointers) {\n        var pointersLength = pointers.length;\n\n        // no need to loop when only one touch\n        if (pointersLength === 1) {\n            return {\n                x: round(pointers[0].clientX),\n                y: round(pointers[0].clientY)\n            };\n        }\n\n        var x = 0,\n            y = 0,\n            i = 0;\n        while (i < pointersLength) {\n            x += pointers[i].clientX;\n            y += pointers[i].clientY;\n            i++;\n        }\n\n        return {\n            x: round(x / pointersLength),\n            y: round(y / pointersLength)\n        };\n    }\n\n    /**\n     * calculate the velocity between two points. unit is in px per ms.\n     * @param {Number} deltaTime\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Object} velocity `x` and `y`\n     */\n    function getVelocity(deltaTime, x, y) {\n        return {\n            x: x / deltaTime || 0,\n            y: y / deltaTime || 0\n        };\n    }\n\n    /**\n     * get the direction between two points\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Number} direction\n     */\n    function getDirection(x, y) {\n        if (x === y) {\n            return DIRECTION_NONE;\n        }\n\n        if (abs(x) >= abs(y)) {\n            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        }\n        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    }\n\n    /**\n     * calculate the absolute distance between two points\n     * @param {Object} p1 {x, y}\n     * @param {Object} p2 {x, y}\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} distance\n     */\n    function getDistance(p1, p2, props) {\n        if (!props) {\n            props = PROPS_XY;\n        }\n        var x = p2[props[0]] - p1[props[0]],\n            y = p2[props[1]] - p1[props[1]];\n\n        return Math.sqrt(x * x + y * y);\n    }\n\n    /**\n     * calculate the angle between two coordinates\n     * @param {Object} p1\n     * @param {Object} p2\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} angle\n     */\n    function getAngle(p1, p2, props) {\n        if (!props) {\n            props = PROPS_XY;\n        }\n        var x = p2[props[0]] - p1[props[0]],\n            y = p2[props[1]] - p1[props[1]];\n        return Math.atan2(y, x) * 180 / Math.PI;\n    }\n\n    /**\n     * calculate the rotation degrees between two pointersets\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} rotation\n     */\n    function getRotation(start, end) {\n        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n    }\n\n    /**\n     * calculate the scale factor between two pointersets\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} scale\n     */\n    function getScale(start, end) {\n        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n    }\n\n    var MOUSE_INPUT_MAP = {\n        mousedown: INPUT_START,\n        mousemove: INPUT_MOVE,\n        mouseup: INPUT_END\n    };\n\n    var MOUSE_ELEMENT_EVENTS = 'mousedown';\n    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n    /**\n     * Mouse events input\n     * @constructor\n     * @extends Input\n     */\n    function MouseInput() {\n        this.evEl = MOUSE_ELEMENT_EVENTS;\n        this.evWin = MOUSE_WINDOW_EVENTS;\n\n        this.pressed = false; // mousedown state\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(MouseInput, Input, {\n        /**\n         * handle mouse events\n         * @param {Object} ev\n         */\n        handler: function MEhandler(ev) {\n            var eventType = MOUSE_INPUT_MAP[ev.type];\n\n            // on start we want to have the left mouse button down\n            if (eventType & INPUT_START && ev.button === 0) {\n                this.pressed = true;\n            }\n\n            if (eventType & INPUT_MOVE && ev.which !== 1) {\n                eventType = INPUT_END;\n            }\n\n            // mouse must be down\n            if (!this.pressed) {\n                return;\n            }\n\n            if (eventType & INPUT_END) {\n                this.pressed = false;\n            }\n\n            this.callback(this.manager, eventType, {\n                pointers: [ev],\n                changedPointers: [ev],\n                pointerType: INPUT_TYPE_MOUSE,\n                srcEvent: ev\n            });\n        }\n    });\n\n    var POINTER_INPUT_MAP = {\n        pointerdown: INPUT_START,\n        pointermove: INPUT_MOVE,\n        pointerup: INPUT_END,\n        pointercancel: INPUT_CANCEL,\n        pointerout: INPUT_CANCEL\n    };\n\n    // in IE10 the pointer types is defined as an enum\n    var IE10_POINTER_TYPE_ENUM = {\n        2: INPUT_TYPE_TOUCH,\n        3: INPUT_TYPE_PEN,\n        4: INPUT_TYPE_MOUSE,\n        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n    };\n\n    var POINTER_ELEMENT_EVENTS = 'pointerdown';\n    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n    // IE10 has prefixed support, and case-sensitive\n    if (window.MSPointerEvent && !window.PointerEvent) {\n        POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n    }\n\n    /**\n     * Pointer events input\n     * @constructor\n     * @extends Input\n     */\n    function PointerEventInput() {\n        this.evEl = POINTER_ELEMENT_EVENTS;\n        this.evWin = POINTER_WINDOW_EVENTS;\n\n        Input.apply(this, arguments);\n\n        this.store = this.manager.session.pointerEvents = [];\n    }\n\n    inherit(PointerEventInput, Input, {\n        /**\n         * handle mouse events\n         * @param {Object} ev\n         */\n        handler: function PEhandler(ev) {\n            var store = this.store;\n            var removePointer = false;\n\n            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n            var isTouch = pointerType == INPUT_TYPE_TOUCH;\n\n            // get index of the event in the store\n            var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n            // start and mouse must be down\n            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n                if (storeIndex < 0) {\n                    store.push(ev);\n                    storeIndex = store.length - 1;\n                }\n            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n                removePointer = true;\n            }\n\n            // it not found, so the pointer hasn't been down (so it's probably a hover)\n            if (storeIndex < 0) {\n                return;\n            }\n\n            // update the event in the store\n            store[storeIndex] = ev;\n\n            this.callback(this.manager, eventType, {\n                pointers: store,\n                changedPointers: [ev],\n                pointerType: pointerType,\n                srcEvent: ev\n            });\n\n            if (removePointer) {\n                // remove from the store\n                store.splice(storeIndex, 1);\n            }\n        }\n    });\n\n    var SINGLE_TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\n     * Touch events input\n     * @constructor\n     * @extends Input\n     */\n    function SingleTouchInput() {\n        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n        this.started = false;\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(SingleTouchInput, Input, {\n        handler: function TEhandler(ev) {\n            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n            // should we handle the touch events?\n            if (type === INPUT_START) {\n                this.started = true;\n            }\n\n            if (!this.started) {\n                return;\n            }\n\n            var touches = normalizeSingleTouches.call(this, ev, type);\n\n            // when done, reset the started state\n            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n                this.started = false;\n            }\n\n            this.callback(this.manager, type, {\n                pointers: touches[0],\n                changedPointers: touches[1],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            });\n        }\n    });\n\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n    function normalizeSingleTouches(ev, type) {\n        var all = toArray(ev.touches);\n        var changed = toArray(ev.changedTouches);\n\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            all = uniqueArray(all.concat(changed), 'identifier', true);\n        }\n\n        return [all, changed];\n    }\n\n    var TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\n     * Multi-user touch events input\n     * @constructor\n     * @extends Input\n     */\n    function TouchInput() {\n        this.evTarget = TOUCH_TARGET_EVENTS;\n        this.targetIds = {};\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(TouchInput, Input, {\n        handler: function MTEhandler(ev) {\n            var type = TOUCH_INPUT_MAP[ev.type];\n            var touches = getTouches.call(this, ev, type);\n            if (!touches) {\n                return;\n            }\n\n            this.callback(this.manager, type, {\n                pointers: touches[0],\n                changedPointers: touches[1],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            });\n        }\n    });\n\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n    function getTouches(ev, type) {\n        var allTouches = toArray(ev.touches);\n        var targetIds = this.targetIds;\n\n        // when there is only one touch, the process can be simplified\n        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n            targetIds[allTouches[0].identifier] = true;\n            return [allTouches, allTouches];\n        }\n\n        var i,\n            targetTouches,\n            changedTouches = toArray(ev.changedTouches),\n            changedTargetTouches = [],\n            target = this.target;\n\n        // get target touches from touches\n        targetTouches = allTouches.filter(function (touch) {\n            return hasParent(touch.target, target);\n        });\n\n        // collect touches\n        if (type === INPUT_START) {\n            i = 0;\n            while (i < targetTouches.length) {\n                targetIds[targetTouches[i].identifier] = true;\n                i++;\n            }\n        }\n\n        // filter changed touches to only contain touches that exist in the collected target ids\n        i = 0;\n        while (i < changedTouches.length) {\n            if (targetIds[changedTouches[i].identifier]) {\n                changedTargetTouches.push(changedTouches[i]);\n            }\n\n            // cleanup removed touches\n            if (type & (INPUT_END | INPUT_CANCEL)) {\n                delete targetIds[changedTouches[i].identifier];\n            }\n            i++;\n        }\n\n        if (!changedTargetTouches.length) {\n            return;\n        }\n\n        return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n    }\n\n    /**\n     * Combined touch and mouse input\n     *\n     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n     * This because touch devices also emit mouse events while doing a touch.\n     *\n     * @constructor\n     * @extends Input\n     */\n\n    var DEDUP_TIMEOUT = 2500;\n    var DEDUP_DISTANCE = 25;\n\n    function TouchMouseInput() {\n        Input.apply(this, arguments);\n\n        var handler = bindFn(this.handler, this);\n        this.touch = new TouchInput(this.manager, handler);\n        this.mouse = new MouseInput(this.manager, handler);\n\n        this.primaryTouch = null;\n        this.lastTouches = [];\n    }\n\n    inherit(TouchMouseInput, Input, {\n        /**\n         * handle mouse and touch events\n         * @param {Hammer} manager\n         * @param {String} inputEvent\n         * @param {Object} inputData\n         */\n        handler: function TMEhandler(manager, inputEvent, inputData) {\n            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n                isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n                return;\n            }\n\n            // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n            if (isTouch) {\n                recordTouches.call(this, inputEvent, inputData);\n            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n                return;\n            }\n\n            this.callback(manager, inputEvent, inputData);\n        },\n\n        /**\n         * remove the event listeners\n         */\n        destroy: function destroy() {\n            this.touch.destroy();\n            this.mouse.destroy();\n        }\n    });\n\n    function recordTouches(eventType, eventData) {\n        if (eventType & INPUT_START) {\n            this.primaryTouch = eventData.changedPointers[0].identifier;\n            setLastTouch.call(this, eventData);\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            setLastTouch.call(this, eventData);\n        }\n    }\n\n    function setLastTouch(eventData) {\n        var touch = eventData.changedPointers[0];\n\n        if (touch.identifier === this.primaryTouch) {\n            var lastTouch = { x: touch.clientX, y: touch.clientY };\n            this.lastTouches.push(lastTouch);\n            var lts = this.lastTouches;\n            var removeLastTouch = function removeLastTouch() {\n                var i = lts.indexOf(lastTouch);\n                if (i > -1) {\n                    lts.splice(i, 1);\n                }\n            };\n            setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n        }\n    }\n\n    function isSyntheticEvent(eventData) {\n        var x = eventData.srcEvent.clientX,\n            y = eventData.srcEvent.clientY;\n        for (var i = 0; i < this.lastTouches.length; i++) {\n            var t = this.lastTouches[i];\n            var dx = Math.abs(x - t.x),\n                dy = Math.abs(y - t.y);\n            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n    // magical touchAction value\n    var TOUCH_ACTION_COMPUTE = 'compute';\n    var TOUCH_ACTION_AUTO = 'auto';\n    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n    var TOUCH_ACTION_NONE = 'none';\n    var TOUCH_ACTION_PAN_X = 'pan-x';\n    var TOUCH_ACTION_PAN_Y = 'pan-y';\n    var TOUCH_ACTION_MAP = getTouchActionProps();\n\n    /**\n     * Touch Action\n     * sets the touchAction property or uses the js alternative\n     * @param {Manager} manager\n     * @param {String} value\n     * @constructor\n     */\n    function TouchAction(manager, value) {\n        this.manager = manager;\n        this.set(value);\n    }\n\n    TouchAction.prototype = {\n        /**\n         * set the touchAction value on the element or enable the polyfill\n         * @param {String} value\n         */\n        set: function set(value) {\n            // find out the touch-action by the event handlers\n            if (value == TOUCH_ACTION_COMPUTE) {\n                value = this.compute();\n            }\n\n            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n            }\n            this.actions = value.toLowerCase().trim();\n        },\n\n        /**\n         * just re-set the touchAction value\n         */\n        update: function update() {\n            this.set(this.manager.options.touchAction);\n        },\n\n        /**\n         * compute the value for the touchAction property based on the recognizer's settings\n         * @returns {String} value\n         */\n        compute: function compute() {\n            var actions = [];\n            each(this.manager.recognizers, function (recognizer) {\n                if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                    actions = actions.concat(recognizer.getTouchAction());\n                }\n            });\n            return cleanTouchActions(actions.join(' '));\n        },\n\n        /**\n         * this method is called on each input cycle and provides the preventing of the browser behavior\n         * @param {Object} input\n         */\n        preventDefaults: function preventDefaults(input) {\n            var srcEvent = input.srcEvent;\n            var direction = input.offsetDirection;\n\n            // if the touch action did prevented once this session\n            if (this.manager.session.prevented) {\n                srcEvent.preventDefault();\n                return;\n            }\n\n            var actions = this.actions;\n            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n            if (hasNone) {\n                //do not prevent defaults if this is a tap gesture\n\n                var isTapPointer = input.pointers.length === 1;\n                var isTapMovement = input.distance < 2;\n                var isTapTouchTime = input.deltaTime < 250;\n\n                if (isTapPointer && isTapMovement && isTapTouchTime) {\n                    return;\n                }\n            }\n\n            if (hasPanX && hasPanY) {\n                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n                return;\n            }\n\n            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n                return this.preventSrc(srcEvent);\n            }\n        },\n\n        /**\n         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n         * @param {Object} srcEvent\n         */\n        preventSrc: function preventSrc(srcEvent) {\n            this.manager.session.prevented = true;\n            srcEvent.preventDefault();\n        }\n    };\n\n    /**\n     * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n     * @param {String} actions\n     * @returns {*}\n     */\n    function cleanTouchActions(actions) {\n        // none\n        if (inStr(actions, TOUCH_ACTION_NONE)) {\n            return TOUCH_ACTION_NONE;\n        }\n\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n        // if both pan-x and pan-y are set (different recognizers\n        // for different directions, e.g. horizontal pan but vertical swipe?)\n        // we need none (as otherwise with pan-x pan-y combined none of these\n        // recognizers will work, since the browser would handle all panning\n        if (hasPanX && hasPanY) {\n            return TOUCH_ACTION_NONE;\n        }\n\n        // pan-x OR pan-y\n        if (hasPanX || hasPanY) {\n            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n        }\n\n        // manipulation\n        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n            return TOUCH_ACTION_MANIPULATION;\n        }\n\n        return TOUCH_ACTION_AUTO;\n    }\n\n    function getTouchActionProps() {\n        if (!NATIVE_TOUCH_ACTION) {\n            return false;\n        }\n        var touchMap = {};\n        var cssSupports = window.CSS && window.CSS.supports;\n        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n\n            // If css.supports is not supported but there is native touch-action assume it supports\n            // all values. This is the case for IE 10 and 11.\n            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n        });\n        return touchMap;\n    }\n\n    /**\n     * Recognizer flow explained; *\n     * All recognizers have the initial state of POSSIBLE when a input session starts.\n     * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n     * Example session for mouse-input: mousedown -> mousemove -> mouseup\n     *\n     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n     * which determines with state it should be.\n     *\n     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n     * POSSIBLE to give it another change on the next cycle.\n     *\n     *               Possible\n     *                  |\n     *            +-----+---------------+\n     *            |                     |\n     *      +-----+-----+               |\n     *      |           |               |\n     *   Failed      Cancelled          |\n     *                          +-------+------+\n     *                          |              |\n     *                      Recognized       Began\n     *                                         |\n     *                                      Changed\n     *                                         |\n     *                                  Ended/Recognized\n     */\n    var STATE_POSSIBLE = 1;\n    var STATE_BEGAN = 2;\n    var STATE_CHANGED = 4;\n    var STATE_ENDED = 8;\n    var STATE_RECOGNIZED = STATE_ENDED;\n    var STATE_CANCELLED = 16;\n    var STATE_FAILED = 32;\n\n    /**\n     * Recognizer\n     * Every recognizer needs to extend from this class.\n     * @constructor\n     * @param {Object} options\n     */\n    function Recognizer(options) {\n        this.options = assign({}, this.defaults, options || {});\n\n        this.id = uniqueId();\n\n        this.manager = null;\n\n        // default is enable true\n        this.options.enable = ifUndefined(this.options.enable, true);\n\n        this.state = STATE_POSSIBLE;\n\n        this.simultaneous = {};\n        this.requireFail = [];\n    }\n\n    Recognizer.prototype = {\n        /**\n         * @virtual\n         * @type {Object}\n         */\n        defaults: {},\n\n        /**\n         * set options\n         * @param {Object} options\n         * @return {Recognizer}\n         */\n        set: function set(options) {\n            assign(this.options, options);\n\n            // also update the touchAction, in case something changed about the directions/enabled state\n            this.manager && this.manager.touchAction.update();\n            return this;\n        },\n\n        /**\n         * recognize simultaneous with an other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        recognizeWith: function recognizeWith(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n                return this;\n            }\n\n            var simultaneous = this.simultaneous;\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            if (!simultaneous[otherRecognizer.id]) {\n                simultaneous[otherRecognizer.id] = otherRecognizer;\n                otherRecognizer.recognizeWith(this);\n            }\n            return this;\n        },\n\n        /**\n         * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            delete this.simultaneous[otherRecognizer.id];\n            return this;\n        },\n\n        /**\n         * recognizer can only run when an other is failing\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        requireFailure: function requireFailure(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n                return this;\n            }\n\n            var requireFail = this.requireFail;\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            if (inArray(requireFail, otherRecognizer) === -1) {\n                requireFail.push(otherRecognizer);\n                otherRecognizer.requireFailure(this);\n            }\n            return this;\n        },\n\n        /**\n         * drop the requireFailure link. it does not remove the link on the other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            var index = inArray(this.requireFail, otherRecognizer);\n            if (index > -1) {\n                this.requireFail.splice(index, 1);\n            }\n            return this;\n        },\n\n        /**\n         * has require failures boolean\n         * @returns {boolean}\n         */\n        hasRequireFailures: function hasRequireFailures() {\n            return this.requireFail.length > 0;\n        },\n\n        /**\n         * if the recognizer can recognize simultaneous with an other recognizer\n         * @param {Recognizer} otherRecognizer\n         * @returns {Boolean}\n         */\n        canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n            return !!this.simultaneous[otherRecognizer.id];\n        },\n\n        /**\n         * You should use `tryEmit` instead of `emit` directly to check\n         * that all the needed recognizers has failed before emitting.\n         * @param {Object} input\n         */\n        emit: function emit(input) {\n            var self = this;\n            var state = this.state;\n\n            function emit(event) {\n                self.manager.emit(event, input);\n            }\n\n            // 'panstart' and 'panmove'\n            if (state < STATE_ENDED) {\n                emit(self.options.event + stateStr(state));\n            }\n\n            emit(self.options.event); // simple 'eventName' events\n\n            if (input.additionalEvent) {\n                // additional event(panleft, panright, pinchin, pinchout...)\n                emit(input.additionalEvent);\n            }\n\n            // panend and pancancel\n            if (state >= STATE_ENDED) {\n                emit(self.options.event + stateStr(state));\n            }\n        },\n\n        /**\n         * Check that all the require failure recognizers has failed,\n         * if true, it emits a gesture event,\n         * otherwise, setup the state to FAILED.\n         * @param {Object} input\n         */\n        tryEmit: function tryEmit(input) {\n            if (this.canEmit()) {\n                return this.emit(input);\n            }\n            // it's failing anyway\n            this.state = STATE_FAILED;\n        },\n\n        /**\n         * can we emit?\n         * @returns {boolean}\n         */\n        canEmit: function canEmit() {\n            var i = 0;\n            while (i < this.requireFail.length) {\n                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        },\n\n        /**\n         * update the recognizer\n         * @param {Object} inputData\n         */\n        recognize: function recognize(inputData) {\n            // make a new copy of the inputData\n            // so we can change the inputData without messing up the other recognizers\n            var inputDataClone = assign({}, inputData);\n\n            // is is enabled and allow recognizing?\n            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n                this.reset();\n                this.state = STATE_FAILED;\n                return;\n            }\n\n            // reset when we've reached the end\n            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n                this.state = STATE_POSSIBLE;\n            }\n\n            this.state = this.process(inputDataClone);\n\n            // the recognizer has recognized a gesture\n            // so trigger an event\n            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n                this.tryEmit(inputDataClone);\n            }\n        },\n\n        /**\n         * return the state of the recognizer\n         * the actual recognizing happens in this method\n         * @virtual\n         * @param {Object} inputData\n         * @returns {Const} STATE\n         */\n        process: function process(inputData) {}, // jshint ignore:line\n\n        /**\n         * return the preferred touch-action\n         * @virtual\n         * @returns {Array}\n         */\n        getTouchAction: function getTouchAction() {},\n\n        /**\n         * called when the gesture isn't allowed to recognize\n         * like when another is being recognized or it is disabled\n         * @virtual\n         */\n        reset: function reset() {}\n    };\n\n    /**\n     * get a usable string, used as event postfix\n     * @param {Const} state\n     * @returns {String} state\n     */\n    function stateStr(state) {\n        if (state & STATE_CANCELLED) {\n            return 'cancel';\n        } else if (state & STATE_ENDED) {\n            return 'end';\n        } else if (state & STATE_CHANGED) {\n            return 'move';\n        } else if (state & STATE_BEGAN) {\n            return 'start';\n        }\n        return '';\n    }\n\n    /**\n     * direction cons to string\n     * @param {Const} direction\n     * @returns {String}\n     */\n    function directionStr(direction) {\n        if (direction == DIRECTION_DOWN) {\n            return 'down';\n        } else if (direction == DIRECTION_UP) {\n            return 'up';\n        } else if (direction == DIRECTION_LEFT) {\n            return 'left';\n        } else if (direction == DIRECTION_RIGHT) {\n            return 'right';\n        }\n        return '';\n    }\n\n    /**\n     * get a recognizer by name if it is bound to a manager\n     * @param {Recognizer|String} otherRecognizer\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer}\n     */\n    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n        var manager = recognizer.manager;\n        if (manager) {\n            return manager.get(otherRecognizer);\n        }\n        return otherRecognizer;\n    }\n\n    /**\n     * This recognizer is just used as a base for the simple attribute recognizers.\n     * @constructor\n     * @extends Recognizer\n     */\n    function AttrRecognizer() {\n        Recognizer.apply(this, arguments);\n    }\n\n    inherit(AttrRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof AttrRecognizer\n         */\n        defaults: {\n            /**\n             * @type {Number}\n             * @default 1\n             */\n            pointers: 1\n        },\n\n        /**\n         * Used to check if it the recognizer receives valid input, like input.distance > 10.\n         * @memberof AttrRecognizer\n         * @param {Object} input\n         * @returns {Boolean} recognized\n         */\n        attrTest: function attrTest(input) {\n            var optionPointers = this.options.pointers;\n            return optionPointers === 0 || input.pointers.length === optionPointers;\n        },\n\n        /**\n         * Process the input and return the state for the recognizer\n         * @memberof AttrRecognizer\n         * @param {Object} input\n         * @returns {*} State\n         */\n        process: function process(input) {\n            var state = this.state;\n            var eventType = input.eventType;\n\n            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n            var isValid = this.attrTest(input);\n\n            // on cancel input and we've recognized before, return STATE_CANCELLED\n            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n                return state | STATE_CANCELLED;\n            } else if (isRecognized || isValid) {\n                if (eventType & INPUT_END) {\n                    return state | STATE_ENDED;\n                } else if (!(state & STATE_BEGAN)) {\n                    return STATE_BEGAN;\n                }\n                return state | STATE_CHANGED;\n            }\n            return STATE_FAILED;\n        }\n    });\n\n    /**\n     * Pan\n     * Recognized when the pointer is down and moved in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function PanRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n\n        this.pX = null;\n        this.pY = null;\n    }\n\n    inherit(PanRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof PanRecognizer\n         */\n        defaults: {\n            event: 'pan',\n            threshold: 10,\n            pointers: 1,\n            direction: DIRECTION_ALL\n        },\n\n        getTouchAction: function getTouchAction() {\n            var direction = this.options.direction;\n            var actions = [];\n            if (direction & DIRECTION_HORIZONTAL) {\n                actions.push(TOUCH_ACTION_PAN_Y);\n            }\n            if (direction & DIRECTION_VERTICAL) {\n                actions.push(TOUCH_ACTION_PAN_X);\n            }\n            return actions;\n        },\n\n        directionTest: function directionTest(input) {\n            var options = this.options;\n            var hasMoved = true;\n            var distance = input.distance;\n            var direction = input.direction;\n            var x = input.deltaX;\n            var y = input.deltaY;\n\n            // lock to axis?\n            if (!(direction & options.direction)) {\n                if (options.direction & DIRECTION_HORIZONTAL) {\n                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                    hasMoved = x != this.pX;\n                    distance = Math.abs(input.deltaX);\n                } else {\n                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n                    hasMoved = y != this.pY;\n                    distance = Math.abs(input.deltaY);\n                }\n            }\n            input.direction = direction;\n            return hasMoved && distance > options.threshold && direction & options.direction;\n        },\n\n        attrTest: function attrTest(input) {\n            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n        },\n\n        emit: function emit(input) {\n\n            this.pX = input.deltaX;\n            this.pY = input.deltaY;\n\n            var direction = directionStr(input.direction);\n\n            if (direction) {\n                input.additionalEvent = this.options.event + direction;\n            }\n            this._super.emit.call(this, input);\n        }\n    });\n\n    /**\n     * Pinch\n     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function PinchRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(PinchRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof PinchRecognizer\n         */\n        defaults: {\n            event: 'pinch',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_NONE];\n        },\n\n        attrTest: function attrTest(input) {\n            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n        },\n\n        emit: function emit(input) {\n            if (input.scale !== 1) {\n                var inOut = input.scale < 1 ? 'in' : 'out';\n                input.additionalEvent = this.options.event + inOut;\n            }\n            this._super.emit.call(this, input);\n        }\n    });\n\n    /**\n     * Press\n     * Recognized when the pointer is down for x ms without any movement.\n     * @constructor\n     * @extends Recognizer\n     */\n    function PressRecognizer() {\n        Recognizer.apply(this, arguments);\n\n        this._timer = null;\n        this._input = null;\n    }\n\n    inherit(PressRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof PressRecognizer\n         */\n        defaults: {\n            event: 'press',\n            pointers: 1,\n            time: 251, // minimal time of the pointer to be pressed\n            threshold: 9 // a minimal movement is ok, but keep it low\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_AUTO];\n        },\n\n        process: function process(input) {\n            var options = this.options;\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTime = input.deltaTime > options.time;\n\n            this._input = input;\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n                this.reset();\n            } else if (input.eventType & INPUT_START) {\n                this.reset();\n                this._timer = setTimeoutContext(function () {\n                    this.state = STATE_RECOGNIZED;\n                    this.tryEmit();\n                }, options.time, this);\n            } else if (input.eventType & INPUT_END) {\n                return STATE_RECOGNIZED;\n            }\n            return STATE_FAILED;\n        },\n\n        reset: function reset() {\n            clearTimeout(this._timer);\n        },\n\n        emit: function emit(input) {\n            if (this.state !== STATE_RECOGNIZED) {\n                return;\n            }\n\n            if (input && input.eventType & INPUT_END) {\n                this.manager.emit(this.options.event + 'up', input);\n            } else {\n                this._input.timeStamp = now();\n                this.manager.emit(this.options.event, this._input);\n            }\n        }\n    });\n\n    /**\n     * Rotate\n     * Recognized when two or more pointer are moving in a circular motion.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function RotateRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(RotateRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof RotateRecognizer\n         */\n        defaults: {\n            event: 'rotate',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_NONE];\n        },\n\n        attrTest: function attrTest(input) {\n            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n        }\n    });\n\n    /**\n     * Swipe\n     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function SwipeRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(SwipeRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof SwipeRecognizer\n         */\n        defaults: {\n            event: 'swipe',\n            threshold: 10,\n            velocity: 0.3,\n            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n            pointers: 1\n        },\n\n        getTouchAction: function getTouchAction() {\n            return PanRecognizer.prototype.getTouchAction.call(this);\n        },\n\n        attrTest: function attrTest(input) {\n            var direction = this.options.direction;\n            var velocity;\n\n            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n                velocity = input.overallVelocity;\n            } else if (direction & DIRECTION_HORIZONTAL) {\n                velocity = input.overallVelocityX;\n            } else if (direction & DIRECTION_VERTICAL) {\n                velocity = input.overallVelocityY;\n            }\n\n            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n        },\n\n        emit: function emit(input) {\n            var direction = directionStr(input.offsetDirection);\n            if (direction) {\n                this.manager.emit(this.options.event + direction, input);\n            }\n\n            this.manager.emit(this.options.event, input);\n        }\n    });\n\n    /**\n     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n     * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n     * a single tap.\n     *\n     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n     * multi-taps being recognized.\n     * @constructor\n     * @extends Recognizer\n     */\n    function TapRecognizer() {\n        Recognizer.apply(this, arguments);\n\n        // previous time and center,\n        // used for tap counting\n        this.pTime = false;\n        this.pCenter = false;\n\n        this._timer = null;\n        this._input = null;\n        this.count = 0;\n    }\n\n    inherit(TapRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof PinchRecognizer\n         */\n        defaults: {\n            event: 'tap',\n            pointers: 1,\n            taps: 1,\n            interval: 300, // max time between the multi-tap taps\n            time: 250, // max time of the pointer to be down (like finger on the screen)\n            threshold: 9, // a minimal movement is ok, but keep it low\n            posThreshold: 10 // a multi-tap can be a bit off the initial position\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_MANIPULATION];\n        },\n\n        process: function process(input) {\n            var options = this.options;\n\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTouchTime = input.deltaTime < options.time;\n\n            this.reset();\n\n            if (input.eventType & INPUT_START && this.count === 0) {\n                return this.failTimeout();\n            }\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if (validMovement && validTouchTime && validPointers) {\n                if (input.eventType != INPUT_END) {\n                    return this.failTimeout();\n                }\n\n                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n                this.pTime = input.timeStamp;\n                this.pCenter = input.center;\n\n                if (!validMultiTap || !validInterval) {\n                    this.count = 1;\n                } else {\n                    this.count += 1;\n                }\n\n                this._input = input;\n\n                // if tap count matches we have recognized it,\n                // else it has began recognizing...\n                var tapCount = this.count % options.taps;\n                if (tapCount === 0) {\n                    // no failing requirements, immediately trigger the tap event\n                    // or wait as long as the multitap interval to trigger\n                    if (!this.hasRequireFailures()) {\n                        return STATE_RECOGNIZED;\n                    } else {\n                        this._timer = setTimeoutContext(function () {\n                            this.state = STATE_RECOGNIZED;\n                            this.tryEmit();\n                        }, options.interval, this);\n                        return STATE_BEGAN;\n                    }\n                }\n            }\n            return STATE_FAILED;\n        },\n\n        failTimeout: function failTimeout() {\n            this._timer = setTimeoutContext(function () {\n                this.state = STATE_FAILED;\n            }, this.options.interval, this);\n            return STATE_FAILED;\n        },\n\n        reset: function reset() {\n            clearTimeout(this._timer);\n        },\n\n        emit: function emit() {\n            if (this.state == STATE_RECOGNIZED) {\n                this._input.tapCount = this.count;\n                this.manager.emit(this.options.event, this._input);\n            }\n        }\n    });\n\n    /**\n     * Simple way to create a manager with a default set of recognizers.\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n    function Hammer(element, options) {\n        options = options || {};\n        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n        return new Manager(element, options);\n    }\n\n    /**\n     * @const {string}\n     */\n    Hammer.VERSION = '2.0.7';\n\n    /**\n     * default settings\n     * @namespace\n     */\n    Hammer.defaults = {\n        /**\n         * set if DOM events are being triggered.\n         * But this is slower and unused by simple implementations, so disabled by default.\n         * @type {Boolean}\n         * @default false\n         */\n        domEvents: false,\n\n        /**\n         * The value for the touchAction property/fallback.\n         * When set to `compute` it will magically set the correct value based on the added recognizers.\n         * @type {String}\n         * @default compute\n         */\n        touchAction: TOUCH_ACTION_COMPUTE,\n\n        /**\n         * @type {Boolean}\n         * @default true\n         */\n        enable: true,\n\n        /**\n         * EXPERIMENTAL FEATURE -- can be removed/changed\n         * Change the parent input target element.\n         * If Null, then it is being set the to main element.\n         * @type {Null|EventTarget}\n         * @default null\n         */\n        inputTarget: null,\n\n        /**\n         * force an input class\n         * @type {Null|Function}\n         * @default null\n         */\n        inputClass: null,\n\n        /**\n         * Default recognizer setup when calling `Hammer()`\n         * When creating a new Manager these will be skipped.\n         * @type {Array}\n         */\n        preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],\n\n        /**\n         * Some CSS properties can be used to improve the working of Hammer.\n         * Add them to this method and they will be set when creating a new Manager.\n         * @namespace\n         */\n        cssProps: {\n            /**\n             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n             * @type {String}\n             * @default 'none'\n             */\n            userSelect: 'none',\n\n            /**\n             * Disable the Windows Phone grippers when pressing an element.\n             * @type {String}\n             * @default 'none'\n             */\n            touchSelect: 'none',\n\n            /**\n             * Disables the default callout shown when you touch and hold a touch target.\n             * On iOS, when you touch and hold a touch target such as a link, Safari displays\n             * a callout containing information about the link. This property allows you to disable that callout.\n             * @type {String}\n             * @default 'none'\n             */\n            touchCallout: 'none',\n\n            /**\n             * Specifies whether zooming is enabled. Used by IE10>\n             * @type {String}\n             * @default 'none'\n             */\n            contentZooming: 'none',\n\n            /**\n             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n             * @type {String}\n             * @default 'none'\n             */\n            userDrag: 'none',\n\n            /**\n             * Overrides the highlight color shown when the user taps a link or a JavaScript\n             * clickable element in iOS. This property obeys the alpha value, if specified.\n             * @type {String}\n             * @default 'rgba(0,0,0,0)'\n             */\n            tapHighlightColor: 'rgba(0,0,0,0)'\n        }\n    };\n\n    var STOP = 1;\n    var FORCED_STOP = 2;\n\n    /**\n     * Manager\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n    function Manager(element, options) {\n        this.options = assign({}, Hammer.defaults, options || {});\n\n        this.options.inputTarget = this.options.inputTarget || element;\n\n        this.handlers = {};\n        this.session = {};\n        this.recognizers = [];\n        this.oldCssProps = {};\n\n        this.element = element;\n        this.input = createInputInstance(this);\n        this.touchAction = new TouchAction(this, this.options.touchAction);\n\n        toggleCssProps(this, true);\n\n        each(this.options.recognizers, function (item) {\n            var recognizer = this.add(new item[0](item[1]));\n            item[2] && recognizer.recognizeWith(item[2]);\n            item[3] && recognizer.requireFailure(item[3]);\n        }, this);\n    }\n\n    Manager.prototype = {\n        /**\n         * set options\n         * @param {Object} options\n         * @returns {Manager}\n         */\n        set: function set(options) {\n            assign(this.options, options);\n\n            // Options that need a little more setup\n            if (options.touchAction) {\n                this.touchAction.update();\n            }\n            if (options.inputTarget) {\n                // Clean up existing event listeners and reinitialize\n                this.input.destroy();\n                this.input.target = options.inputTarget;\n                this.input.init();\n            }\n            return this;\n        },\n\n        /**\n         * stop recognizing for this session.\n         * This session will be discarded, when a new [input]start event is fired.\n         * When forced, the recognizer cycle is stopped immediately.\n         * @param {Boolean} [force]\n         */\n        stop: function stop(force) {\n            this.session.stopped = force ? FORCED_STOP : STOP;\n        },\n\n        /**\n         * run the recognizers!\n         * called by the inputHandler function on every movement of the pointers (touches)\n         * it walks through all the recognizers and tries to detect the gesture that is being made\n         * @param {Object} inputData\n         */\n        recognize: function recognize(inputData) {\n            var session = this.session;\n            if (session.stopped) {\n                return;\n            }\n\n            // run the touch-action polyfill\n            this.touchAction.preventDefaults(inputData);\n\n            var recognizer;\n            var recognizers = this.recognizers;\n\n            // this holds the recognizer that is being recognized.\n            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n            // if no recognizer is detecting a thing, it is set to `null`\n            var curRecognizer = session.curRecognizer;\n\n            // reset when the last recognizer is recognized\n            // or when we're in a new session\n            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n                curRecognizer = session.curRecognizer = null;\n            }\n\n            var i = 0;\n            while (i < recognizers.length) {\n                recognizer = recognizers[i];\n\n                // find out if we are allowed try to recognize the input for this one.\n                // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n                //      that is being recognized.\n                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n                //      this can be setup with the `recognizeWith()` method on the recognizer.\n                if (session.stopped !== FORCED_STOP && ( // 1\n                !curRecognizer || recognizer == curRecognizer || // 2\n                recognizer.canRecognizeWith(curRecognizer))) {\n                    // 3\n                    recognizer.recognize(inputData);\n                } else {\n                    recognizer.reset();\n                }\n\n                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n                // current active recognizer. but only if we don't already have an active recognizer\n                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                    curRecognizer = session.curRecognizer = recognizer;\n                }\n                i++;\n            }\n        },\n\n        /**\n         * get a recognizer by its event name.\n         * @param {Recognizer|String} recognizer\n         * @returns {Recognizer|Null}\n         */\n        get: function get(recognizer) {\n            if (recognizer instanceof Recognizer) {\n                return recognizer;\n            }\n\n            var recognizers = this.recognizers;\n            for (var i = 0; i < recognizers.length; i++) {\n                if (recognizers[i].options.event == recognizer) {\n                    return recognizers[i];\n                }\n            }\n            return null;\n        },\n\n        /**\n         * add a recognizer to the manager\n         * existing recognizers with the same event name will be removed\n         * @param {Recognizer} recognizer\n         * @returns {Recognizer|Manager}\n         */\n        add: function add(recognizer) {\n            if (invokeArrayArg(recognizer, 'add', this)) {\n                return this;\n            }\n\n            // remove existing\n            var existing = this.get(recognizer.options.event);\n            if (existing) {\n                this.remove(existing);\n            }\n\n            this.recognizers.push(recognizer);\n            recognizer.manager = this;\n\n            this.touchAction.update();\n            return recognizer;\n        },\n\n        /**\n         * remove a recognizer by name or instance\n         * @param {Recognizer|String} recognizer\n         * @returns {Manager}\n         */\n        remove: function remove(recognizer) {\n            if (invokeArrayArg(recognizer, 'remove', this)) {\n                return this;\n            }\n\n            recognizer = this.get(recognizer);\n\n            // let's make sure this recognizer exists\n            if (recognizer) {\n                var recognizers = this.recognizers;\n                var index = inArray(recognizers, recognizer);\n\n                if (index !== -1) {\n                    recognizers.splice(index, 1);\n                    this.touchAction.update();\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * bind event\n         * @param {String} events\n         * @param {Function} handler\n         * @returns {EventEmitter} this\n         */\n        on: function on(events, handler) {\n            if (events === undefined) {\n                return;\n            }\n            if (handler === undefined) {\n                return;\n            }\n\n            var handlers = this.handlers;\n            each(splitStr(events), function (event) {\n                handlers[event] = handlers[event] || [];\n                handlers[event].push(handler);\n            });\n            return this;\n        },\n\n        /**\n         * unbind event, leave emit blank to remove all handlers\n         * @param {String} events\n         * @param {Function} [handler]\n         * @returns {EventEmitter} this\n         */\n        off: function off(events, handler) {\n            if (events === undefined) {\n                return;\n            }\n\n            var handlers = this.handlers;\n            each(splitStr(events), function (event) {\n                if (!handler) {\n                    delete handlers[event];\n                } else {\n                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n                }\n            });\n            return this;\n        },\n\n        /**\n         * emit event to the listeners\n         * @param {String} event\n         * @param {Object} data\n         */\n        emit: function emit(event, data) {\n            // we also want to trigger dom events\n            if (this.options.domEvents) {\n                triggerDomEvent(event, data);\n            }\n\n            // no handlers, so skip it all\n            var handlers = this.handlers[event] && this.handlers[event].slice();\n            if (!handlers || !handlers.length) {\n                return;\n            }\n\n            data.type = event;\n            data.preventDefault = function () {\n                data.srcEvent.preventDefault();\n            };\n\n            var i = 0;\n            while (i < handlers.length) {\n                handlers[i](data);\n                i++;\n            }\n        },\n\n        /**\n         * destroy the manager and unbinds all events\n         * it doesn't unbind dom events, that is the user own responsibility\n         */\n        destroy: function destroy() {\n            this.element && toggleCssProps(this, false);\n\n            this.handlers = {};\n            this.session = {};\n            this.input.destroy();\n            this.element = null;\n        }\n    };\n\n    /**\n     * add/remove the css properties as defined in manager.options.cssProps\n     * @param {Manager} manager\n     * @param {Boolean} add\n     */\n    function toggleCssProps(manager, add) {\n        var element = manager.element;\n        if (!element.style) {\n            return;\n        }\n        var prop;\n        each(manager.options.cssProps, function (value, name) {\n            prop = prefixed(element.style, name);\n            if (add) {\n                manager.oldCssProps[prop] = element.style[prop];\n                element.style[prop] = value;\n            } else {\n                element.style[prop] = manager.oldCssProps[prop] || '';\n            }\n        });\n        if (!add) {\n            manager.oldCssProps = {};\n        }\n    }\n\n    /**\n     * trigger dom event\n     * @param {String} event\n     * @param {Object} data\n     */\n    function triggerDomEvent(event, data) {\n        var gestureEvent = document.createEvent('Event');\n        gestureEvent.initEvent(event, true, true);\n        gestureEvent.gesture = data;\n        data.target.dispatchEvent(gestureEvent);\n    }\n\n    assign(Hammer, {\n        INPUT_START: INPUT_START,\n        INPUT_MOVE: INPUT_MOVE,\n        INPUT_END: INPUT_END,\n        INPUT_CANCEL: INPUT_CANCEL,\n\n        STATE_POSSIBLE: STATE_POSSIBLE,\n        STATE_BEGAN: STATE_BEGAN,\n        STATE_CHANGED: STATE_CHANGED,\n        STATE_ENDED: STATE_ENDED,\n        STATE_RECOGNIZED: STATE_RECOGNIZED,\n        STATE_CANCELLED: STATE_CANCELLED,\n        STATE_FAILED: STATE_FAILED,\n\n        DIRECTION_NONE: DIRECTION_NONE,\n        DIRECTION_LEFT: DIRECTION_LEFT,\n        DIRECTION_RIGHT: DIRECTION_RIGHT,\n        DIRECTION_UP: DIRECTION_UP,\n        DIRECTION_DOWN: DIRECTION_DOWN,\n        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n        DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n        DIRECTION_ALL: DIRECTION_ALL,\n\n        Manager: Manager,\n        Input: Input,\n        TouchAction: TouchAction,\n\n        TouchInput: TouchInput,\n        MouseInput: MouseInput,\n        PointerEventInput: PointerEventInput,\n        TouchMouseInput: TouchMouseInput,\n        SingleTouchInput: SingleTouchInput,\n\n        Recognizer: Recognizer,\n        AttrRecognizer: AttrRecognizer,\n        Tap: TapRecognizer,\n        Pan: PanRecognizer,\n        Swipe: SwipeRecognizer,\n        Pinch: PinchRecognizer,\n        Rotate: RotateRecognizer,\n        Press: PressRecognizer,\n\n        on: addEventListeners,\n        off: removeEventListeners,\n        each: each,\n        merge: merge,\n        extend: extend,\n        assign: assign,\n        inherit: inherit,\n        bindFn: bindFn,\n        prefixed: prefixed\n    });\n\n    // this prevents errors when Hammer is loaded in the presence of an AMD\n    //  style loader but by script tag, not by the loader.\n    var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n    freeGlobal.Hammer = Hammer;\n\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n            return Hammer;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(window, document, 'Hammer');\n\n//# sourceURL=webpack:///./node_modules/hammerjs/hammer.js?");

/***/ }),

/***/ "./node_modules/insert-after/index.es5.js":
/*!************************************************!*\
  !*** ./node_modules/insert-after/index.es5.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = insertAfter;\nfunction insertAfter(node, _ref) {\n  var nextSibling = _ref.nextSibling,\n      parentNode = _ref.parentNode;\n\n  return parentNode.insertBefore(node, nextSibling);\n}\nmodule.exports = exports['default'];\n\n//# sourceURL=webpack:///./node_modules/insert-after/index.es5.js?");

/***/ }),

/***/ "./node_modules/is-pointer-inside/index.es5.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-pointer-inside/index.es5.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = isPointerInside;\n\nvar _globalOffset = __webpack_require__(/*! global-offset */ \"./node_modules/global-offset/index.es5.js\");\n\nvar _globalOffset2 = _interopRequireDefault(_globalOffset);\n\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\n\nfunction isPointerInside(el, _ref) {\n    var pageX = _ref.pageX,\n        pageY = _ref.pageY;\n\n    var _offset = (0, _globalOffset2.default)(el),\n        left = _offset.left,\n        top = _offset.top;\n\n    var offsetWidth = el.offsetWidth,\n        offsetHeight = el.offsetHeight;\n\n    return pageX >= left && pageX <= left + offsetWidth && pageY >= top && pageY <= top + offsetHeight;\n}\nmodule.exports = exports['default'];\n\n//# sourceURL=webpack:///./node_modules/is-pointer-inside/index.es5.js?");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * jQuery JavaScript Library v3.3.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2018-01-20T17:24Z\n */\n(function (global, factory) {\n\n\t\"use strict\";\n\n\tif (( false ? undefined : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ? factory(global, true) : function (w) {\n\t\t\tif (!w.document) {\n\t\t\t\tthrow new Error(\"jQuery requires a window with a document\");\n\t\t\t}\n\t\t\treturn factory(w);\n\t\t};\n\t} else {\n\t\tfactory(global);\n\t}\n\n\t// Pass this if window is not defined yet\n})(typeof window !== \"undefined\" ? window : undefined, function (window, noGlobal) {\n\n\t// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n\t// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n\t// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n\t// enough that all such attempts are guarded in a try block.\n\t\"use strict\";\n\n\tvar arr = [];\n\n\tvar document = window.document;\n\n\tvar getProto = Object.getPrototypeOf;\n\n\tvar _slice = arr.slice;\n\n\tvar concat = arr.concat;\n\n\tvar push = arr.push;\n\n\tvar indexOf = arr.indexOf;\n\n\tvar class2type = {};\n\n\tvar toString = class2type.toString;\n\n\tvar hasOwn = class2type.hasOwnProperty;\n\n\tvar fnToString = hasOwn.toString;\n\n\tvar ObjectFunctionString = fnToString.call(Object);\n\n\tvar support = {};\n\n\tvar isFunction = function isFunction(obj) {\n\n\t\t// Support: Chrome <=57, Firefox <=52\n\t\t// In some browsers, typeof returns \"function\" for HTML <object> elements\n\t\t// (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n\t\t// We don't want to classify *any* DOM node as a function.\n\t\treturn typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n\t};\n\n\tvar isWindow = function isWindow(obj) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval(code, doc, node) {\n\t\tdoc = doc || document;\n\n\t\tvar i,\n\t\t    script = doc.createElement(\"script\");\n\n\t\tscript.text = code;\n\t\tif (node) {\n\t\t\tfor (i in preservedScriptAttributes) {\n\t\t\t\tif (node[i]) {\n\t\t\t\t\tscript[i] = node[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild(script).parentNode.removeChild(script);\n\t}\n\n\tfunction toType(obj) {\n\t\tif (obj == null) {\n\t\t\treturn obj + \"\";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t}\n\t/* global Symbol */\n\t// Defining this global in .eslintrc.json would create a danger of using the global\n\t// unguarded in another place, it seems safer to define global only for this module\n\n\n\tvar version = \"3.3.1\",\n\n\n\t// Define a local copy of jQuery\n\tjQuery = function jQuery(selector, context) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init(selector, context);\n\t},\n\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n\tjQuery.fn = jQuery.prototype = {\n\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\n\t\tconstructor: jQuery,\n\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\n\t\ttoArray: function toArray() {\n\t\t\treturn _slice.call(this);\n\t\t},\n\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function get(num) {\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tif (num == null) {\n\t\t\t\treturn _slice.call(this);\n\t\t\t}\n\n\t\t\t// Return just the one element from the set\n\t\t\treturn num < 0 ? this[num + this.length] : this[num];\n\t\t},\n\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function pushStack(elems) {\n\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge(this.constructor(), elems);\n\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\n\t\t// Execute a callback for every element in the matched set.\n\t\teach: function each(callback) {\n\t\t\treturn jQuery.each(this, callback);\n\t\t},\n\n\t\tmap: function map(callback) {\n\t\t\treturn this.pushStack(jQuery.map(this, function (elem, i) {\n\t\t\t\treturn callback.call(elem, i, elem);\n\t\t\t}));\n\t\t},\n\n\t\tslice: function slice() {\n\t\t\treturn this.pushStack(_slice.apply(this, arguments));\n\t\t},\n\n\t\tfirst: function first() {\n\t\t\treturn this.eq(0);\n\t\t},\n\n\t\tlast: function last() {\n\t\t\treturn this.eq(-1);\n\t\t},\n\n\t\teq: function eq(i) {\n\t\t\tvar len = this.length,\n\t\t\t    j = +i + (i < 0 ? len : 0);\n\t\t\treturn this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n\t\t},\n\n\t\tend: function end() {\n\t\t\treturn this.prevObject || this.constructor();\n\t\t},\n\n\t\t// For internal use only.\n\t\t// Behaves like an Array's method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: arr.sort,\n\t\tsplice: arr.splice\n\t};\n\n\tjQuery.extend = jQuery.fn.extend = function () {\n\t\tvar options,\n\t\t    name,\n\t\t    src,\n\t\t    copy,\n\t\t    copyIsArray,\n\t\t    clone,\n\t\t    target = arguments[0] || {},\n\t\t    i = 1,\n\t\t    length = arguments.length,\n\t\t    deep = false;\n\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === \"boolean\") {\n\t\t\tdeep = target;\n\n\t\t\t// Skip the boolean and the target\n\t\t\ttarget = arguments[i] || {};\n\t\t\ti++;\n\t\t}\n\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) !== \"object\" && !isFunction(target)) {\n\t\t\ttarget = {};\n\t\t}\n\n\t\t// Extend jQuery itself if only one argument is passed\n\t\tif (i === length) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\n\t\tfor (; i < length; i++) {\n\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ((options = arguments[i]) != null) {\n\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target === copy) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && Array.isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = jQuery.extend(deep, clone, copy);\n\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (copy !== undefined) {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\n\tjQuery.extend({\n\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\n\t\terror: function error(msg) {\n\t\t\tthrow new Error(msg);\n\t\t},\n\n\t\tnoop: function noop() {},\n\n\t\tisPlainObject: function isPlainObject(obj) {\n\t\t\tvar proto, Ctor;\n\n\t\t\t// Detect obvious negatives\n\t\t\t// Use toString instead of jQuery.type to catch host objects\n\t\t\tif (!obj || toString.call(obj) !== \"[object Object]\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tproto = getProto(obj);\n\n\t\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\t\tif (!proto) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\t\tCtor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n\t\t\treturn typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n\t\t},\n\n\t\tisEmptyObject: function isEmptyObject(obj) {\n\n\t\t\t/* eslint-disable no-unused-vars */\n\t\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\t\tvar name;\n\n\t\t\tfor (name in obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t// Evaluates a script in a global context\n\t\tglobalEval: function globalEval(code) {\n\t\t\tDOMEval(code);\n\t\t},\n\n\t\teach: function each(obj, callback) {\n\t\t\tvar length,\n\t\t\t    i = 0;\n\n\t\t\tif (isArrayLike(obj)) {\n\t\t\t\tlength = obj.length;\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tif (callback.call(obj[i], i, obj[i]) === false) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i in obj) {\n\t\t\t\t\tif (callback.call(obj[i], i, obj[i]) === false) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t},\n\n\t\t// Support: Android <=4.0 only\n\t\ttrim: function trim(text) {\n\t\t\treturn text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n\t\t},\n\n\t\t// results is for internal usage only\n\t\tmakeArray: function makeArray(arr, results) {\n\t\t\tvar ret = results || [];\n\n\t\t\tif (arr != null) {\n\t\t\t\tif (isArrayLike(Object(arr))) {\n\t\t\t\t\tjQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call(ret, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\tinArray: function inArray(elem, arr, i) {\n\t\t\treturn arr == null ? -1 : indexOf.call(arr, elem, i);\n\t\t},\n\n\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\tmerge: function merge(first, second) {\n\t\t\tvar len = +second.length,\n\t\t\t    j = 0,\n\t\t\t    i = first.length;\n\n\t\t\tfor (; j < len; j++) {\n\t\t\t\tfirst[i++] = second[j];\n\t\t\t}\n\n\t\t\tfirst.length = i;\n\n\t\t\treturn first;\n\t\t},\n\n\t\tgrep: function grep(elems, callback, invert) {\n\t\t\tvar callbackInverse,\n\t\t\t    matches = [],\n\t\t\t    i = 0,\n\t\t\t    length = elems.length,\n\t\t\t    callbackExpect = !invert;\n\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor (; i < length; i++) {\n\t\t\t\tcallbackInverse = !callback(elems[i], i);\n\t\t\t\tif (callbackInverse !== callbackExpect) {\n\t\t\t\t\tmatches.push(elems[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn matches;\n\t\t},\n\n\t\t// arg is for internal usage only\n\t\tmap: function map(elems, callback, arg) {\n\t\t\tvar length,\n\t\t\t    value,\n\t\t\t    i = 0,\n\t\t\t    ret = [];\n\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif (isArrayLike(elems)) {\n\t\t\t\tlength = elems.length;\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tvalue = callback(elems[i], i, arg);\n\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tret.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor (i in elems) {\n\t\t\t\t\tvalue = callback(elems[i], i, arg);\n\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tret.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply([], ret);\n\t\t},\n\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t});\n\n\tif (typeof Symbol === \"function\") {\n\t\tjQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n\t}\n\n\t// Populate the class2type map\n\tjQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (i, name) {\n\t\tclass2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n\t});\n\n\tfunction isArrayLike(obj) {\n\n\t\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t\t// `in` check used to prevent JIT error (gh-2145)\n\t\t// hasOwn isn't used here due to false negatives\n\t\t// regarding Nodelist length in IE\n\t\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\t    type = toType(obj);\n\n\t\tif (isFunction(obj) || isWindow(obj)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n  * Sizzle CSS Selector Engine v2.3.3\n  * https://sizzlejs.com/\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license\n  * http://jquery.org/license\n  *\n  * Date: 2016-08-08\n  */\n\tfunction (window) {\n\n\t\tvar i,\n\t\t    support,\n\t\t    Expr,\n\t\t    getText,\n\t\t    isXML,\n\t\t    tokenize,\n\t\t    compile,\n\t\t    select,\n\t\t    outermostContext,\n\t\t    sortInput,\n\t\t    hasDuplicate,\n\n\n\t\t// Local document vars\n\t\tsetDocument,\n\t\t    document,\n\t\t    docElem,\n\t\t    documentIsHTML,\n\t\t    rbuggyQSA,\n\t\t    rbuggyMatches,\n\t\t    matches,\n\t\t    contains,\n\n\n\t\t// Instance-specific data\n\t\texpando = \"sizzle\" + 1 * new Date(),\n\t\t    preferredDoc = window.document,\n\t\t    dirruns = 0,\n\t\t    done = 0,\n\t\t    classCache = createCache(),\n\t\t    tokenCache = createCache(),\n\t\t    compilerCache = createCache(),\n\t\t    sortOrder = function sortOrder(a, b) {\n\t\t\tif (a === b) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\n\t\t// Instance methods\n\t\thasOwn = {}.hasOwnProperty,\n\t\t    arr = [],\n\t\t    pop = arr.pop,\n\t\t    push_native = arr.push,\n\t\t    push = arr.push,\n\t\t    slice = arr.slice,\n\n\t\t// Use a stripped-down indexOf as it's faster than native\n\t\t// https://jsperf.com/thor-indexof-vs-for/5\n\t\tindexOf = function indexOf(list, elem) {\n\t\t\tvar i = 0,\n\t\t\t    len = list.length;\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (list[i] === elem) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\t    booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\n\t\t// Regular expressions\n\n\t\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\n\t\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n\t\t    pseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" + \")\\\\)|)\",\n\n\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n\t\t    rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n\t\t    rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n\t\t    rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n\t\t    rattributeQuotes = new RegExp(\"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\"),\n\t\t    rpseudo = new RegExp(pseudos),\n\t\t    ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n\t\t    matchExpr = {\n\t\t\t\"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n\t\t\t\"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n\t\t\t\"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n\t\t\t\"ATTR\": new RegExp(\"^\" + attributes),\n\t\t\t\"PSEUDO\": new RegExp(\"^\" + pseudos),\n\t\t\t\"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n\t\t\t\"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t\"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n\t\t},\n\t\t    rinputs = /^(?:input|select|textarea|button)$/i,\n\t\t    rheader = /^h\\d$/i,\n\t\t    rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t\t    rsibling = /[+~]/,\n\n\n\t\t// CSS escapes\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n\t\t    funescape = function funescape(_, escaped, escapedWhitespace) {\n\t\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox<24\n\t\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\t\treturn high !== high || escapedWhitespace ? escaped : high < 0 ?\n\t\t\t// BMP codepoint\n\t\t\tString.fromCharCode(high + 0x10000) :\n\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\tString.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n\t\t},\n\n\n\t\t// CSS string/identifier serialization\n\t\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\t\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\t\t    fcssescape = function fcssescape(ch, asCodePoint) {\n\t\t\tif (asCodePoint) {\n\n\t\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\t\tif (ch === \"\\0\") {\n\t\t\t\t\treturn \"\\uFFFD\";\n\t\t\t\t}\n\n\t\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\t\treturn ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n\t\t\t}\n\n\t\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\t\treturn \"\\\\\" + ch;\n\t\t},\n\n\n\t\t// Used for iframes\n\t\t// See setDocument()\n\t\t// Removing the function wrapper causes a \"Permission Denied\"\n\t\t// error in IE\n\t\tunloadHandler = function unloadHandler() {\n\t\t\tsetDocument();\n\t\t},\n\t\t    disabledAncestor = addCombinator(function (elem) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t}, { dir: \"parentNode\", next: \"legend\" });\n\n\t\t// Optimize for push.apply( _, NodeList )\n\t\ttry {\n\t\t\tpush.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\n\t\t\t// Support: Android<4.0\n\t\t\t// Detect silently failing push.apply\n\t\t\tarr[preferredDoc.childNodes.length].nodeType;\n\t\t} catch (e) {\n\t\t\tpush = { apply: arr.length ?\n\n\t\t\t\t// Leverage slice if possible\n\t\t\t\tfunction (target, els) {\n\t\t\t\t\tpush_native.apply(target, slice.call(els));\n\t\t\t\t} :\n\n\t\t\t\t// Support: IE<9\n\t\t\t\t// Otherwise append directly\n\t\t\t\tfunction (target, els) {\n\t\t\t\t\tvar j = target.length,\n\t\t\t\t\t    i = 0;\n\t\t\t\t\t// Can't trust NodeList.length\n\t\t\t\t\twhile (target[j++] = els[i++]) {}\n\t\t\t\t\ttarget.length = j - 1;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction Sizzle(selector, context, results, seed) {\n\t\t\tvar m,\n\t\t\t    i,\n\t\t\t    elem,\n\t\t\t    nid,\n\t\t\t    match,\n\t\t\t    groups,\n\t\t\t    newSelector,\n\t\t\t    newContext = context && context.ownerDocument,\n\n\n\t\t\t// nodeType defaults to 9, since context defaults to document\n\t\t\tnodeType = context ? context.nodeType : 9;\n\n\t\t\tresults = results || [];\n\n\t\t\t// Return early from calls with invalid selector or context\n\t\t\tif (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n\n\t\t\t\treturn results;\n\t\t\t}\n\n\t\t\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\t\t\tif (!seed) {\n\n\t\t\t\tif ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n\t\t\t\t\tsetDocument(context);\n\t\t\t\t}\n\t\t\t\tcontext = context || document;\n\n\t\t\t\tif (documentIsHTML) {\n\n\t\t\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\t\t\tif (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n\n\t\t\t\t\t\t// ID selector\n\t\t\t\t\t\tif (m = match[1]) {\n\n\t\t\t\t\t\t\t// Document context\n\t\t\t\t\t\t\tif (nodeType === 9) {\n\t\t\t\t\t\t\t\tif (elem = context.getElementById(m)) {\n\n\t\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\t\tif (elem.id === m) {\n\t\t\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Element context\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\tif (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n\n\t\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Type selector\n\t\t\t\t\t\t} else if (match[2]) {\n\t\t\t\t\t\t\tpush.apply(results, context.getElementsByTagName(selector));\n\t\t\t\t\t\t\treturn results;\n\n\t\t\t\t\t\t\t// Class selector\n\t\t\t\t\t\t} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n\n\t\t\t\t\t\t\tpush.apply(results, context.getElementsByClassName(m));\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Take advantage of querySelectorAll\n\t\t\t\t\tif (support.qsa && !compilerCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n\n\t\t\t\t\t\tif (nodeType !== 1) {\n\t\t\t\t\t\t\tnewContext = context;\n\t\t\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t\t\t\t// Support: IE <=8\n\t\t\t\t\t\t\t// Exclude object elements\n\t\t\t\t\t\t} else if (context.nodeName.toLowerCase() !== \"object\") {\n\n\t\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\t\tif (nid = context.getAttribute(\"id\")) {\n\t\t\t\t\t\t\t\tnid = nid.replace(rcssescape, fcssescape);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontext.setAttribute(\"id\", nid = expando);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\t\t\tgroups = tokenize(selector);\n\t\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector(groups[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewSelector = groups.join(\",\");\n\n\t\t\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\t\t\tnewContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (newSelector) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tpush.apply(results, newContext.querySelectorAll(newSelector));\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t} catch (qsaError) {} finally {\n\t\t\t\t\t\t\t\tif (nid === expando) {\n\t\t\t\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All others\n\t\t\treturn select(selector.replace(rtrim, \"$1\"), context, results, seed);\n\t\t}\n\n\t\t/**\n   * Create key-value caches of limited size\n   * @returns {function(string, object)} Returns the Object data after storing it on itself with\n   *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n   *\tdeleting the oldest entry\n   */\n\t\tfunction createCache() {\n\t\t\tvar keys = [];\n\n\t\t\tfunction cache(key, value) {\n\t\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\t\tif (keys.push(key + \" \") > Expr.cacheLength) {\n\t\t\t\t\t// Only keep the most recent entries\n\t\t\t\t\tdelete cache[keys.shift()];\n\t\t\t\t}\n\t\t\t\treturn cache[key + \" \"] = value;\n\t\t\t}\n\t\t\treturn cache;\n\t\t}\n\n\t\t/**\n   * Mark a function for special use by Sizzle\n   * @param {Function} fn The function to mark\n   */\n\t\tfunction markFunction(fn) {\n\t\t\tfn[expando] = true;\n\t\t\treturn fn;\n\t\t}\n\n\t\t/**\n   * Support testing using an element\n   * @param {Function} fn Passed the created element and returns a boolean result\n   */\n\t\tfunction assert(fn) {\n\t\t\tvar el = document.createElement(\"fieldset\");\n\n\t\t\ttry {\n\t\t\t\treturn !!fn(el);\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t} finally {\n\t\t\t\t// Remove from its parent by default\n\t\t\t\tif (el.parentNode) {\n\t\t\t\t\tel.parentNode.removeChild(el);\n\t\t\t\t}\n\t\t\t\t// release memory in IE\n\t\t\t\tel = null;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Adds the same handler for all of the specified attrs\n   * @param {String} attrs Pipe-separated list of attributes\n   * @param {Function} handler The method that will be applied\n   */\n\t\tfunction addHandle(attrs, handler) {\n\t\t\tvar arr = attrs.split(\"|\"),\n\t\t\t    i = arr.length;\n\n\t\t\twhile (i--) {\n\t\t\t\tExpr.attrHandle[arr[i]] = handler;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Checks document order of two siblings\n   * @param {Element} a\n   * @param {Element} b\n   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n   */\n\t\tfunction siblingCheck(a, b) {\n\t\t\tvar cur = b && a,\n\t\t\t    diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;\n\n\t\t\t// Use IE sourceIndex if available on both nodes\n\t\t\tif (diff) {\n\t\t\t\treturn diff;\n\t\t\t}\n\n\t\t\t// Check if b follows a\n\t\t\tif (cur) {\n\t\t\t\twhile (cur = cur.nextSibling) {\n\t\t\t\t\tif (cur === b) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn a ? 1 : -1;\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for input types\n   * @param {String} type\n   */\n\t\tfunction createInputPseudo(type) {\n\t\t\treturn function (elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === type;\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for buttons\n   * @param {String} type\n   */\n\t\tfunction createButtonPseudo(type) {\n\t\t\treturn function (elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for :enabled/:disabled\n   * @param {Boolean} disabled true for :disabled; false for :enabled\n   */\n\t\tfunction createDisabledPseudo(disabled) {\n\n\t\t\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\t\t\treturn function (elem) {\n\n\t\t\t\t// Only certain elements can match :enabled or :disabled\n\t\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\t\t\tif (\"form\" in elem) {\n\n\t\t\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t\t\t// * option elements in a disabled optgroup\n\t\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t\t\t// All such elements have a \"form\" property.\n\t\t\t\t\tif (elem.parentNode && elem.disabled === false) {\n\n\t\t\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\t\t\tif (\"label\" in elem) {\n\t\t\t\t\t\t\tif (\"label\" in elem.parentNode) {\n\t\t\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\t\telem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem.disabled === disabled;\n\n\t\t\t\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t\t\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t\t\t\t// even exist on them, let alone have a boolean value.\n\t\t\t\t} else if (\"label\" in elem) {\n\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t}\n\n\t\t\t\t// Remaining elements are neither :enabled nor :disabled\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for positionals\n   * @param {Function} fn\n   */\n\t\tfunction createPositionalPseudo(fn) {\n\t\t\treturn markFunction(function (argument) {\n\t\t\t\targument = +argument;\n\t\t\t\treturn markFunction(function (seed, matches) {\n\t\t\t\t\tvar j,\n\t\t\t\t\t    matchIndexes = fn([], seed.length, argument),\n\t\t\t\t\t    i = matchIndexes.length;\n\n\t\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (seed[j = matchIndexes[i]]) {\n\t\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Checks a node for validity as a Sizzle context\n   * @param {Element|Object=} context\n   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n   */\n\t\tfunction testContext(context) {\n\t\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t\t}\n\n\t\t// Expose support vars for convenience\n\t\tsupport = Sizzle.support = {};\n\n\t\t/**\n   * Detects XML nodes\n   * @param {Element|Object} elem An element or a document\n   * @returns {Boolean} True iff elem is a non-HTML XML node\n   */\n\t\tisXML = Sizzle.isXML = function (elem) {\n\t\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t\t// (such as loading iframes in IE - #4833)\n\t\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t\t};\n\n\t\t/**\n   * Sets document-related variables once based on the current document\n   * @param {Element|Object} [doc] An element or document object to use to set the document\n   * @returns {Object} Returns the current document\n   */\n\t\tsetDocument = Sizzle.setDocument = function (node) {\n\t\t\tvar hasCompare,\n\t\t\t    subWindow,\n\t\t\t    doc = node ? node.ownerDocument || node : preferredDoc;\n\n\t\t\t// Return early if doc is invalid or already selected\n\t\t\tif (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n\t\t\t\treturn document;\n\t\t\t}\n\n\t\t\t// Update global variables\n\t\t\tdocument = doc;\n\t\t\tdocElem = document.documentElement;\n\t\t\tdocumentIsHTML = !isXML(document);\n\n\t\t\t// Support: IE 9-11, Edge\n\t\t\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t\t\tif (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n\n\t\t\t\t// Support: IE 11, Edge\n\t\t\t\tif (subWindow.addEventListener) {\n\t\t\t\t\tsubWindow.addEventListener(\"unload\", unloadHandler, false);\n\n\t\t\t\t\t// Support: IE 9 - 10 only\n\t\t\t\t} else if (subWindow.attachEvent) {\n\t\t\t\t\tsubWindow.attachEvent(\"onunload\", unloadHandler);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Attributes\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Support: IE<8\n\t\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t\t// (excepting IE8 booleans)\n\t\t\tsupport.attributes = assert(function (el) {\n\t\t\t\tel.className = \"i\";\n\t\t\t\treturn !el.getAttribute(\"className\");\n\t\t\t});\n\n\t\t\t/* getElement(s)By*\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\t\tsupport.getElementsByTagName = assert(function (el) {\n\t\t\t\tel.appendChild(document.createComment(\"\"));\n\t\t\t\treturn !el.getElementsByTagName(\"*\").length;\n\t\t\t});\n\n\t\t\t// Support: IE<9\n\t\t\tsupport.getElementsByClassName = rnative.test(document.getElementsByClassName);\n\n\t\t\t// Support: IE<10\n\t\t\t// Check if getElementById returns elements by name\n\t\t\t// The broken getElementById methods don't pick up programmatically-set names,\n\t\t\t// so use a roundabout getElementsByName test\n\t\t\tsupport.getById = assert(function (el) {\n\t\t\t\tdocElem.appendChild(el).id = expando;\n\t\t\t\treturn !document.getElementsByName || !document.getElementsByName(expando).length;\n\t\t\t});\n\n\t\t\t// ID filter and find\n\t\t\tif (support.getById) {\n\t\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tExpr.find[\"ID\"] = function (id, context) {\n\t\t\t\t\tif (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n\t\t\t\t\t\tvar elem = context.getElementById(id);\n\t\t\t\t\t\treturn elem ? [elem] : [];\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Support: IE 6 - 7 only\n\t\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\t\tExpr.find[\"ID\"] = function (id, context) {\n\t\t\t\t\tif (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n\t\t\t\t\t\tvar node,\n\t\t\t\t\t\t    i,\n\t\t\t\t\t\t    elems,\n\t\t\t\t\t\t    elem = context.getElementById(id);\n\n\t\t\t\t\t\tif (elem) {\n\n\t\t\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\t\tif (node && node.value === id) {\n\t\t\t\t\t\t\t\treturn [elem];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\t\t\telems = context.getElementsByName(id);\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t\twhile (elem = elems[i++]) {\n\t\t\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\t\t\tif (node && node.value === id) {\n\t\t\t\t\t\t\t\t\treturn [elem];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Tag\n\t\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n\t\t\t\tif (typeof context.getElementsByTagName !== \"undefined\") {\n\t\t\t\t\treturn context.getElementsByTagName(tag);\n\n\t\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t\t} else if (support.qsa) {\n\t\t\t\t\treturn context.querySelectorAll(tag);\n\t\t\t\t}\n\t\t\t} : function (tag, context) {\n\t\t\t\tvar elem,\n\t\t\t\t    tmp = [],\n\t\t\t\t    i = 0,\n\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName(tag);\n\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif (tag === \"*\") {\n\t\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\t\ttmp.push(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\n\t\t\t// Class\n\t\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n\t\t\t\tif (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n\t\t\t\t\treturn context.getElementsByClassName(className);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/* QSA/matchesSelector\n   ---------------------------------------------------------------------- */\n\n\t\t\t// QSA and matchesSelector support\n\n\t\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\t\trbuggyMatches = [];\n\n\t\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t\t// See https://bugs.jquery.com/ticket/13378\n\t\t\trbuggyQSA = [];\n\n\t\t\tif (support.qsa = rnative.test(document.querySelectorAll)) {\n\t\t\t\t// Build QSA regex\n\t\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\t\tassert(function (el) {\n\t\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t\t// since its presence should be enough\n\t\t\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\t\t\tdocElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\";\n\n\t\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\t\tif (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: IE8\n\t\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\t\tif (!el.querySelectorAll(\"[selected]\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\t\t\tif (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\t\tif (!el.querySelectorAll(\":checked\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\t\t\tif (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tassert(function (el) {\n\t\t\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\";\n\n\t\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\t\tvar input = document.createElement(\"input\");\n\t\t\t\t\tinput.setAttribute(\"type\", \"hidden\");\n\t\t\t\t\tel.appendChild(input).setAttribute(\"name\", \"D\");\n\n\t\t\t\t\t// Support: IE8\n\t\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\t\tif (el.querySelectorAll(\"[name=d]\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\t\tif (el.querySelectorAll(\":enabled\").length !== 2) {\n\t\t\t\t\t\trbuggyQSA.push(\":enabled\", \":disabled\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: IE9-11+\n\t\t\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\t\t\tdocElem.appendChild(el).disabled = true;\n\t\t\t\t\tif (el.querySelectorAll(\":disabled\").length !== 2) {\n\t\t\t\t\t\trbuggyQSA.push(\":enabled\", \":disabled\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n\n\t\t\t\tassert(function (el) {\n\t\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\t\tsupport.disconnectedMatch = matches.call(el, \"*\");\n\n\t\t\t\t\t// This should fail with an exception\n\t\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\t\tmatches.call(el, \"[s!='']:x\");\n\t\t\t\t\trbuggyMatches.push(\"!=\", pseudos);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\trbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n\t\t\trbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n\n\t\t\t/* Contains\n   ---------------------------------------------------------------------- */\n\t\t\thasCompare = rnative.test(docElem.compareDocumentPosition);\n\n\t\t\t// Element contains another\n\t\t\t// Purposefully self-exclusive\n\t\t\t// As in, an element does not contain itself\n\t\t\tcontains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t    bup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n\t\t\t} : function (a, b) {\n\t\t\t\tif (b) {\n\t\t\t\t\twhile (b = b.parentNode) {\n\t\t\t\t\t\tif (b === a) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t\t/* Sorting\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Document order sorting\n\t\t\tsortOrder = hasCompare ? function (a, b) {\n\n\t\t\t\t// Flag for duplicate removal\n\t\t\t\tif (a === b) {\n\t\t\t\t\thasDuplicate = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\t\tif (compare) {\n\t\t\t\t\treturn compare;\n\t\t\t\t}\n\n\t\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\t\tcompare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :\n\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\n\t\t\t\t// Disconnected nodes\n\t\t\t\tif (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n\n\t\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\t\tif (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Maintain original order\n\t\t\t\t\treturn sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\t\t\t\t}\n\n\t\t\t\treturn compare & 4 ? -1 : 1;\n\t\t\t} : function (a, b) {\n\t\t\t\t// Exit early if the nodes are identical\n\t\t\t\tif (a === b) {\n\t\t\t\t\thasDuplicate = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tvar cur,\n\t\t\t\t    i = 0,\n\t\t\t\t    aup = a.parentNode,\n\t\t\t\t    bup = b.parentNode,\n\t\t\t\t    ap = [a],\n\t\t\t\t    bp = [b];\n\n\t\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\t\tif (!aup || !bup) {\n\t\t\t\t\treturn a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\n\t\t\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t\t} else if (aup === bup) {\n\t\t\t\t\treturn siblingCheck(a, b);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\t\tcur = a;\n\t\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\t\tap.unshift(cur);\n\t\t\t\t}\n\t\t\t\tcur = b;\n\t\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\t\tbp.unshift(cur);\n\t\t\t\t}\n\n\t\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\t\twhile (ap[i] === bp[i]) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck(ap[i], bp[i]) :\n\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n\t\t\t};\n\n\t\t\treturn document;\n\t\t};\n\n\t\tSizzle.matches = function (expr, elements) {\n\t\t\treturn Sizzle(expr, null, null, elements);\n\t\t};\n\n\t\tSizzle.matchesSelector = function (elem, expr) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((elem.ownerDocument || elem) !== document) {\n\t\t\t\tsetDocument(elem);\n\t\t\t}\n\n\t\t\t// Make sure that attribute selectors are quoted\n\t\t\texpr = expr.replace(rattributeQuotes, \"='$1']\");\n\n\t\t\tif (support.matchesSelector && documentIsHTML && !compilerCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n\n\t\t\t\ttry {\n\t\t\t\t\tvar ret = matches.call(elem, expr);\n\n\t\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\t\tif (ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn Sizzle(expr, document, null, [elem]).length > 0;\n\t\t};\n\n\t\tSizzle.contains = function (context, elem) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((context.ownerDocument || context) !== document) {\n\t\t\t\tsetDocument(context);\n\t\t\t}\n\t\t\treturn contains(context, elem);\n\t\t};\n\n\t\tSizzle.attr = function (elem, name) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((elem.ownerDocument || elem) !== document) {\n\t\t\t\tsetDocument(elem);\n\t\t\t}\n\n\t\t\tvar fn = Expr.attrHandle[name.toLowerCase()],\n\n\t\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n\n\t\t\treturn val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t};\n\n\t\tSizzle.escape = function (sel) {\n\t\t\treturn (sel + \"\").replace(rcssescape, fcssescape);\n\t\t};\n\n\t\tSizzle.error = function (msg) {\n\t\t\tthrow new Error(\"Syntax error, unrecognized expression: \" + msg);\n\t\t};\n\n\t\t/**\n   * Document sorting and removing duplicates\n   * @param {ArrayLike} results\n   */\n\t\tSizzle.uniqueSort = function (results) {\n\t\t\tvar elem,\n\t\t\t    duplicates = [],\n\t\t\t    j = 0,\n\t\t\t    i = 0;\n\n\t\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\t\thasDuplicate = !support.detectDuplicates;\n\t\t\tsortInput = !support.sortStable && results.slice(0);\n\t\t\tresults.sort(sortOrder);\n\n\t\t\tif (hasDuplicate) {\n\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\tif (elem === results[i]) {\n\t\t\t\t\t\tj = duplicates.push(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (j--) {\n\t\t\t\t\tresults.splice(duplicates[j], 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear input after sorting to release objects\n\t\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\t\tsortInput = null;\n\n\t\t\treturn results;\n\t\t};\n\n\t\t/**\n   * Utility function for retrieving the text value of an array of DOM nodes\n   * @param {Array|Element} elem\n   */\n\t\tgetText = Sizzle.getText = function (elem) {\n\t\t\tvar node,\n\t\t\t    ret = \"\",\n\t\t\t    i = 0,\n\t\t\t    nodeType = elem.nodeType;\n\n\t\t\tif (!nodeType) {\n\t\t\t\t// If no nodeType, this is expected to be an array\n\t\t\t\twhile (node = elem[i++]) {\n\t\t\t\t\t// Do not traverse comment nodes\n\t\t\t\t\tret += getText(node);\n\t\t\t\t}\n\t\t\t} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n\t\t\t\t// Use textContent for elements\n\t\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\t\tif (typeof elem.textContent === \"string\") {\n\t\t\t\t\treturn elem.textContent;\n\t\t\t\t} else {\n\t\t\t\t\t// Traverse its children\n\t\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\t\tret += getText(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (nodeType === 3 || nodeType === 4) {\n\t\t\t\treturn elem.nodeValue;\n\t\t\t}\n\t\t\t// Do not include comment or processing instruction nodes\n\n\t\t\treturn ret;\n\t\t};\n\n\t\tExpr = Sizzle.selectors = {\n\n\t\t\t// Can be adjusted by the user\n\t\t\tcacheLength: 50,\n\n\t\t\tcreatePseudo: markFunction,\n\n\t\t\tmatch: matchExpr,\n\n\t\t\tattrHandle: {},\n\n\t\t\tfind: {},\n\n\t\t\trelative: {\n\t\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t\t},\n\n\t\t\tpreFilter: {\n\t\t\t\t\"ATTR\": function ATTR(match) {\n\t\t\t\t\tmatch[1] = match[1].replace(runescape, funescape);\n\n\t\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\t\tmatch[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n\t\t\t\t\tif (match[2] === \"~=\") {\n\t\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn match.slice(0, 4);\n\t\t\t\t},\n\n\t\t\t\t\"CHILD\": function CHILD(match) {\n\t\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n     \t1 type (only|nth|...)\n     \t2 what (child|of-type)\n     \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n     \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n     \t5 sign of xn-component\n     \t6 x of xn-component\n     \t7 sign of y-component\n     \t8 y of y-component\n     */\n\t\t\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\t\t\tif (match[1].slice(0, 3) === \"nth\") {\n\t\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\t\tif (!match[3]) {\n\t\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\t\tmatch[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n\t\t\t\t\t\tmatch[5] = +(match[7] + match[8] || match[3] === \"odd\");\n\n\t\t\t\t\t\t// other types prohibit arguments\n\t\t\t\t\t} else if (match[3]) {\n\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn match;\n\t\t\t\t},\n\n\t\t\t\t\"PSEUDO\": function PSEUDO(match) {\n\t\t\t\t\tvar excess,\n\t\t\t\t\t    unquoted = !match[6] && match[2];\n\n\t\t\t\t\tif (matchExpr[\"CHILD\"].test(match[0])) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\t\tif (match[3]) {\n\t\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t\t} else if (unquoted && rpseudo.test(unquoted) && (\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\texcess = tokenize(unquoted, true)) && (\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\texcess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n\n\t\t\t\t\t\t// excess is a negative index\n\t\t\t\t\t\tmatch[0] = match[0].slice(0, excess);\n\t\t\t\t\t\tmatch[2] = unquoted.slice(0, excess);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\t\treturn match.slice(0, 3);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tfilter: {\n\n\t\t\t\t\"TAG\": function TAG(nodeNameSelector) {\n\t\t\t\t\tvar nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n\t\t\t\t\treturn nodeNameSelector === \"*\" ? function () {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} : function (elem) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t\"CLASS\": function CLASS(className) {\n\t\t\t\t\tvar pattern = classCache[className + \" \"];\n\n\t\t\t\t\treturn pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n\t\t\t\t\t\treturn pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\t\"ATTR\": function ATTR(name, operator, check) {\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar result = Sizzle.attr(elem, name);\n\n\t\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!operator) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult += \"\";\n\n\t\t\t\t\t\treturn operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t\"CHILD\": function CHILD(type, what, argument, first, last) {\n\t\t\t\t\tvar simple = type.slice(0, 3) !== \"nth\",\n\t\t\t\t\t    forward = type.slice(-4) !== \"last\",\n\t\t\t\t\t    ofType = what === \"of-type\";\n\n\t\t\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction (elem) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} : function (elem, context, xml) {\n\t\t\t\t\t\tvar cache,\n\t\t\t\t\t\t    uniqueCache,\n\t\t\t\t\t\t    outerCache,\n\t\t\t\t\t\t    node,\n\t\t\t\t\t\t    nodeIndex,\n\t\t\t\t\t\t    start,\n\t\t\t\t\t\t    dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t    parent = elem.parentNode,\n\t\t\t\t\t\t    name = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t    useCache = !xml && !ofType,\n\t\t\t\t\t\t    diff = false;\n\n\t\t\t\t\t\tif (parent) {\n\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif (simple) {\n\t\t\t\t\t\t\t\twhile (dir) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile (node = node[dir]) {\n\t\t\t\t\t\t\t\t\t\tif (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstart = [forward ? parent.firstChild : parent.lastChild];\n\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif (forward && useCache) {\n\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[type] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\tdiff = nodeIndex && cache[2];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[nodeIndex];\n\n\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\tdiff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif (node.nodeType === 1 && ++diff && node === elem) {\n\t\t\t\t\t\t\t\t\t\tuniqueCache[type] = [dirruns, nodeIndex, diff];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t\tif (useCache) {\n\t\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\t\t\tcache = uniqueCache[type] || [];\n\t\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t\tif (diff === false) {\n\t\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t\t\tif ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n\n\t\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\t\tif (useCache) {\n\t\t\t\t\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache[type] = [dirruns, diff];\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (node === elem) {\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || diff % first === 0 && diff / first >= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t\"PSEUDO\": function PSEUDO(pseudo, argument) {\n\t\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\t\tvar args,\n\t\t\t\t\t    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo);\n\n\t\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t\t// just as Sizzle does\n\t\t\t\t\tif (fn[expando]) {\n\t\t\t\t\t\treturn fn(argument);\n\t\t\t\t\t}\n\n\t\t\t\t\t// But maintain support for old signatures\n\t\t\t\t\tif (fn.length > 1) {\n\t\t\t\t\t\targs = [pseudo, pseudo, \"\", argument];\n\t\t\t\t\t\treturn Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t    matched = fn(seed, argument),\n\t\t\t\t\t\t\t    i = matched.length;\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tidx = indexOf(seed, matched[i]);\n\t\t\t\t\t\t\t\tseed[idx] = !(matches[idx] = matched[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) : function (elem) {\n\t\t\t\t\t\t\treturn fn(elem, 0, args);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tpseudos: {\n\t\t\t\t// Potentially complex pseudos\n\t\t\t\t\"not\": markFunction(function (selector) {\n\t\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t\t// spaces as combinators\n\t\t\t\t\tvar input = [],\n\t\t\t\t\t    results = [],\n\t\t\t\t\t    matcher = compile(selector.replace(rtrim, \"$1\"));\n\n\t\t\t\t\treturn matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t    unmatched = matcher(seed, null, xml, []),\n\t\t\t\t\t\t    i = seed.length;\n\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) : function (elem, context, xml) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher(input, null, xml, results);\n\t\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\t\tinput[0] = null;\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t\"has\": markFunction(function (selector) {\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn Sizzle(selector, elem).length > 0;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t\"contains\": markFunction(function (text) {\n\t\t\t\t\ttext = text.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t\t// is based solely on the element's language value\n\t\t\t\t// being equal to the identifier C,\n\t\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\t\"lang\": markFunction(function (lang) {\n\t\t\t\t\t// lang value must be a valid identifier\n\t\t\t\t\tif (!ridentifier.test(lang || \"\")) {\n\t\t\t\t\t\tSizzle.error(\"unsupported lang: \" + lang);\n\t\t\t\t\t}\n\t\t\t\t\tlang = lang.replace(runescape, funescape).toLowerCase();\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar elemLang;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n\n\t\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while ((elem = elem.parentNode) && elem.nodeType === 1);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t// Miscellaneous\n\t\t\t\t\"target\": function target(elem) {\n\t\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\t\treturn hash && hash.slice(1) === elem.id;\n\t\t\t\t},\n\n\t\t\t\t\"root\": function root(elem) {\n\t\t\t\t\treturn elem === docElem;\n\t\t\t\t},\n\n\t\t\t\t\"focus\": function focus(elem) {\n\t\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t\t},\n\n\t\t\t\t// Boolean properties\n\t\t\t\t\"enabled\": createDisabledPseudo(false),\n\t\t\t\t\"disabled\": createDisabledPseudo(true),\n\n\t\t\t\t\"checked\": function checked(elem) {\n\t\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\t\treturn nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n\t\t\t\t},\n\n\t\t\t\t\"selected\": function selected(elem) {\n\t\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t\t// options in Safari work properly\n\t\t\t\t\tif (elem.parentNode) {\n\t\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem.selected === true;\n\t\t\t\t},\n\n\t\t\t\t// Contents\n\t\t\t\t\"empty\": function empty(elem) {\n\t\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\t\tif (elem.nodeType < 6) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t\"parent\": function parent(elem) {\n\t\t\t\t\treturn !Expr.pseudos[\"empty\"](elem);\n\t\t\t\t},\n\n\t\t\t\t// Element/input types\n\t\t\t\t\"header\": function header(elem) {\n\t\t\t\t\treturn rheader.test(elem.nodeName);\n\t\t\t\t},\n\n\t\t\t\t\"input\": function input(elem) {\n\t\t\t\t\treturn rinputs.test(elem.nodeName);\n\t\t\t\t},\n\n\t\t\t\t\"button\": function button(elem) {\n\t\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t\t},\n\n\t\t\t\t\"text\": function text(elem) {\n\t\t\t\t\tvar attr;\n\t\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && (\n\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t\t(attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n\t\t\t\t},\n\n\t\t\t\t// Position-in-collection\n\t\t\t\t\"first\": createPositionalPseudo(function () {\n\t\t\t\t\treturn [0];\n\t\t\t\t}),\n\n\t\t\t\t\"last\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\treturn [length - 1];\n\t\t\t\t}),\n\n\t\t\t\t\"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\treturn [argument < 0 ? argument + length : argument];\n\t\t\t\t}),\n\n\t\t\t\t\"even\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\tvar i = 0;\n\t\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t\"odd\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\tvar i = 1;\n\t\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t\"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\t\tfor (; --i >= 0;) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t\"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\t\tfor (; ++i < length;) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n\t\t// Add button/input type pseudos\n\t\tfor (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\n\t\t\tExpr.pseudos[i] = createInputPseudo(i);\n\t\t}\n\t\tfor (i in { submit: true, reset: true }) {\n\t\t\tExpr.pseudos[i] = createButtonPseudo(i);\n\t\t}\n\n\t\t// Easy API for creating new setFilters\n\t\tfunction setFilters() {}\n\t\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\t\tExpr.setFilters = new setFilters();\n\n\t\ttokenize = Sizzle.tokenize = function (selector, parseOnly) {\n\t\t\tvar matched,\n\t\t\t    match,\n\t\t\t    tokens,\n\t\t\t    type,\n\t\t\t    soFar,\n\t\t\t    groups,\n\t\t\t    preFilters,\n\t\t\t    cached = tokenCache[selector + \" \"];\n\n\t\t\tif (cached) {\n\t\t\t\treturn parseOnly ? 0 : cached.slice(0);\n\t\t\t}\n\n\t\t\tsoFar = selector;\n\t\t\tgroups = [];\n\t\t\tpreFilters = Expr.preFilter;\n\n\t\t\twhile (soFar) {\n\n\t\t\t\t// Comma and first run\n\t\t\t\tif (!matched || (match = rcomma.exec(soFar))) {\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\t\tsoFar = soFar.slice(match[0].length) || soFar;\n\t\t\t\t\t}\n\t\t\t\t\tgroups.push(tokens = []);\n\t\t\t\t}\n\n\t\t\t\tmatched = false;\n\n\t\t\t\t// Combinators\n\t\t\t\tif (match = rcombinators.exec(soFar)) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\t\ttype: match[0].replace(rtrim, \" \")\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t}\n\n\t\t\t\t// Filters\n\t\t\t\tfor (type in Expr.filter) {\n\t\t\t\t\tif ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n\t\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\t\ttokens.push({\n\t\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\t\tmatches: match\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!matched) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the length of the invalid excess\n\t\t\t// if we're just parsing\n\t\t\t// Otherwise, throw an error or return tokens\n\t\t\treturn parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache(selector, groups).slice(0);\n\t\t};\n\n\t\tfunction toSelector(tokens) {\n\t\t\tvar i = 0,\n\t\t\t    len = tokens.length,\n\t\t\t    selector = \"\";\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tselector += tokens[i].value;\n\t\t\t}\n\t\t\treturn selector;\n\t\t}\n\n\t\tfunction addCombinator(matcher, combinator, base) {\n\t\t\tvar dir = combinator.dir,\n\t\t\t    skip = combinator.next,\n\t\t\t    key = skip || dir,\n\t\t\t    checkNonElements = base && key === \"parentNode\",\n\t\t\t    doneName = done++;\n\n\t\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction (elem, context, xml) {\n\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\treturn matcher(elem, context, xml);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} :\n\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction (elem, context, xml) {\n\t\t\t\tvar oldCache,\n\t\t\t\t    uniqueCache,\n\t\t\t\t    outerCache,\n\t\t\t\t    newCache = [dirruns, doneName];\n\n\t\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\t\tif (xml) {\n\t\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\t\tif (matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\t\touterCache = elem[expando] || (elem[expando] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n\t\t\t\t\t\t\tif (skip && skip === elem.nodeName.toLowerCase()) {\n\t\t\t\t\t\t\t\telem = elem[dir] || elem;\n\t\t\t\t\t\t\t} else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn newCache[2] = oldCache[2];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\tuniqueCache[key] = newCache;\n\n\t\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif (newCache[2] = matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}\n\n\t\tfunction elementMatcher(matchers) {\n\t\t\treturn matchers.length > 1 ? function (elem, context, xml) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (!matchers[i](elem, context, xml)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} : matchers[0];\n\t\t}\n\n\t\tfunction multipleContexts(selector, contexts, results) {\n\t\t\tvar i = 0,\n\t\t\t    len = contexts.length;\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tSizzle(selector, contexts[i], results);\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\tfunction condense(unmatched, map, filter, context, xml) {\n\t\t\tvar elem,\n\t\t\t    newUnmatched = [],\n\t\t\t    i = 0,\n\t\t\t    len = unmatched.length,\n\t\t\t    mapped = map != null;\n\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\tif (!filter || filter(elem, context, xml)) {\n\t\t\t\t\t\tnewUnmatched.push(elem);\n\t\t\t\t\t\tif (mapped) {\n\t\t\t\t\t\t\tmap.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newUnmatched;\n\t\t}\n\n\t\tfunction setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n\t\t\tif (postFilter && !postFilter[expando]) {\n\t\t\t\tpostFilter = setMatcher(postFilter);\n\t\t\t}\n\t\t\tif (postFinder && !postFinder[expando]) {\n\t\t\t\tpostFinder = setMatcher(postFinder, postSelector);\n\t\t\t}\n\t\t\treturn markFunction(function (seed, results, context, xml) {\n\t\t\t\tvar temp,\n\t\t\t\t    i,\n\t\t\t\t    elem,\n\t\t\t\t    preMap = [],\n\t\t\t\t    postMap = [],\n\t\t\t\t    preexisting = results.length,\n\n\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n\n\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n\t\t\t\t    matcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || (seed ? preFilter : preexisting || postFilter) ?\n\n\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t[] :\n\n\t\t\t\t// ...otherwise use results directly\n\t\t\t\tresults : matcherIn;\n\n\t\t\t\t// Find primary matches\n\t\t\t\tif (matcher) {\n\t\t\t\t\tmatcher(matcherIn, matcherOut, context, xml);\n\t\t\t\t}\n\n\t\t\t\t// Apply postFilter\n\t\t\t\tif (postFilter) {\n\t\t\t\t\ttemp = condense(matcherOut, postMap);\n\t\t\t\t\tpostFilter(temp, [], context, xml);\n\n\t\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\t\ti = temp.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (elem = temp[i]) {\n\t\t\t\t\t\t\tmatcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (seed) {\n\t\t\t\t\tif (postFinder || preFilter) {\n\t\t\t\t\t\tif (postFinder) {\n\t\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tif (elem = matcherOut[i]) {\n\t\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\t\ttemp.push(matcherIn[i] = elem);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpostFinder(null, matcherOut = [], temp, xml);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n\n\t\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t\t} else {\n\t\t\t\t\tmatcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\t\t\t\t\tif (postFinder) {\n\t\t\t\t\t\tpostFinder(null, results, matcherOut, xml);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpush.apply(results, matcherOut);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction matcherFromTokens(tokens) {\n\t\t\tvar checkContext,\n\t\t\t    matcher,\n\t\t\t    j,\n\t\t\t    len = tokens.length,\n\t\t\t    leadingRelative = Expr.relative[tokens[0].type],\n\t\t\t    implicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t\t    i = leadingRelative ? 1 : 0,\n\n\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator(function (elem) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true),\n\t\t\t    matchAnyContext = addCombinator(function (elem) {\n\t\t\t\treturn indexOf(checkContext, elem) > -1;\n\t\t\t}, implicitRelative, true),\n\t\t\t    matchers = [function (elem, context, xml) {\n\t\t\t\tvar ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n\t\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\t\tcheckContext = null;\n\t\t\t\treturn ret;\n\t\t\t}];\n\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (matcher = Expr.relative[tokens[i].type]) {\n\t\t\t\t\tmatchers = [addCombinator(elementMatcher(matchers), matcher)];\n\t\t\t\t} else {\n\t\t\t\t\tmatcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n\n\t\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\t\tif (matcher[expando]) {\n\t\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\t\tj = ++i;\n\t\t\t\t\t\tfor (; j < len; j++) {\n\t\t\t\t\t\t\tif (Expr.relative[tokens[j].type]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === \" \" ? \"*\" : \"\" })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n\t\t\t\t\t}\n\t\t\t\t\tmatchers.push(matcher);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn elementMatcher(matchers);\n\t\t}\n\n\t\tfunction matcherFromGroupMatchers(elementMatchers, setMatchers) {\n\t\t\tvar bySet = setMatchers.length > 0,\n\t\t\t    byElement = elementMatchers.length > 0,\n\t\t\t    superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n\t\t\t\tvar elem,\n\t\t\t\t    j,\n\t\t\t\t    matcher,\n\t\t\t\t    matchedCount = 0,\n\t\t\t\t    i = \"0\",\n\t\t\t\t    unmatched = seed && [],\n\t\t\t\t    setMatched = [],\n\t\t\t\t    contextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n\t\t\t\t    len = elems.length;\n\n\t\t\t\tif (outermost) {\n\t\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t\t}\n\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\t\tfor (; i !== len && (elem = elems[i]) != null; i++) {\n\t\t\t\t\tif (byElement && elem) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tif (!context && elem.ownerDocument !== document) {\n\t\t\t\t\t\t\tsetDocument(elem);\n\t\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (matcher = elementMatchers[j++]) {\n\t\t\t\t\t\t\tif (matcher(elem, context || document, xml)) {\n\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outermost) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif (bySet) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif (elem = !matcher && elem) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif (seed) {\n\t\t\t\t\t\t\tunmatched.push(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t\t// makes the latter nonnegative.\n\t\t\t\tmatchedCount += i;\n\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t\t// no element matchers and no seed.\n\t\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t\t// numerically zero.\n\t\t\t\tif (bySet && i !== matchedCount) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile (matcher = setMatchers[j++]) {\n\t\t\t\t\t\tmatcher(unmatched, setMatched, context, xml);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (seed) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif (matchedCount > 0) {\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tif (!(unmatched[i] || setMatched[i])) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call(results);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense(setMatched);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply(results, setMatched);\n\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n\n\t\t\t\t\t\tSizzle.uniqueSort(results);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif (outermost) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\n\t\t\t\treturn unmatched;\n\t\t\t};\n\n\t\t\treturn bySet ? markFunction(superMatcher) : superMatcher;\n\t\t}\n\n\t\tcompile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\n\t\t\tvar i,\n\t\t\t    setMatchers = [],\n\t\t\t    elementMatchers = [],\n\t\t\t    cached = compilerCache[selector + \" \"];\n\n\t\t\tif (!cached) {\n\t\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = tokenize(selector);\n\t\t\t\t}\n\t\t\t\ti = match.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tcached = matcherFromTokens(match[i]);\n\t\t\t\t\tif (cached[expando]) {\n\t\t\t\t\t\tsetMatchers.push(cached);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telementMatchers.push(cached);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Cache the compiled function\n\t\t\t\tcached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n\n\t\t\t\t// Save selector and tokenization\n\t\t\t\tcached.selector = selector;\n\t\t\t}\n\t\t\treturn cached;\n\t\t};\n\n\t\t/**\n   * A low-level selection function that works with Sizzle's compiled\n   *  selector functions\n   * @param {String|Function} selector A selector or a pre-compiled\n   *  selector function built with Sizzle.compile\n   * @param {Element} context\n   * @param {Array} [results]\n   * @param {Array} [seed] A set of elements to match against\n   */\n\t\tselect = Sizzle.select = function (selector, context, results, seed) {\n\t\t\tvar i,\n\t\t\t    tokens,\n\t\t\t    token,\n\t\t\t    type,\n\t\t\t    find,\n\t\t\t    compiled = typeof selector === \"function\" && selector,\n\t\t\t    match = !seed && tokenize(selector = compiled.selector || selector);\n\n\t\t\tresults = results || [];\n\n\t\t\t// Try to minimize operations if there is only one selector in the list and no seed\n\t\t\t// (the latter of which guarantees us context)\n\t\t\tif (match.length === 1) {\n\n\t\t\t\t// Reduce context if the leading compound selector is an ID\n\t\t\t\ttokens = match[0] = match[0].slice(0);\n\t\t\t\tif (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n\n\t\t\t\t\tcontext = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\t\t\t\t\tif (!context) {\n\t\t\t\t\t\treturn results;\n\n\t\t\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t\t} else if (compiled) {\n\t\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t\t}\n\n\t\t\t\t\tselector = selector.slice(tokens.shift().value.length);\n\t\t\t\t}\n\n\t\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\t\ti = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t\t// Abort if we hit a combinator\n\t\t\t\t\tif (Expr.relative[type = token.type]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (find = Expr.find[type]) {\n\t\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\t\tif (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n\n\t\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\t\ttokens.splice(i, 1);\n\t\t\t\t\t\t\tselector = seed.length && toSelector(tokens);\n\t\t\t\t\t\t\tif (!selector) {\n\t\t\t\t\t\t\t\tpush.apply(results, seed);\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Compile and execute a filtering function if one is not provided\n\t\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t\t(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n\t\t\treturn results;\n\t\t};\n\n\t\t// One-time assignments\n\n\t\t// Sort stability\n\t\tsupport.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\n\n\t\t// Support: Chrome 14-35+\n\t\t// Always assume duplicates if they aren't passed to the comparison function\n\t\tsupport.detectDuplicates = !!hasDuplicate;\n\n\t\t// Initialize against the default document\n\t\tsetDocument();\n\n\t\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t\t// Detached nodes confoundingly follow *each other*\n\t\tsupport.sortDetached = assert(function (el) {\n\t\t\t// Should return 1, but returns 4 (following)\n\t\t\treturn el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n\t\t});\n\n\t\t// Support: IE<8\n\t\t// Prevent attribute/property \"interpolation\"\n\t\t// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\t\tif (!assert(function (el) {\n\t\t\tel.innerHTML = \"<a href='#'></a>\";\n\t\t\treturn el.firstChild.getAttribute(\"href\") === \"#\";\n\t\t})) {\n\t\t\taddHandle(\"type|href|height|width\", function (elem, name, isXML) {\n\t\t\t\tif (!isXML) {\n\t\t\t\t\treturn elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Use defaultValue in place of getAttribute(\"value\")\n\t\tif (!support.attributes || !assert(function (el) {\n\t\t\tel.innerHTML = \"<input/>\";\n\t\t\tel.firstChild.setAttribute(\"value\", \"\");\n\t\t\treturn el.firstChild.getAttribute(\"value\") === \"\";\n\t\t})) {\n\t\t\taddHandle(\"value\", function (elem, name, isXML) {\n\t\t\t\tif (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n\t\t\t\t\treturn elem.defaultValue;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\t\tif (!assert(function (el) {\n\t\t\treturn el.getAttribute(\"disabled\") == null;\n\t\t})) {\n\t\t\taddHandle(booleans, function (elem, name, isXML) {\n\t\t\t\tvar val;\n\t\t\t\tif (!isXML) {\n\t\t\t\t\treturn elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn Sizzle;\n\t}(window);\n\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\n\t// Deprecated\n\tjQuery.expr[\":\"] = jQuery.expr.pseudos;\n\tjQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\tjQuery.escapeSelector = Sizzle.escape;\n\n\tvar dir = function dir(elem, _dir, until) {\n\t\tvar matched = [],\n\t\t    truncate = until !== undefined;\n\n\t\twhile ((elem = elem[_dir]) && elem.nodeType !== 9) {\n\t\t\tif (elem.nodeType === 1) {\n\t\t\t\tif (truncate && jQuery(elem).is(until)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push(elem);\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t};\n\n\tvar _siblings = function _siblings(n, elem) {\n\t\tvar matched = [];\n\n\t\tfor (; n; n = n.nextSibling) {\n\t\t\tif (n.nodeType === 1 && n !== elem) {\n\t\t\t\tmatched.push(n);\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t};\n\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\n\tfunction nodeName(elem, name) {\n\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t};\n\tvar rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;\n\n\t// Implement the identical functionality for filter and not\n\tfunction winnow(elements, qualifier, not) {\n\t\tif (isFunction(qualifier)) {\n\t\t\treturn jQuery.grep(elements, function (elem, i) {\n\t\t\t\treturn !!qualifier.call(elem, i, elem) !== not;\n\t\t\t});\n\t\t}\n\n\t\t// Single element\n\t\tif (qualifier.nodeType) {\n\t\t\treturn jQuery.grep(elements, function (elem) {\n\t\t\t\treturn elem === qualifier !== not;\n\t\t\t});\n\t\t}\n\n\t\t// Arraylike of elements (jQuery, arguments, Array)\n\t\tif (typeof qualifier !== \"string\") {\n\t\t\treturn jQuery.grep(elements, function (elem) {\n\t\t\t\treturn indexOf.call(qualifier, elem) > -1 !== not;\n\t\t\t});\n\t\t}\n\n\t\t// Filtered directly for both simple and complex selectors\n\t\treturn jQuery.filter(qualifier, elements, not);\n\t}\n\n\tjQuery.filter = function (expr, elems, not) {\n\t\tvar elem = elems[0];\n\n\t\tif (not) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\tif (elems.length === 1 && elem.nodeType === 1) {\n\t\t\treturn jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\n\t\t}\n\n\t\treturn jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n\t};\n\n\tjQuery.fn.extend({\n\t\tfind: function find(selector) {\n\t\t\tvar i,\n\t\t\t    ret,\n\t\t\t    len = this.length,\n\t\t\t    self = this;\n\n\t\t\tif (typeof selector !== \"string\") {\n\t\t\t\treturn this.pushStack(jQuery(selector).filter(function () {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (jQuery.contains(self[i], this)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tret = this.pushStack([]);\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tjQuery.find(selector, self[i], ret);\n\t\t\t}\n\n\t\t\treturn len > 1 ? jQuery.uniqueSort(ret) : ret;\n\t\t},\n\t\tfilter: function filter(selector) {\n\t\t\treturn this.pushStack(winnow(this, selector || [], false));\n\t\t},\n\t\tnot: function not(selector) {\n\t\t\treturn this.pushStack(winnow(this, selector || [], true));\n\t\t},\n\t\tis: function is(selector) {\n\t\t\treturn !!winnow(this,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n\t\t}\n\t});\n\n\t// Initialize a jQuery object\n\n\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\t    init = jQuery.fn.init = function (selector, context, root) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif (!selector) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif (typeof selector === \"string\") {\n\t\t\tif (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [null, selector, null];\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec(selector);\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif (match && (match[1] || !context)) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif (match[1]) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n\t\t\t\t\t\tfor (match in context) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif (isFunction(this[match])) {\n\t\t\t\t\t\t\t\tthis[match](context[match]);\n\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr(match, context[match]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById(match[2]);\n\n\t\t\t\t\tif (elem) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if (!context || context.jquery) {\n\t\t\t\treturn (context || root).find(selector);\n\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor(context).find(selector);\n\t\t\t}\n\n\t\t\t// HANDLE: $(DOMElement)\n\t\t} else if (selector.nodeType) {\n\t\t\tthis[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t} else if (isFunction(selector)) {\n\t\t\treturn root.ready !== undefined ? root.ready(selector) :\n\n\t\t\t// Execute immediately if ready is not present\n\t\t\tselector(jQuery);\n\t\t}\n\n\t\treturn jQuery.makeArray(selector, this);\n\t};\n\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\n\t// Initialize central reference\n\trootjQuery = jQuery(document);\n\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\n\tjQuery.fn.extend({\n\t\thas: function has(target) {\n\t\t\tvar targets = jQuery(target, this),\n\t\t\t    l = targets.length;\n\n\t\t\treturn this.filter(function () {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\tif (jQuery.contains(this, targets[i])) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tclosest: function closest(selectors, context) {\n\t\t\tvar cur,\n\t\t\t    i = 0,\n\t\t\t    l = this.length,\n\t\t\t    matched = [],\n\t\t\t    targets = typeof selectors !== \"string\" && jQuery(selectors);\n\n\t\t\t// Positional selectors never match, since there's no _selection_ context\n\t\t\tif (!rneedsContext.test(selectors)) {\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\tfor (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n\n\t\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\t\tif (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n\n\t\t\t\t\t\t\tmatched.push(cur);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n\t\t},\n\n\t\t// Determine the position of an element within the set\n\t\tindex: function index(elem) {\n\n\t\t\t// No argument, return index in parent\n\t\t\tif (!elem) {\n\t\t\t\treturn this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n\t\t\t}\n\n\t\t\t// Index in selector\n\t\t\tif (typeof elem === \"string\") {\n\t\t\t\treturn indexOf.call(jQuery(elem), this[0]);\n\t\t\t}\n\n\t\t\t// Locate the position of the desired element\n\t\t\treturn indexOf.call(this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem);\n\t\t},\n\n\t\tadd: function add(selector, context) {\n\t\t\treturn this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n\t\t},\n\n\t\taddBack: function addBack(selector) {\n\t\t\treturn this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n\t\t}\n\t});\n\n\tfunction sibling(cur, dir) {\n\t\twhile ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\t\treturn cur;\n\t}\n\n\tjQuery.each({\n\t\tparent: function parent(elem) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function parents(elem) {\n\t\t\treturn dir(elem, \"parentNode\");\n\t\t},\n\t\tparentsUntil: function parentsUntil(elem, i, until) {\n\t\t\treturn dir(elem, \"parentNode\", until);\n\t\t},\n\t\tnext: function next(elem) {\n\t\t\treturn sibling(elem, \"nextSibling\");\n\t\t},\n\t\tprev: function prev(elem) {\n\t\t\treturn sibling(elem, \"previousSibling\");\n\t\t},\n\t\tnextAll: function nextAll(elem) {\n\t\t\treturn dir(elem, \"nextSibling\");\n\t\t},\n\t\tprevAll: function prevAll(elem) {\n\t\t\treturn dir(elem, \"previousSibling\");\n\t\t},\n\t\tnextUntil: function nextUntil(elem, i, until) {\n\t\t\treturn dir(elem, \"nextSibling\", until);\n\t\t},\n\t\tprevUntil: function prevUntil(elem, i, until) {\n\t\t\treturn dir(elem, \"previousSibling\", until);\n\t\t},\n\t\tsiblings: function siblings(elem) {\n\t\t\treturn _siblings((elem.parentNode || {}).firstChild, elem);\n\t\t},\n\t\tchildren: function children(elem) {\n\t\t\treturn _siblings(elem.firstChild);\n\t\t},\n\t\tcontents: function contents(elem) {\n\t\t\tif (nodeName(elem, \"iframe\")) {\n\t\t\t\treturn elem.contentDocument;\n\t\t\t}\n\n\t\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t\t// Treat the template element as a regular one in browsers that\n\t\t\t// don't support it.\n\t\t\tif (nodeName(elem, \"template\")) {\n\t\t\t\telem = elem.content || elem;\n\t\t\t}\n\n\t\t\treturn jQuery.merge([], elem.childNodes);\n\t\t}\n\t}, function (name, fn) {\n\t\tjQuery.fn[name] = function (until, selector) {\n\t\t\tvar matched = jQuery.map(this, fn, until);\n\n\t\t\tif (name.slice(-5) !== \"Until\") {\n\t\t\t\tselector = until;\n\t\t\t}\n\n\t\t\tif (selector && typeof selector === \"string\") {\n\t\t\t\tmatched = jQuery.filter(selector, matched);\n\t\t\t}\n\n\t\t\tif (this.length > 1) {\n\n\t\t\t\t// Remove duplicates\n\t\t\t\tif (!guaranteedUnique[name]) {\n\t\t\t\t\tjQuery.uniqueSort(matched);\n\t\t\t\t}\n\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif (rparentsprev.test(name)) {\n\t\t\t\t\tmatched.reverse();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack(matched);\n\t\t};\n\t});\n\tvar rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n\t// Convert String-formatted options into Object-formatted ones\n\tfunction createOptions(options) {\n\t\tvar object = {};\n\t\tjQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n\t\t\tobject[flag] = true;\n\t\t});\n\t\treturn object;\n\t}\n\n\t/*\n  * Create a callback list using the following parameters:\n  *\n  *\toptions: an optional list of space-separated options that will change how\n  *\t\t\tthe callback list behaves or a more traditional option object\n  *\n  * By default a callback list will act like an event callback list and can be\n  * \"fired\" multiple times.\n  *\n  * Possible options:\n  *\n  *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n  *\n  *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n  *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n  *\t\t\t\t\tvalues (like a Deferred)\n  *\n  *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n  *\n  *\tstopOnFalse:\tinterrupt callings when a callback returns false\n  *\n  */\n\tjQuery.Callbacks = function (options) {\n\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n\t\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\n\t\t// Flag to know if list was already fired\n\t\t_fired,\n\n\n\t\t// Flag to prevent firing\n\t\t_locked,\n\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\n\t\t// Fire callbacks\n\t\tfire = function fire() {\n\n\t\t\t// Enforce single-firing\n\t\t\t_locked = _locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\t_fired = firing = true;\n\t\t\tfor (; queue.length; firingIndex = -1) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile (++firingIndex < list.length) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif (!options.memory) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif (_locked) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif (memory) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function add() {\n\t\t\t\tif (list) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif (memory && !firing) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push(memory);\n\t\t\t\t\t}\n\n\t\t\t\t\t(function add(args) {\n\t\t\t\t\t\tjQuery.each(args, function (_, arg) {\n\t\t\t\t\t\t\tif (isFunction(arg)) {\n\t\t\t\t\t\t\t\tif (!options.unique || !self.has(arg)) {\n\t\t\t\t\t\t\t\t\tlist.push(arg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (arg && arg.length && toType(arg) !== \"string\") {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd(arg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})(arguments);\n\n\t\t\t\t\tif (memory && !firing) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function remove() {\n\t\t\t\tjQuery.each(arguments, function (_, arg) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ((index = jQuery.inArray(arg, list, index)) > -1) {\n\t\t\t\t\t\tlist.splice(index, 1);\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif (index <= firingIndex) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function has(fn) {\n\t\t\t\treturn fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function empty() {\n\t\t\t\tif (list) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function disable() {\n\t\t\t\t_locked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function disabled() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function lock() {\n\t\t\t\t_locked = queue = [];\n\t\t\t\tif (!memory && !firing) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function locked() {\n\t\t\t\treturn !!_locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function fireWith(context, args) {\n\t\t\t\tif (!_locked) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [context, args.slice ? args.slice() : args];\n\t\t\t\t\tqueue.push(args);\n\t\t\t\t\tif (!firing) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function fire() {\n\t\t\t\tself.fireWith(this, arguments);\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function fired() {\n\t\t\t\treturn !!_fired;\n\t\t\t}\n\t\t};\n\n\t\treturn self;\n\t};\n\n\tfunction Identity(v) {\n\t\treturn v;\n\t}\n\tfunction Thrower(ex) {\n\t\tthrow ex;\n\t}\n\n\tfunction adoptValue(value, resolve, reject, noValue) {\n\t\tvar method;\n\n\t\ttry {\n\n\t\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\t\tif (value && isFunction(method = value.promise)) {\n\t\t\t\tmethod.call(value).done(resolve).fail(reject);\n\n\t\t\t\t// Other thenables\n\t\t\t} else if (value && isFunction(method = value.then)) {\n\t\t\t\tmethod.call(value, resolve, reject);\n\n\t\t\t\t// Other non-thenables\n\t\t\t} else {\n\n\t\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\t\tresolve.apply(undefined, [value].slice(noValue));\n\t\t\t}\n\n\t\t\t// For Promises/A+, convert exceptions into rejections\n\t\t\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t\t\t// Deferred#then to conditionally suppress rejection.\n\t\t} catch (value) {\n\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\treject.apply(undefined, [value]);\n\t\t}\n\t}\n\n\tjQuery.extend({\n\n\t\tDeferred: function Deferred(func) {\n\t\t\tvar tuples = [\n\n\t\t\t// action, add listener, callbacks,\n\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t[\"notify\", \"progress\", jQuery.Callbacks(\"memory\"), jQuery.Callbacks(\"memory\"), 2], [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 0, \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 1, \"rejected\"]],\n\t\t\t    _state = \"pending\",\n\t\t\t    _promise = {\n\t\t\t\tstate: function state() {\n\t\t\t\t\treturn _state;\n\t\t\t\t},\n\t\t\t\talways: function always() {\n\t\t\t\t\tdeferred.done(arguments).fail(arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function _catch(fn) {\n\t\t\t\t\treturn _promise.then(null, fn);\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function pipe() /* fnDone, fnFail, fnProgress */{\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred(function (newDefer) {\n\t\t\t\t\t\tjQuery.each(tuples, function (i, tuple) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[tuple[1]](function () {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply(this, arguments);\n\t\t\t\t\t\t\t\tif (returned && isFunction(returned.promise)) {\n\t\t\t\t\t\t\t\t\treturned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[tuple[0] + \"With\"](this, fn ? [returned] : arguments);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\tthen: function then(onFulfilled, onRejected, onProgress) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve(depth, deferred, handler, special) {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t    args = arguments,\n\t\t\t\t\t\t\t    mightThrow = function mightThrow() {\n\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\tif (depth < maxDepth) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturned = handler.apply(that, args);\n\n\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\tif (returned === deferred.promise()) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\"Thenable self-resolution\");\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\tthen = returned && (\n\n\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t(typeof returned === \"undefined\" ? \"undefined\" : _typeof(returned)) === \"object\" || typeof returned === \"function\") && returned.then;\n\n\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\tif (isFunction(then)) {\n\n\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\tif (special) {\n\t\t\t\t\t\t\t\t\t\tthen.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\tthen.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\tif (handler !== Identity) {\n\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\targs = [returned];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t(special || deferred.resolveWith)(that, args);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\n\n\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\tprocess = special ? mightThrow : function () {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t} catch (e) {\n\n\t\t\t\t\t\t\t\t\tif (jQuery.Deferred.exceptionHook) {\n\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook(e, process.stackTrace);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\tif (depth + 1 >= maxDepth) {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif (handler !== Thrower) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [e];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith(that, args);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif (depth) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif (jQuery.Deferred.getStackHook) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout(process);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred(function (newDefer) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function promise(obj) {\n\t\t\t\t\treturn obj != null ? jQuery.extend(obj, _promise) : _promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\t    deferred = {};\n\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\tvar list = tuple[2],\n\t\t\t\t    stateString = tuple[5];\n\n\t\t\t\t// promise.progress = list.add\n\t\t\t\t// promise.done = list.add\n\t\t\t\t// promise.fail = list.add\n\t\t\t\t_promise[tuple[1]] = list.add;\n\n\t\t\t\t// Handle state\n\t\t\t\tif (stateString) {\n\t\t\t\t\tlist.add(function () {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\t_state = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[3 - i][2].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[3 - i][3].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[0][2].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[0][3].lock);\n\t\t\t\t}\n\n\t\t\t\t// progress_handlers.fire\n\t\t\t\t// fulfilled_handlers.fire\n\t\t\t\t// rejected_handlers.fire\n\t\t\t\tlist.add(tuple[3].fire);\n\n\t\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\t\tdeferred[tuple[0]] = function () {\n\t\t\t\t\tdeferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\n\t\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\t\tdeferred[tuple[0] + \"With\"] = list.fireWith;\n\t\t\t});\n\n\t\t\t// Make the deferred a promise\n\t\t\t_promise.promise(deferred);\n\n\t\t\t// Call given func if any\n\t\t\tif (func) {\n\t\t\t\tfunc.call(deferred, deferred);\n\t\t\t}\n\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\n\t\t// Deferred helper\n\t\twhen: function when(singleValue) {\n\t\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array(i),\n\t\t\t    resolveValues = _slice.call(arguments),\n\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function updateFunc(i) {\n\t\t\t\treturn function (value) {\n\t\t\t\t\tresolveContexts[i] = this;\n\t\t\t\t\tresolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n\t\t\t\t\tif (! --remaining) {\n\t\t\t\t\t\tmaster.resolveWith(resolveContexts, resolveValues);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\t\tif (remaining <= 1) {\n\t\t\t\tadoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);\n\n\t\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\t\tif (master.state() === \"pending\" || isFunction(resolveValues[i] && resolveValues[i].then)) {\n\n\t\t\t\t\treturn master.then();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\t\twhile (i--) {\n\t\t\t\tadoptValue(resolveValues[i], updateFunc(i), master.reject);\n\t\t\t}\n\n\t\t\treturn master.promise();\n\t\t}\n\t});\n\n\t// These usually indicate a programmer mistake during development,\n\t// warn about them ASAP rather than swallowing them by default.\n\tvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\n\tjQuery.Deferred.exceptionHook = function (error, stack) {\n\n\t\t// Support: IE 8 - 9 only\n\t\t// Console exists when dev tools are open, which can happen at any time\n\t\tif (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\n\t\t\twindow.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, stack);\n\t\t}\n\t};\n\n\tjQuery.readyException = function (error) {\n\t\twindow.setTimeout(function () {\n\t\t\tthrow error;\n\t\t});\n\t};\n\n\t// The deferred used on DOM ready\n\tvar readyList = jQuery.Deferred();\n\n\tjQuery.fn.ready = function (fn) {\n\n\t\treadyList.then(fn)\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch(function (error) {\n\t\t\tjQuery.readyException(error);\n\t\t});\n\n\t\treturn this;\n\t};\n\n\tjQuery.extend({\n\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\n\t\t// Handle when the DOM is ready\n\t\tready: function ready(wait) {\n\n\t\t\t// Abort if there are pending holds or we're already ready\n\t\t\tif (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif (wait !== true && --jQuery.readyWait > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith(document, [jQuery]);\n\t\t}\n\t});\n\n\tjQuery.ready.then = readyList.then;\n\n\t// The ready event handler and self cleanup method\n\tfunction completed() {\n\t\tdocument.removeEventListener(\"DOMContentLoaded\", completed);\n\t\twindow.removeEventListener(\"load\", completed);\n\t\tjQuery.ready();\n\t}\n\n\t// Catch cases where $(document).ready() is called\n\t// after the browser event has already occurred.\n\t// Support: IE <=9 - 10 only\n\t// Older IE sometimes signals \"interactive\" too soon\n\tif (document.readyState === \"complete\" || document.readyState !== \"loading\" && !document.documentElement.doScroll) {\n\n\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\twindow.setTimeout(jQuery.ready);\n\t} else {\n\n\t\t// Use the handy event callback\n\t\tdocument.addEventListener(\"DOMContentLoaded\", completed);\n\n\t\t// A fallback to window.onload, that will always work\n\t\twindow.addEventListener(\"load\", completed);\n\t}\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\tvar access = function access(elems, fn, key, value, chainable, emptyGet, raw) {\n\t\tvar i = 0,\n\t\t    len = elems.length,\n\t\t    bulk = key == null;\n\n\t\t// Sets many values\n\t\tif (toType(key) === \"object\") {\n\t\t\tchainable = true;\n\t\t\tfor (i in key) {\n\t\t\t\taccess(elems, fn, i, key[i], true, emptyGet, raw);\n\t\t\t}\n\n\t\t\t// Sets one value\n\t\t} else if (value !== undefined) {\n\t\t\tchainable = true;\n\n\t\t\tif (!isFunction(value)) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif (bulk) {\n\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif (raw) {\n\t\t\t\t\tfn.call(elems, value);\n\t\t\t\t\tfn = null;\n\n\t\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function fn(elem, key, value) {\n\t\t\t\t\t\treturn bulk.call(jQuery(elem), value);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fn) {\n\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\tfn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (chainable) {\n\t\t\treturn elems;\n\t\t}\n\n\t\t// Gets\n\t\tif (bulk) {\n\t\t\treturn fn.call(elems);\n\t\t}\n\n\t\treturn len ? fn(elems[0], key) : emptyGet;\n\t};\n\n\t// Matches dashed string for camelizing\n\tvar rmsPrefix = /^-ms-/,\n\t    rdashAlpha = /-([a-z])/g;\n\n\t// Used by camelCase as callback to replace()\n\tfunction fcamelCase(all, letter) {\n\t\treturn letter.toUpperCase();\n\t}\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 15\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tfunction camelCase(string) {\n\t\treturn string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n\t}\n\tvar acceptData = function acceptData(owner) {\n\n\t\t// Accepts only:\n\t\t//  - Node\n\t\t//    - Node.ELEMENT_NODE\n\t\t//    - Node.DOCUMENT_NODE\n\t\t//  - Object\n\t\t//    - Any\n\t\treturn owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n\t};\n\n\tfunction Data() {\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\n\tData.uid = 1;\n\n\tData.prototype = {\n\n\t\tcache: function cache(owner) {\n\n\t\t\t// Check if the owner object already has a cache\n\t\t\tvar value = owner[this.expando];\n\n\t\t\t// If not, create one\n\t\t\tif (!value) {\n\t\t\t\tvalue = {};\n\n\t\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t\t// but we should not, see #8335.\n\t\t\t\t// Always return an empty object.\n\t\t\t\tif (acceptData(owner)) {\n\n\t\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t\t// use plain assignment\n\t\t\t\t\tif (owner.nodeType) {\n\t\t\t\t\t\towner[this.expando] = value;\n\n\t\t\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t\t\t// deleted when data is removed\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject.defineProperty(owner, this.expando, {\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\t\tset: function set(owner, data, value) {\n\t\t\tvar prop,\n\t\t\t    cache = this.cache(owner);\n\n\t\t\t// Handle: [ owner, key, value ] args\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\tif (typeof data === \"string\") {\n\t\t\t\tcache[camelCase(data)] = value;\n\n\t\t\t\t// Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\n\t\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\t\tfor (prop in data) {\n\t\t\t\t\tcache[camelCase(prop)] = data[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cache;\n\t\t},\n\t\tget: function get(owner, key) {\n\t\t\treturn key === undefined ? this.cache(owner) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[this.expando] && owner[this.expando][camelCase(key)];\n\t\t},\n\t\taccess: function access(owner, key, value) {\n\n\t\t\t// In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\t\t\tif (key === undefined || key && typeof key === \"string\" && value === undefined) {\n\n\t\t\t\treturn this.get(owner, key);\n\t\t\t}\n\n\t\t\t// When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\t\t\tthis.set(owner, key, value);\n\n\t\t\t// Since the \"set\" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function remove(owner, key) {\n\t\t\tvar i,\n\t\t\t    cache = owner[this.expando];\n\n\t\t\tif (cache === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (key !== undefined) {\n\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif (Array.isArray(key)) {\n\n\t\t\t\t\t// If key is an array of keys...\n\t\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\t\tkey = key.map(camelCase);\n\t\t\t\t} else {\n\t\t\t\t\tkey = camelCase(key);\n\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tkey = key in cache ? [key] : key.match(rnothtmlwhite) || [];\n\t\t\t\t}\n\n\t\t\t\ti = key.length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tdelete cache[key[i]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the expando if there's no more data\n\t\t\tif (key === undefined || jQuery.isEmptyObject(cache)) {\n\n\t\t\t\t// Support: Chrome <=35 - 45\n\t\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\t\tif (owner.nodeType) {\n\t\t\t\t\towner[this.expando] = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tdelete owner[this.expando];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function hasData(owner) {\n\t\t\tvar cache = owner[this.expando];\n\t\t\treturn cache !== undefined && !jQuery.isEmptyObject(cache);\n\t\t}\n\t};\n\tvar dataPriv = new Data();\n\n\tvar dataUser = new Data();\n\n\t//\tImplementation Summary\n\t//\n\t//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t//\t2. Improve the module's maintainability by reducing the storage\n\t//\t\tpaths to a single mechanism.\n\t//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t    rmultiDash = /[A-Z]/g;\n\n\tfunction getData(data) {\n\t\tif (data === \"true\") {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (data === \"false\") {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (data === \"null\") {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Only convert to a number if it doesn't change the string\n\t\tif (data === +data + \"\") {\n\t\t\treturn +data;\n\t\t}\n\n\t\tif (rbrace.test(data)) {\n\t\t\treturn JSON.parse(data);\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tfunction dataAttr(elem, key, data) {\n\t\tvar name;\n\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif (data === undefined && elem.nodeType === 1) {\n\t\t\tname = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n\t\t\tdata = elem.getAttribute(name);\n\n\t\t\tif (typeof data === \"string\") {\n\t\t\t\ttry {\n\t\t\t\t\tdata = getData(data);\n\t\t\t\t} catch (e) {}\n\n\t\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\t\tdataUser.set(elem, key, data);\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\n\tjQuery.extend({\n\t\thasData: function hasData(elem) {\n\t\t\treturn dataUser.hasData(elem) || dataPriv.hasData(elem);\n\t\t},\n\n\t\tdata: function data(elem, name, _data) {\n\t\t\treturn dataUser.access(elem, name, _data);\n\t\t},\n\n\t\tremoveData: function removeData(elem, name) {\n\t\t\tdataUser.remove(elem, name);\n\t\t},\n\n\t\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t\t// with direct calls to dataPriv methods, these can be deprecated.\n\t\t_data: function _data(elem, name, data) {\n\t\t\treturn dataPriv.access(elem, name, data);\n\t\t},\n\n\t\t_removeData: function _removeData(elem, name) {\n\t\t\tdataPriv.remove(elem, name);\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tdata: function data(key, value) {\n\t\t\tvar i,\n\t\t\t    name,\n\t\t\t    data,\n\t\t\t    elem = this[0],\n\t\t\t    attrs = elem && elem.attributes;\n\n\t\t\t// Gets all values\n\t\t\tif (key === undefined) {\n\t\t\t\tif (this.length) {\n\t\t\t\t\tdata = dataUser.get(elem);\n\n\t\t\t\t\tif (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile (i--) {\n\n\t\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\t\tif (attrs[i]) {\n\t\t\t\t\t\t\t\tname = attrs[i].name;\n\t\t\t\t\t\t\t\tif (name.indexOf(\"data-\") === 0) {\n\t\t\t\t\t\t\t\t\tname = camelCase(name.slice(5));\n\t\t\t\t\t\t\t\t\tdataAttr(elem, name, data[name]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataPriv.set(elem, \"hasDataAttrs\", true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t// Sets multiple values\n\t\t\tif ((typeof key === \"undefined\" ? \"undefined\" : _typeof(key)) === \"object\") {\n\t\t\t\treturn this.each(function () {\n\t\t\t\t\tdataUser.set(this, key);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn access(this, function (value) {\n\t\t\t\tvar data;\n\n\t\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\t\tif (elem && value === undefined) {\n\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\t\tdata = dataUser.get(elem, key);\n\t\t\t\t\tif (data !== undefined) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\t\tdata = dataAttr(elem, key);\n\t\t\t\t\tif (data !== undefined) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the data...\n\t\t\t\tthis.each(function () {\n\n\t\t\t\t\t// We always store the camelCased key\n\t\t\t\t\tdataUser.set(this, key, value);\n\t\t\t\t});\n\t\t\t}, null, value, arguments.length > 1, null, true);\n\t\t},\n\n\t\tremoveData: function removeData(key) {\n\t\t\treturn this.each(function () {\n\t\t\t\tdataUser.remove(this, key);\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tqueue: function queue(elem, type, data) {\n\t\t\tvar queue;\n\n\t\t\tif (elem) {\n\t\t\t\ttype = (type || \"fx\") + \"queue\";\n\t\t\t\tqueue = dataPriv.get(elem, type);\n\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif (data) {\n\t\t\t\t\tif (!queue || Array.isArray(data)) {\n\t\t\t\t\t\tqueue = dataPriv.access(elem, type, jQuery.makeArray(data));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\n\t\tdequeue: function dequeue(elem, type) {\n\t\t\ttype = type || \"fx\";\n\n\t\t\tvar queue = jQuery.queue(elem, type),\n\t\t\t    startLength = queue.length,\n\t\t\t    fn = queue.shift(),\n\t\t\t    hooks = jQuery._queueHooks(elem, type),\n\t\t\t    next = function next() {\n\t\t\t\tjQuery.dequeue(elem, type);\n\t\t\t};\n\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif (fn === \"inprogress\") {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\n\t\t\tif (fn) {\n\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif (type === \"fx\") {\n\t\t\t\t\tqueue.unshift(\"inprogress\");\n\t\t\t\t}\n\n\t\t\t\t// Clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call(elem, next, hooks);\n\t\t\t}\n\n\t\t\tif (!startLength && hooks) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\n\t\t// Not public - generate a queueHooks object, or return the current one\n\t\t_queueHooks: function _queueHooks(elem, type) {\n\t\t\tvar key = type + \"queueHooks\";\n\t\t\treturn dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n\t\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function () {\n\t\t\t\t\tdataPriv.remove(elem, [type + \"queue\", key]);\n\t\t\t\t})\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tqueue: function queue(type, data) {\n\t\t\tvar setter = 2;\n\n\t\t\tif (typeof type !== \"string\") {\n\t\t\t\tdata = type;\n\t\t\t\ttype = \"fx\";\n\t\t\t\tsetter--;\n\t\t\t}\n\n\t\t\tif (arguments.length < setter) {\n\t\t\t\treturn jQuery.queue(this[0], type);\n\t\t\t}\n\n\t\t\treturn data === undefined ? this : this.each(function () {\n\t\t\t\tvar queue = jQuery.queue(this, type, data);\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks(this, type);\n\n\t\t\t\tif (type === \"fx\" && queue[0] !== \"inprogress\") {\n\t\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdequeue: function dequeue(type) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t});\n\t\t},\n\t\tclearQueue: function clearQueue(type) {\n\t\t\treturn this.queue(type || \"fx\", []);\n\t\t},\n\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function promise(type, obj) {\n\t\t\tvar tmp,\n\t\t\t    count = 1,\n\t\t\t    defer = jQuery.Deferred(),\n\t\t\t    elements = this,\n\t\t\t    i = this.length,\n\t\t\t    resolve = function resolve() {\n\t\t\t\tif (! --count) {\n\t\t\t\t\tdefer.resolveWith(elements, [elements]);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (typeof type !== \"string\") {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || \"fx\";\n\n\t\t\twhile (i--) {\n\t\t\t\ttmp = dataPriv.get(elements[i], type + \"queueHooks\");\n\t\t\t\tif (tmp && tmp.empty) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add(resolve);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise(obj);\n\t\t}\n\t});\n\tvar pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n\n\tvar rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n\n\tvar cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n\n\tvar isHiddenWithinTree = function isHiddenWithinTree(elem, el) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" || elem.style.display === \"\" &&\n\n\t\t// Otherwise, check computed style\n\t\t// Support: Firefox <=43 - 45\n\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t// in the document.\n\t\tjQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, \"display\") === \"none\";\n\t};\n\n\tvar swap = function swap(elem, options, callback, args) {\n\t\tvar ret,\n\t\t    name,\n\t\t    old = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor (name in options) {\n\t\t\told[name] = elem.style[name];\n\t\t\telem.style[name] = options[name];\n\t\t}\n\n\t\tret = callback.apply(elem, args || []);\n\n\t\t// Revert the old values\n\t\tfor (name in options) {\n\t\t\telem.style[name] = old[name];\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\tfunction adjustCSS(elem, prop, valueParts, tween) {\n\t\tvar adjusted,\n\t\t    scale,\n\t\t    maxIterations = 20,\n\t\t    currentValue = tween ? function () {\n\t\t\treturn tween.cur();\n\t\t} : function () {\n\t\t\treturn jQuery.css(elem, prop, \"\");\n\t\t},\n\t\t    initial = currentValue(),\n\t\t    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n\n\t\tif (initialInUnit && initialInUnit[3] !== unit) {\n\n\t\t\t// Support: Firefox <=54\n\t\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\t\tinitial = initial / 2;\n\n\t\t\t// Trust units reported by jQuery.css\n\t\t\tunit = unit || initialInUnit[3];\n\n\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\tinitialInUnit = +initial || 1;\n\n\t\t\twhile (maxIterations--) {\n\n\t\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\t\tjQuery.style(elem, prop, initialInUnit + unit);\n\t\t\t\tif ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\n\t\t\t\t\tmaxIterations = 0;\n\t\t\t\t}\n\t\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\t}\n\n\t\t\tinitialInUnit = initialInUnit * 2;\n\t\t\tjQuery.style(elem, prop, initialInUnit + unit);\n\n\t\t\t// Make sure we update the tween properties later on\n\t\t\tvalueParts = valueParts || [];\n\t\t}\n\n\t\tif (valueParts) {\n\t\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t\t// Apply relative offset (+=/-=) if specified\n\t\t\tadjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n\t\t\tif (tween) {\n\t\t\t\ttween.unit = unit;\n\t\t\t\ttween.start = initialInUnit;\n\t\t\t\ttween.end = adjusted;\n\t\t\t}\n\t\t}\n\t\treturn adjusted;\n\t}\n\n\tvar defaultDisplayMap = {};\n\n\tfunction getDefaultDisplay(elem) {\n\t\tvar temp,\n\t\t    doc = elem.ownerDocument,\n\t\t    nodeName = elem.nodeName,\n\t\t    display = defaultDisplayMap[nodeName];\n\n\t\tif (display) {\n\t\t\treturn display;\n\t\t}\n\n\t\ttemp = doc.body.appendChild(doc.createElement(nodeName));\n\t\tdisplay = jQuery.css(temp, \"display\");\n\n\t\ttemp.parentNode.removeChild(temp);\n\n\t\tif (display === \"none\") {\n\t\t\tdisplay = \"block\";\n\t\t}\n\t\tdefaultDisplayMap[nodeName] = display;\n\n\t\treturn display;\n\t}\n\n\tfunction showHide(elements, show) {\n\t\tvar display,\n\t\t    elem,\n\t\t    values = [],\n\t\t    index = 0,\n\t\t    length = elements.length;\n\n\t\t// Determine new display value for elements that need to change\n\t\tfor (; index < length; index++) {\n\t\t\telem = elements[index];\n\t\t\tif (!elem.style) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdisplay = elem.style.display;\n\t\t\tif (show) {\n\n\t\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t\t// inline or about-to-be-restored)\n\t\t\t\tif (display === \"none\") {\n\t\t\t\t\tvalues[index] = dataPriv.get(elem, \"display\") || null;\n\t\t\t\t\tif (!values[index]) {\n\t\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n\t\t\t\t\tvalues[index] = getDefaultDisplay(elem);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (display !== \"none\") {\n\t\t\t\t\tvalues[index] = \"none\";\n\n\t\t\t\t\t// Remember what we're overwriting\n\t\t\t\t\tdataPriv.set(elem, \"display\", display);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set the display of the elements in a second loop to avoid constant reflow\n\t\tfor (index = 0; index < length; index++) {\n\t\t\tif (values[index] != null) {\n\t\t\t\telements[index].style.display = values[index];\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\tjQuery.fn.extend({\n\t\tshow: function show() {\n\t\t\treturn showHide(this, true);\n\t\t},\n\t\thide: function hide() {\n\t\t\treturn showHide(this);\n\t\t},\n\t\ttoggle: function toggle(state) {\n\t\t\tif (typeof state === \"boolean\") {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tif (isHiddenWithinTree(this)) {\n\t\t\t\t\tjQuery(this).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery(this).hide();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\tvar rcheckableType = /^(?:checkbox|radio)$/i;\n\n\tvar rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i;\n\n\tvar rscriptType = /^$|^module$|\\/(?:java|ecma)script/i;\n\n\t// We have to close these tags to support XHTML (#13200)\n\tvar wrapMap = {\n\n\t\t// Support: IE <=9 only\n\t\toption: [1, \"<select multiple='multiple'>\", \"</select>\"],\n\n\t\t// XHTML parsers do not magically insert elements in the\n\t\t// same way that tag soup parsers do. So we cannot shorten\n\t\t// this by omitting <tbody> or other required elements.\n\t\tthead: [1, \"<table>\", \"</table>\"],\n\t\tcol: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n\t\ttr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n\t\ttd: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n\n\t\t_default: [0, \"\", \"\"]\n\t};\n\n\t// Support: IE <=9 only\n\twrapMap.optgroup = wrapMap.option;\n\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\n\tfunction getAll(context, tag) {\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\t\tvar ret;\n\n\t\tif (typeof context.getElementsByTagName !== \"undefined\") {\n\t\t\tret = context.getElementsByTagName(tag || \"*\");\n\t\t} else if (typeof context.querySelectorAll !== \"undefined\") {\n\t\t\tret = context.querySelectorAll(tag || \"*\");\n\t\t} else {\n\t\t\tret = [];\n\t\t}\n\n\t\tif (tag === undefined || tag && nodeName(context, tag)) {\n\t\t\treturn jQuery.merge([context], ret);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval(elems, refElements) {\n\t\tvar i = 0,\n\t\t    l = elems.length;\n\n\t\tfor (; i < l; i++) {\n\t\t\tdataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\n\t\t}\n\t}\n\n\tvar rhtml = /<|&#?\\w+;/;\n\n\tfunction buildFragment(elems, context, scripts, selection, ignored) {\n\t\tvar elem,\n\t\t    tmp,\n\t\t    tag,\n\t\t    wrap,\n\t\t    contains,\n\t\t    j,\n\t\t    fragment = context.createDocumentFragment(),\n\t\t    nodes = [],\n\t\t    i = 0,\n\t\t    l = elems.length;\n\n\t\tfor (; i < l; i++) {\n\t\t\telem = elems[i];\n\n\t\t\tif (elem || elem === 0) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif (toType(elem) === \"object\") {\n\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge(nodes, elem.nodeType ? [elem] : elem);\n\n\t\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if (!rhtml.test(elem)) {\n\t\t\t\t\tnodes.push(context.createTextNode(elem));\n\n\t\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild(context.createElement(\"div\"));\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n\t\t\t\t\twrap = wrapMap[tag] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[0];\n\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge(nodes, tmp.childNodes);\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile (elem = nodes[i++]) {\n\n\t\t\t// Skip elements already in the context collection (trac-4087)\n\t\t\tif (selection && jQuery.inArray(elem, selection) > -1) {\n\t\t\t\tif (ignored) {\n\t\t\t\t\tignored.push(elem);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains(elem.ownerDocument, elem);\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll(fragment.appendChild(elem), \"script\");\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif (contains) {\n\t\t\t\tsetGlobalEval(tmp);\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif (scripts) {\n\t\t\t\tj = 0;\n\t\t\t\twhile (elem = tmp[j++]) {\n\t\t\t\t\tif (rscriptType.test(elem.type || \"\")) {\n\t\t\t\t\t\tscripts.push(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t}\n\n\t(function () {\n\t\tvar fragment = document.createDocumentFragment(),\n\t\t    div = fragment.appendChild(document.createElement(\"div\")),\n\t\t    input = document.createElement(\"input\");\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Check state lost if the name is set (#11217)\n\t\t// Support: Windows Web Apps (WWA)\n\t\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\t\tinput.setAttribute(\"type\", \"radio\");\n\t\tinput.setAttribute(\"checked\", \"checked\");\n\t\tinput.setAttribute(\"name\", \"t\");\n\n\t\tdiv.appendChild(input);\n\n\t\t// Support: Android <=4.1 only\n\t\t// Older WebKit doesn't clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\n\n\t\t// Support: IE <=11 only\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\t\tsupport.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n\t})();\n\tvar documentElement = document.documentElement;\n\n\tvar rkeyEvent = /^key/,\n\t    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\t    rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\n\t// Support: IE <=9 only\n\t// See #13393 for more info\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch (err) {}\n\t}\n\n\tfunction _on(elem, types, selector, data, fn, one) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ((typeof types === \"undefined\" ? \"undefined\" : _typeof(types)) === \"object\") {\n\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif (typeof selector !== \"string\") {\n\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor (type in types) {\n\t\t\t\t_on(elem, type, selector, data, types[type], one);\n\t\t\t}\n\t\t\treturn elem;\n\t\t}\n\n\t\tif (data == null && fn == null) {\n\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if (fn == null) {\n\t\t\tif (typeof selector === \"string\") {\n\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif (fn === false) {\n\t\t\tfn = returnFalse;\n\t\t} else if (!fn) {\n\t\t\treturn elem;\n\t\t}\n\n\t\tif (one === 1) {\n\t\t\torigFn = fn;\n\t\t\tfn = function fn(event) {\n\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off(event);\n\t\t\t\treturn origFn.apply(this, arguments);\n\t\t\t};\n\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n\t\t}\n\t\treturn elem.each(function () {\n\t\t\tjQuery.event.add(this, types, fn, data, selector);\n\t\t});\n\t}\n\n\t/*\n  * Helper functions for managing events -- not part of the public interface.\n  * Props to Dean Edwards' addEvent library for many of the ideas.\n  */\n\tjQuery.event = {\n\n\t\tglobal: {},\n\n\t\tadd: function add(elem, types, handler, data, selector) {\n\n\t\t\tvar handleObjIn,\n\t\t\t    eventHandle,\n\t\t\t    tmp,\n\t\t\t    events,\n\t\t\t    t,\n\t\t\t    handleObj,\n\t\t\t    special,\n\t\t\t    handlers,\n\t\t\t    type,\n\t\t\t    namespaces,\n\t\t\t    origType,\n\t\t\t    elemData = dataPriv.get(elem);\n\n\t\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif (!elemData) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif (handler.handler) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\n\t\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\t\tif (selector) {\n\t\t\t\tjQuery.find.matchesSelector(documentElement, selector);\n\t\t\t}\n\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif (!handler.guid) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\n\t\t\t// Init the element's event structure and main handler, if this is the first\n\t\t\tif (!(events = elemData.events)) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif (!(eventHandle = elemData.handle)) {\n\t\t\t\teventHandle = elemData.handle = function (e) {\n\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = (types || \"\").match(rnothtmlwhite) || [\"\"];\n\t\t\tt = types.length;\n\t\t\twhile (t--) {\n\t\t\t\ttmp = rtypenamespace.exec(types[t]) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = (tmp[2] || \"\").split(\".\").sort();\n\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif (!type) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = (selector ? special.delegateType : special.bindType) || type;\n\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend({\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test(selector),\n\t\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t\t}, handleObjIn);\n\n\t\t\t\t// Init the event handler queue if we're the first\n\t\t\t\tif (!(handlers = events[type])) {\n\t\t\t\t\thandlers = events[type] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\t\tif (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n\n\t\t\t\t\t\tif (elem.addEventListener) {\n\t\t\t\t\t\t\telem.addEventListener(type, eventHandle);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (special.add) {\n\t\t\t\t\tspecial.add.call(elem, handleObj);\n\n\t\t\t\t\tif (!handleObj.handler.guid) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add to the element's handler list, delegates in front\n\t\t\t\tif (selector) {\n\t\t\t\t\thandlers.splice(handlers.delegateCount++, 0, handleObj);\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push(handleObj);\n\t\t\t\t}\n\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[type] = true;\n\t\t\t}\n\t\t},\n\n\t\t// Detach an event or set of events from an element\n\t\tremove: function remove(elem, types, handler, selector, mappedTypes) {\n\n\t\t\tvar j,\n\t\t\t    origCount,\n\t\t\t    tmp,\n\t\t\t    events,\n\t\t\t    t,\n\t\t\t    handleObj,\n\t\t\t    special,\n\t\t\t    handlers,\n\t\t\t    type,\n\t\t\t    namespaces,\n\t\t\t    origType,\n\t\t\t    elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n\n\t\t\tif (!elemData || !(events = elemData.events)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = (types || \"\").match(rnothtmlwhite) || [\"\"];\n\t\t\tt = types.length;\n\t\t\twhile (t--) {\n\t\t\t\ttmp = rtypenamespace.exec(types[t]) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = (tmp[2] || \"\").split(\".\").sort();\n\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif (!type) {\n\t\t\t\t\tfor (type in events) {\n\t\t\t\t\t\tjQuery.event.remove(elem, type + types[t], handler, selector, true);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\t\t\t\ttype = (selector ? special.delegateType : special.bindType) || type;\n\t\t\t\thandlers = events[type] || [];\n\t\t\t\ttmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\");\n\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile (j--) {\n\t\t\t\t\thandleObj = handlers[j];\n\n\t\t\t\t\tif ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n\t\t\t\t\t\thandlers.splice(j, 1);\n\n\t\t\t\t\t\tif (handleObj.selector) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (special.remove) {\n\t\t\t\t\t\t\tspecial.remove.call(elem, handleObj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif (origCount && !handlers.length) {\n\t\t\t\t\tif (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n\n\t\t\t\t\t\tjQuery.removeEvent(elem, type, elemData.handle);\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete events[type];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove data and the expando if it's no longer used\n\t\t\tif (jQuery.isEmptyObject(events)) {\n\t\t\t\tdataPriv.remove(elem, \"handle events\");\n\t\t\t}\n\t\t},\n\n\t\tdispatch: function dispatch(nativeEvent) {\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tvar event = jQuery.event.fix(nativeEvent);\n\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    ret,\n\t\t\t    matched,\n\t\t\t    handleObj,\n\t\t\t    handlerQueue,\n\t\t\t    args = new Array(arguments.length),\n\t\t\t    handlers = (dataPriv.get(this, \"events\") || {})[event.type] || [],\n\t\t\t    special = jQuery.event.special[event.type] || {};\n\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[0] = event;\n\n\t\t\tfor (i = 1; i < arguments.length; i++) {\n\t\t\t\targs[i] = arguments[i];\n\t\t\t}\n\n\t\t\tevent.delegateTarget = this;\n\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif (special.preDispatch && special.preDispatch.call(this, event) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call(this, event, handlers);\n\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\t\tj = 0;\n\t\t\t\twhile ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {\n\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\t\tret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n\t\t\t\t\t\tif (ret !== undefined) {\n\t\t\t\t\t\t\tif ((event.result = ret) === false) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif (special.postDispatch) {\n\t\t\t\tspecial.postDispatch.call(this, event);\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\thandlers: function handlers(event, _handlers) {\n\t\t\tvar i,\n\t\t\t    handleObj,\n\t\t\t    sel,\n\t\t\t    matchedHandlers,\n\t\t\t    matchedSelectors,\n\t\t\t    handlerQueue = [],\n\t\t\t    delegateCount = _handlers.delegateCount,\n\t\t\t    cur = event.target;\n\n\t\t\t// Find delegate handlers\n\t\t\tif (delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!(event.type === \"click\" && event.button >= 1)) {\n\n\t\t\t\tfor (; cur !== this; cur = cur.parentNode || this) {\n\n\t\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\n\t\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\t\tfor (i = 0; i < delegateCount; i++) {\n\t\t\t\t\t\t\thandleObj = _handlers[i];\n\n\t\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\t\tif (matchedSelectors[sel] === undefined) {\n\t\t\t\t\t\t\t\tmatchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (matchedSelectors[sel]) {\n\t\t\t\t\t\t\t\tmatchedHandlers.push(handleObj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (matchedHandlers.length) {\n\t\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matchedHandlers });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tcur = this;\n\t\t\tif (delegateCount < _handlers.length) {\n\t\t\t\thandlerQueue.push({ elem: cur, handlers: _handlers.slice(delegateCount) });\n\t\t\t}\n\n\t\t\treturn handlerQueue;\n\t\t},\n\n\t\taddProp: function addProp(name, hook) {\n\t\t\tObject.defineProperty(jQuery.Event.prototype, name, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\n\t\t\t\tget: isFunction(hook) ? function () {\n\t\t\t\t\tif (this.originalEvent) {\n\t\t\t\t\t\treturn hook(this.originalEvent);\n\t\t\t\t\t}\n\t\t\t\t} : function () {\n\t\t\t\t\tif (this.originalEvent) {\n\t\t\t\t\t\treturn this.originalEvent[name];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tset: function set(value) {\n\t\t\t\t\tObject.defineProperty(this, name, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tfix: function fix(originalEvent) {\n\t\t\treturn originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n\t\t},\n\n\t\tspecial: {\n\t\t\tload: {\n\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this !== safeActiveElement() && this.focus) {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusin\"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this === safeActiveElement() && this.blur) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusout\"\n\t\t\t},\n\t\t\tclick: {\n\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this.type === \"checkbox\" && this.click && nodeName(this, \"input\")) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t\t_default: function _default(event) {\n\t\t\t\t\treturn nodeName(event.target, \"a\");\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function postDispatch(event) {\n\n\t\t\t\t\t// Support: Firefox 20+\n\t\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\t\tif (event.result !== undefined && event.originalEvent) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.removeEvent = function (elem, type, handle) {\n\n\t\t// This \"if\" is needed for plain objects\n\t\tif (elem.removeEventListener) {\n\t\t\telem.removeEventListener(type, handle);\n\t\t}\n\t};\n\n\tjQuery.Event = function (src, props) {\n\n\t\t// Allow instantiation without the 'new' keyword\n\t\tif (!(this instanceof jQuery.Event)) {\n\t\t\treturn new jQuery.Event(src, props);\n\t\t}\n\n\t\t// Event object\n\t\tif (src && src.type) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&\n\n\t\t\t// Support: Android <=2.3 only\n\t\t\tsrc.returnValue === false ? returnTrue : returnFalse;\n\n\t\t\t// Create target properties\n\t\t\t// Support: Safari <=6 - 7 only\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tthis.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n\n\t\t\tthis.currentTarget = src.currentTarget;\n\t\t\tthis.relatedTarget = src.relatedTarget;\n\n\t\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\n\t\t// Put explicitly provided properties onto the event object\n\t\tif (props) {\n\t\t\tjQuery.extend(this, props);\n\t\t}\n\n\t\t// Create a timestamp if incoming event doesn't have one\n\t\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t\t// Mark it as fixed\n\t\tthis[jQuery.expando] = true;\n\t};\n\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tconstructor: jQuery.Event,\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\t\tisSimulated: false,\n\n\t\tpreventDefault: function preventDefault() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\t\tif (e && !this.isSimulated) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function stopPropagation() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isPropagationStopped = returnTrue;\n\n\t\t\tif (e && !this.isSimulated) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tstopImmediatePropagation: function stopImmediatePropagation() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\t\tif (e && !this.isSimulated) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\n\t// Includes all common event props including KeyEvent and MouseEvent specific props\n\tjQuery.each({\n\t\taltKey: true,\n\t\tbubbles: true,\n\t\tcancelable: true,\n\t\tchangedTouches: true,\n\t\tctrlKey: true,\n\t\tdetail: true,\n\t\teventPhase: true,\n\t\tmetaKey: true,\n\t\tpageX: true,\n\t\tpageY: true,\n\t\tshiftKey: true,\n\t\tview: true,\n\t\t\"char\": true,\n\t\tcharCode: true,\n\t\tkey: true,\n\t\tkeyCode: true,\n\t\tbutton: true,\n\t\tbuttons: true,\n\t\tclientX: true,\n\t\tclientY: true,\n\t\toffsetX: true,\n\t\toffsetY: true,\n\t\tpointerId: true,\n\t\tpointerType: true,\n\t\tscreenX: true,\n\t\tscreenY: true,\n\t\ttargetTouches: true,\n\t\ttoElement: true,\n\t\ttouches: true,\n\n\t\twhich: function which(event) {\n\t\t\tvar button = event.button;\n\n\t\t\t// Add which for key events\n\t\t\tif (event.which == null && rkeyEvent.test(event.type)) {\n\t\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\tif (!event.which && button !== undefined && rmouseEvent.test(event.type)) {\n\t\t\t\tif (button & 1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (button & 2) {\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\n\t\t\t\tif (button & 4) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn event.which;\n\t\t}\n\t}, jQuery.event.addProp);\n\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// so that event delegation works in jQuery.\n\t// Do the same for pointerenter/pointerleave and pointerover/pointerout\n\t//\n\t// Support: Safari 7 only\n\t// Safari sends mouseenter too often; see:\n\t// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n\t// for the description of the bug (it existed in older Chrome versions as well).\n\tjQuery.each({\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\",\n\t\tpointerenter: \"pointerover\",\n\t\tpointerleave: \"pointerout\"\n\t}, function (orig, fix) {\n\t\tjQuery.event.special[orig] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\n\t\t\thandle: function handle(event) {\n\t\t\t\tvar ret,\n\t\t\t\t    target = this,\n\t\t\t\t    related = event.relatedTarget,\n\t\t\t\t    handleObj = event.handleObj;\n\n\t\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif (!related || related !== target && !jQuery.contains(target, related)) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply(this, arguments);\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t});\n\n\tjQuery.fn.extend({\n\n\t\ton: function on(types, selector, data, fn) {\n\t\t\treturn _on(this, types, selector, data, fn);\n\t\t},\n\t\tone: function one(types, selector, data, fn) {\n\t\t\treturn _on(this, types, selector, data, fn, 1);\n\t\t},\n\t\toff: function off(types, selector, fn) {\n\t\t\tvar handleObj, type;\n\t\t\tif (types && types.preventDefault && types.handleObj) {\n\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ((typeof types === \"undefined\" ? \"undefined\" : _typeof(types)) === \"object\") {\n\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor (type in types) {\n\t\t\t\t\tthis.off(type, selector, types[type]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (selector === false || typeof selector === \"function\") {\n\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif (fn === false) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.event.remove(this, types, fn, selector);\n\t\t\t});\n\t\t}\n\t});\n\n\tvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t    rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n\t// Prefer a tbody over its parent table for containing new rows\n\tfunction manipulationTarget(elem, content) {\n\t\tif (nodeName(elem, \"table\") && nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\n\n\t\t\treturn jQuery(elem).children(\"tbody\")[0] || elem;\n\t\t}\n\n\t\treturn elem;\n\t}\n\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript(elem) {\n\t\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript(elem) {\n\t\tif ((elem.type || \"\").slice(0, 5) === \"true/\") {\n\t\t\telem.type = elem.type.slice(5);\n\t\t} else {\n\t\t\telem.removeAttribute(\"type\");\n\t\t}\n\n\t\treturn elem;\n\t}\n\n\tfunction cloneCopyEvent(src, dest) {\n\t\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\t\tif (dest.nodeType !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 1. Copy private data: events, handlers, etc.\n\t\tif (dataPriv.hasData(src)) {\n\t\t\tpdataOld = dataPriv.access(src);\n\t\t\tpdataCur = dataPriv.set(dest, pdataOld);\n\t\t\tevents = pdataOld.events;\n\n\t\t\tif (events) {\n\t\t\t\tdelete pdataCur.handle;\n\t\t\t\tpdataCur.events = {};\n\n\t\t\t\tfor (type in events) {\n\t\t\t\t\tfor (i = 0, l = events[type].length; i < l; i++) {\n\t\t\t\t\t\tjQuery.event.add(dest, type, events[type][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. Copy user data\n\t\tif (dataUser.hasData(src)) {\n\t\t\tudataOld = dataUser.access(src);\n\t\t\tudataCur = jQuery.extend({}, udataOld);\n\n\t\t\tdataUser.set(dest, udataCur);\n\t\t}\n\t}\n\n\t// Fix IE bugs, see support tests\n\tfunction fixInput(src, dest) {\n\t\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\t\tif (nodeName === \"input\" && rcheckableType.test(src.type)) {\n\t\t\tdest.checked = src.checked;\n\n\t\t\t// Fails to return the selected option to the default selected state when cloning options\n\t\t} else if (nodeName === \"input\" || nodeName === \"textarea\") {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\n\tfunction domManip(collection, args, callback, ignored) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply([], args);\n\n\t\tvar fragment,\n\t\t    first,\n\t\t    scripts,\n\t\t    hasScripts,\n\t\t    node,\n\t\t    doc,\n\t\t    i = 0,\n\t\t    l = collection.length,\n\t\t    iNoClone = l - 1,\n\t\t    value = args[0],\n\t\t    valueIsFunction = isFunction(value);\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif (valueIsFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n\t\t\treturn collection.each(function (index) {\n\t\t\t\tvar self = collection.eq(index);\n\t\t\t\tif (valueIsFunction) {\n\t\t\t\t\targs[0] = value.call(this, index, self.html());\n\t\t\t\t}\n\t\t\t\tdomManip(self, args, callback, ignored);\n\t\t\t});\n\t\t}\n\n\t\tif (l) {\n\t\t\tfragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif (fragment.childNodes.length === 1) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\t\tif (first || ignored) {\n\t\t\t\tscripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item\n\t\t\t\t// instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif (i !== iNoClone) {\n\t\t\t\t\t\tnode = jQuery.clone(node, true, true);\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif (hasScripts) {\n\n\t\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\t\tjQuery.merge(scripts, getAll(node, \"script\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call(collection[i], node, i);\n\t\t\t\t}\n\n\t\t\t\tif (hasScripts) {\n\t\t\t\t\tdoc = scripts[scripts.length - 1].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map(scripts, restoreScript);\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor (i = 0; i < hasScripts; i++) {\n\t\t\t\t\t\tnode = scripts[i];\n\t\t\t\t\t\tif (rscriptType.test(node.type || \"\") && !dataPriv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n\n\t\t\t\t\t\t\tif (node.src && (node.type || \"\").toLowerCase() !== \"module\") {\n\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif (jQuery._evalUrl) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl(node.src);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDOMEval(node.textContent.replace(rcleanScript, \"\"), doc, node);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn collection;\n\t}\n\n\tfunction _remove(elem, selector, keepData) {\n\t\tvar node,\n\t\t    nodes = selector ? jQuery.filter(selector, elem) : elem,\n\t\t    i = 0;\n\n\t\tfor (; (node = nodes[i]) != null; i++) {\n\t\t\tif (!keepData && node.nodeType === 1) {\n\t\t\t\tjQuery.cleanData(getAll(node));\n\t\t\t}\n\n\t\t\tif (node.parentNode) {\n\t\t\t\tif (keepData && jQuery.contains(node.ownerDocument, node)) {\n\t\t\t\t\tsetGlobalEval(getAll(node, \"script\"));\n\t\t\t\t}\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t}\n\t\t}\n\n\t\treturn elem;\n\t}\n\n\tjQuery.extend({\n\t\thtmlPrefilter: function htmlPrefilter(html) {\n\t\t\treturn html.replace(rxhtmlTag, \"<$1></$2>\");\n\t\t},\n\n\t\tclone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n\t\t\tvar i,\n\t\t\t    l,\n\t\t\t    srcElements,\n\t\t\t    destElements,\n\t\t\t    clone = elem.cloneNode(true),\n\t\t\t    inPage = jQuery.contains(elem.ownerDocument, elem);\n\n\t\t\t// Fix IE cloning issues\n\t\t\tif (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n\n\t\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll(clone);\n\t\t\t\tsrcElements = getAll(elem);\n\n\t\t\t\tfor (i = 0, l = srcElements.length; i < l; i++) {\n\t\t\t\t\tfixInput(srcElements[i], destElements[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif (dataAndEvents) {\n\t\t\t\tif (deepDataAndEvents) {\n\t\t\t\t\tsrcElements = srcElements || getAll(elem);\n\t\t\t\t\tdestElements = destElements || getAll(clone);\n\n\t\t\t\t\tfor (i = 0, l = srcElements.length; i < l; i++) {\n\t\t\t\t\t\tcloneCopyEvent(srcElements[i], destElements[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent(elem, clone);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll(clone, \"script\");\n\t\t\tif (destElements.length > 0) {\n\t\t\t\tsetGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n\t\t\t}\n\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\n\t\tcleanData: function cleanData(elems) {\n\t\t\tvar data,\n\t\t\t    elem,\n\t\t\t    type,\n\t\t\t    special = jQuery.event.special,\n\t\t\t    i = 0;\n\n\t\t\tfor (; (elem = elems[i]) !== undefined; i++) {\n\t\t\t\tif (acceptData(elem)) {\n\t\t\t\t\tif (data = elem[dataPriv.expando]) {\n\t\t\t\t\t\tif (data.events) {\n\t\t\t\t\t\t\tfor (type in data.events) {\n\t\t\t\t\t\t\t\tif (special[type]) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove(elem, type);\n\n\t\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent(elem, type, data.handle);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[dataPriv.expando] = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif (elem[dataUser.expando]) {\n\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[dataUser.expando] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tdetach: function detach(selector) {\n\t\t\treturn _remove(this, selector, true);\n\t\t},\n\n\t\tremove: function remove(selector) {\n\t\t\treturn _remove(this, selector);\n\t\t},\n\n\t\ttext: function text(value) {\n\t\t\treturn access(this, function (value) {\n\t\t\t\treturn value === undefined ? jQuery.text(this) : this.empty().each(function () {\n\t\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, null, value, arguments.length);\n\t\t},\n\n\t\tappend: function append() {\n\t\t\treturn domManip(this, arguments, function (elem) {\n\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\tvar target = manipulationTarget(this, elem);\n\t\t\t\t\ttarget.appendChild(elem);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tprepend: function prepend() {\n\t\t\treturn domManip(this, arguments, function (elem) {\n\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\tvar target = manipulationTarget(this, elem);\n\t\t\t\t\ttarget.insertBefore(elem, target.firstChild);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tbefore: function before() {\n\t\t\treturn domManip(this, arguments, function (elem) {\n\t\t\t\tif (this.parentNode) {\n\t\t\t\t\tthis.parentNode.insertBefore(elem, this);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tafter: function after() {\n\t\t\treturn domManip(this, arguments, function (elem) {\n\t\t\t\tif (this.parentNode) {\n\t\t\t\t\tthis.parentNode.insertBefore(elem, this.nextSibling);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tempty: function empty() {\n\t\t\tvar elem,\n\t\t\t    i = 0;\n\n\t\t\tfor (; (elem = this[i]) != null; i++) {\n\t\t\t\tif (elem.nodeType === 1) {\n\n\t\t\t\t\t// Prevent memory leaks\n\t\t\t\t\tjQuery.cleanData(getAll(elem, false));\n\n\t\t\t\t\t// Remove any remaining nodes\n\t\t\t\t\telem.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tclone: function clone(dataAndEvents, deepDataAndEvents) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\t\treturn this.map(function () {\n\t\t\t\treturn jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n\t\t\t});\n\t\t},\n\n\t\thtml: function html(value) {\n\t\t\treturn access(this, function (value) {\n\t\t\t\tvar elem = this[0] || {},\n\t\t\t\t    i = 0,\n\t\t\t\t    l = this.length;\n\n\t\t\t\tif (value === undefined && elem.nodeType === 1) {\n\t\t\t\t\treturn elem.innerHTML;\n\t\t\t\t}\n\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n\n\t\t\t\t\tvalue = jQuery.htmlPrefilter(value);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\t\t\telem = this[i] || {};\n\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\t\t\tjQuery.cleanData(getAll(elem, false));\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telem = 0;\n\n\t\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}\n\n\t\t\t\tif (elem) {\n\t\t\t\t\tthis.empty().append(value);\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length);\n\t\t},\n\n\t\treplaceWith: function replaceWith() {\n\t\t\tvar ignored = [];\n\n\t\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\t\treturn domManip(this, arguments, function (elem) {\n\t\t\t\tvar parent = this.parentNode;\n\n\t\t\t\tif (jQuery.inArray(this, ignored) < 0) {\n\t\t\t\t\tjQuery.cleanData(getAll(this));\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tparent.replaceChild(elem, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force callback invocation\n\t\t\t}, ignored);\n\t\t}\n\t});\n\n\tjQuery.each({\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function (name, original) {\n\t\tjQuery.fn[name] = function (selector) {\n\t\t\tvar elems,\n\t\t\t    ret = [],\n\t\t\t    insert = jQuery(selector),\n\t\t\t    last = insert.length - 1,\n\t\t\t    i = 0;\n\n\t\t\tfor (; i <= last; i++) {\n\t\t\t\telems = i === last ? this : this.clone(true);\n\t\t\t\tjQuery(insert[i])[original](elems);\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tpush.apply(ret, elems.get());\n\t\t\t}\n\n\t\t\treturn this.pushStack(ret);\n\t\t};\n\t});\n\tvar rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n\tvar getStyles = function getStyles(elem) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif (!view || !view.opener) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle(elem);\n\t};\n\n\tvar rboxStyle = new RegExp(cssExpand.join(\"|\"), \"i\");\n\n\t(function () {\n\n\t\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t\t// so they're executed at the same time to save the second computation.\n\t\tfunction computeStyleTests() {\n\n\t\t\t// This is a singleton, we need to execute it only once\n\t\t\tif (!div) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" + \"margin-top:1px;padding:0;border:0\";\n\t\t\tdiv.style.cssText = \"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" + \"margin:auto;border:1px;padding:1px;\" + \"width:60%;top:1%\";\n\t\t\tdocumentElement.appendChild(container).appendChild(div);\n\n\t\t\tvar divStyle = window.getComputedStyle(div);\n\t\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\t\treliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;\n\n\t\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\t\tdiv.style.right = \"60%\";\n\t\t\tpixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;\n\n\t\t\t// Support: IE 9 - 11 only\n\t\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\t\tboxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;\n\n\t\t\t// Support: IE 9 only\n\t\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\t\tdiv.style.position = \"absolute\";\n\t\t\tscrollboxSizeVal = div.offsetWidth === 36 || \"absolute\";\n\n\t\t\tdocumentElement.removeChild(container);\n\n\t\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t\t// it will also be a sign that checks already performed\n\t\t\tdiv = null;\n\t\t}\n\n\t\tfunction roundPixelMeasures(measure) {\n\t\t\treturn Math.round(parseFloat(measure));\n\t\t}\n\n\t\tvar pixelPositionVal,\n\t\t    boxSizingReliableVal,\n\t\t    scrollboxSizeVal,\n\t\t    pixelBoxStylesVal,\n\t\t    reliableMarginLeftVal,\n\t\t    container = document.createElement(\"div\"),\n\t\t    div = document.createElement(\"div\");\n\n\t\t// Finish early in limited (non-browser) environments\n\t\tif (!div.style) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// Style of cloned element affects source element cloned (#8908)\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode(true).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t\tjQuery.extend(support, {\n\t\t\tboxSizingReliable: function boxSizingReliable() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\tpixelBoxStyles: function pixelBoxStyles() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelBoxStylesVal;\n\t\t\t},\n\t\t\tpixelPosition: function pixelPosition() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\treliableMarginLeft: function reliableMarginLeft() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn reliableMarginLeftVal;\n\t\t\t},\n\t\t\tscrollboxSize: function scrollboxSize() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn scrollboxSizeVal;\n\t\t\t}\n\t\t});\n\t})();\n\n\tfunction curCSS(elem, name, computed) {\n\t\tvar width,\n\t\t    minWidth,\n\t\t    maxWidth,\n\t\t    ret,\n\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\t\tcomputed = computed || getStyles(elem);\n\n\t\t// getPropertyValue is needed for:\n\t\t//   .css('filter') (IE 9 only, #12537)\n\t\t//   .css('--customProperty) (#3144)\n\t\tif (computed) {\n\t\t\tret = computed.getPropertyValue(name) || computed[name];\n\n\t\t\tif (ret === \"\" && !jQuery.contains(elem.ownerDocument, elem)) {\n\t\t\t\tret = jQuery.style(elem, name);\n\t\t\t}\n\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Android Browser returns percentage for some values,\n\t\t\t// but width seems to be reliably pixels.\n\t\t\t// This is against the CSSOM draft spec:\n\t\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\t\tif (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\n\t\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" : ret;\n\t}\n\n\tfunction addGetHookIf(conditionFn, hookFn) {\n\n\t\t// Define the hook, we'll check on the first run if it's really needed.\n\t\treturn {\n\t\t\tget: function get() {\n\t\t\t\tif (conditionFn()) {\n\n\t\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t\t// to missing dependency), remove it.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\t\treturn (this.get = hookFn).apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}\n\n\tvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t    rcustomProp = /^--/,\n\t    cssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t    cssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\t    cssPrefixes = [\"Webkit\", \"Moz\", \"ms\"],\n\t    emptyStyle = document.createElement(\"div\").style;\n\n\t// Return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName(name) {\n\n\t\t// Shortcut for names that are not vendor prefixed\n\t\tif (name in emptyStyle) {\n\t\t\treturn name;\n\t\t}\n\n\t\t// Check for vendor prefixed names\n\t\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\t    i = cssPrefixes.length;\n\n\t\twhile (i--) {\n\t\t\tname = cssPrefixes[i] + capName;\n\t\t\tif (name in emptyStyle) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return a property mapped along what jQuery.cssProps suggests or to\n\t// a vendor prefixed property.\n\tfunction finalPropName(name) {\n\t\tvar ret = jQuery.cssProps[name];\n\t\tif (!ret) {\n\t\t\tret = jQuery.cssProps[name] = vendorPropName(name) || name;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tfunction setPositiveNumber(elem, value, subtract) {\n\n\t\t// Any relative (+/-) values have already been\n\t\t// normalized at this point\n\t\tvar matches = rcssNum.exec(value);\n\t\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") : value;\n\t}\n\n\tfunction boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\n\t\tvar i = dimension === \"width\" ? 1 : 0,\n\t\t    extra = 0,\n\t\t    delta = 0;\n\n\t\t// Adjustment may not be necessary\n\t\tif (box === (isBorderBox ? \"border\" : \"content\")) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (; i < 4; i += 2) {\n\n\t\t\t// Both box models exclude margin\n\t\t\tif (box === \"margin\") {\n\t\t\t\tdelta += jQuery.css(elem, box + cssExpand[i], true, styles);\n\t\t\t}\n\n\t\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\t\tif (!isBorderBox) {\n\n\t\t\t\t// Add padding\n\t\t\t\tdelta += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n\n\t\t\t\t// For \"border\" or \"margin\", add border\n\t\t\t\tif (box !== \"padding\") {\n\t\t\t\t\tdelta += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n\n\t\t\t\t\t// But still keep track of it otherwise\n\t\t\t\t} else {\n\t\t\t\t\textra += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n\t\t\t\t}\n\n\t\t\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t\t\t// \"padding\" or \"margin\"\n\t\t\t} else {\n\n\t\t\t\t// For \"content\", subtract padding\n\t\t\t\tif (box === \"content\") {\n\t\t\t\t\tdelta -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n\t\t\t\t}\n\n\t\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\t\tif (box !== \"margin\") {\n\t\t\t\t\tdelta -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\t\tif (!isBorderBox && computedVal >= 0) {\n\n\t\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\t\tdelta += Math.max(0, Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));\n\t\t}\n\n\t\treturn delta;\n\t}\n\n\tfunction getWidthOrHeight(elem, dimension, extra) {\n\n\t\t// Start with computed style\n\t\tvar styles = getStyles(elem),\n\t\t    val = curCSS(elem, dimension, styles),\n\t\t    isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n\t\t    valueIsBorderBox = isBorderBox;\n\n\t\t// Support: Firefox <=54\n\t\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\t\tif (rnumnonpx.test(val)) {\n\t\t\tif (!extra) {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t\tval = \"auto\";\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);\n\n\t\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t\t// This happens for inline elements with no explicit setting (gh-3571)\n\t\t// Support: Android <=4.1 - 4.3 only\n\t\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\t\tif (val === \"auto\" || !parseFloat(val) && jQuery.css(elem, \"display\", false, styles) === \"inline\") {\n\n\t\t\tval = elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)];\n\n\t\t\t// offsetWidth/offsetHeight provide border-box values\n\t\t\tvalueIsBorderBox = true;\n\t\t}\n\n\t\t// Normalize \"\" and auto\n\t\tval = parseFloat(val) || 0;\n\n\t\t// Adjust for the element's box model\n\t\treturn val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles,\n\n\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\tval) + \"px\";\n\t}\n\n\tjQuery.extend({\n\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function get(elem, computed) {\n\t\t\t\t\tif (computed) {\n\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS(elem, \"opacity\");\n\t\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Don't automatically add \"px\" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t\"animationIterationCount\": true,\n\t\t\t\"columnCount\": true,\n\t\t\t\"fillOpacity\": true,\n\t\t\t\"flexGrow\": true,\n\t\t\t\"flexShrink\": true,\n\t\t\t\"fontWeight\": true,\n\t\t\t\"lineHeight\": true,\n\t\t\t\"opacity\": true,\n\t\t\t\"order\": true,\n\t\t\t\"orphans\": true,\n\t\t\t\"widows\": true,\n\t\t\t\"zIndex\": true,\n\t\t\t\"zoom\": true\n\t\t},\n\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {},\n\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function style(elem, name, value, extra) {\n\n\t\t\t// Don't set styles on text and comment nodes\n\t\t\tif (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make sure that we're working with the right name\n\t\t\tvar ret,\n\t\t\t    type,\n\t\t\t    hooks,\n\t\t\t    origName = camelCase(name),\n\t\t\t    isCustomProp = rcustomProp.test(name),\n\t\t\t    style = elem.style;\n\n\t\t\t// Make sure that we're working with the right name. We don't\n\t\t\t// want to query the value if it is a CSS custom property\n\t\t\t// since they are user-defined.\n\t\t\tif (!isCustomProp) {\n\t\t\t\tname = finalPropName(origName);\n\t\t\t}\n\n\t\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\t\thooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n\t\t\t// Check if we're setting a value\n\t\t\tif (value !== undefined) {\n\t\t\t\ttype = typeof value === \"undefined\" ? \"undefined\" : _typeof(value);\n\n\t\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\t\tif (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n\t\t\t\t\tvalue = adjustCSS(elem, name, ret);\n\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t}\n\n\t\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\t\tif (value == null || value !== value) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t\tif (type === \"number\") {\n\t\t\t\t\tvalue += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n\t\t\t\t}\n\n\t\t\t\t// background-* props affect original clone's values\n\t\t\t\tif (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n\t\t\t\t\tstyle[name] = \"inherit\";\n\t\t\t\t}\n\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n\n\t\t\t\t\tif (isCustomProp) {\n\t\t\t\t\t\tstyle.setProperty(name, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstyle[name] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[name];\n\t\t\t}\n\t\t},\n\n\t\tcss: function css(elem, name, extra, styles) {\n\t\t\tvar val,\n\t\t\t    num,\n\t\t\t    hooks,\n\t\t\t    origName = camelCase(name),\n\t\t\t    isCustomProp = rcustomProp.test(name);\n\n\t\t\t// Make sure that we're working with the right name. We don't\n\t\t\t// want to modify the value if it is a CSS custom property\n\t\t\t// since they are user-defined.\n\t\t\tif (!isCustomProp) {\n\t\t\t\tname = finalPropName(origName);\n\t\t\t}\n\n\t\t\t// Try prefixed name followed by the unprefixed name\n\t\t\thooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif (hooks && \"get\" in hooks) {\n\t\t\t\tval = hooks.get(elem, true, extra);\n\t\t\t}\n\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif (val === undefined) {\n\t\t\t\tval = curCSS(elem, name, styles);\n\t\t\t}\n\n\t\t\t// Convert \"normal\" to computed value\n\t\t\tif (val === \"normal\" && name in cssNormalTransform) {\n\t\t\t\tval = cssNormalTransform[name];\n\t\t\t}\n\n\t\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\t\tif (extra === \"\" || extra) {\n\t\t\t\tnum = parseFloat(val);\n\t\t\t\treturn extra === true || isFinite(num) ? num || 0 : val;\n\t\t\t}\n\n\t\t\treturn val;\n\t\t}\n\t});\n\n\tjQuery.each([\"height\", \"width\"], function (i, dimension) {\n\t\tjQuery.cssHooks[dimension] = {\n\t\t\tget: function get(elem, computed, extra) {\n\t\t\t\tif (computed) {\n\n\t\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\t\treturn rdisplayswap.test(jQuery.css(elem, \"display\")) && (\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {\n\t\t\t\t\t\treturn getWidthOrHeight(elem, dimension, extra);\n\t\t\t\t\t}) : getWidthOrHeight(elem, dimension, extra);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset: function set(elem, value, extra) {\n\t\t\t\tvar matches,\n\t\t\t\t    styles = getStyles(elem),\n\t\t\t\t    isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n\t\t\t\t    subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);\n\n\t\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\t\tif (isBorderBox && support.scrollboxSize() === styles.position) {\n\t\t\t\t\tsubtract -= Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, \"border\", false, styles) - 0.5);\n\t\t\t\t}\n\n\t\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\t\tif (subtract && (matches = rcssNum.exec(value)) && (matches[3] || \"px\") !== \"px\") {\n\n\t\t\t\t\telem.style[dimension] = value;\n\t\t\t\t\tvalue = jQuery.css(elem, dimension);\n\t\t\t\t}\n\n\t\t\t\treturn setPositiveNumber(elem, value, subtract);\n\t\t\t}\n\t\t};\n\t});\n\n\tjQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n\t\tif (computed) {\n\t\t\treturn (parseFloat(curCSS(elem, \"marginLeft\")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {\n\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t})) + \"px\";\n\t\t}\n\t});\n\n\t// These hooks are used by animate to expand properties\n\tjQuery.each({\n\t\tmargin: \"\",\n\t\tpadding: \"\",\n\t\tborder: \"Width\"\n\t}, function (prefix, suffix) {\n\t\tjQuery.cssHooks[prefix + suffix] = {\n\t\t\texpand: function expand(value) {\n\t\t\t\tvar i = 0,\n\t\t\t\t    expanded = {},\n\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n\t\t\t\tfor (; i < 4; i++) {\n\t\t\t\t\texpanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n\t\t\t\t}\n\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\n\t\tif (prefix !== \"margin\") {\n\t\t\tjQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tcss: function css(name, value) {\n\t\t\treturn access(this, function (elem, name, value) {\n\t\t\t\tvar styles,\n\t\t\t\t    len,\n\t\t\t\t    map = {},\n\t\t\t\t    i = 0;\n\n\t\t\t\tif (Array.isArray(name)) {\n\t\t\t\t\tstyles = getStyles(elem);\n\t\t\t\t\tlen = name.length;\n\n\t\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\t\tmap[name[i]] = jQuery.css(elem, name[i], false, styles);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\n\t\t\t\treturn value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n\t\t\t}, name, value, arguments.length > 1);\n\t\t}\n\t});\n\n\tfunction Tween(elem, options, prop, end, easing) {\n\t\treturn new Tween.prototype.init(elem, options, prop, end, easing);\n\t}\n\tjQuery.Tween = Tween;\n\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function init(elem, options, prop, end, easing, unit) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || jQuery.easing._default;\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n\t\t},\n\t\tcur: function cur() {\n\t\t\tvar hooks = Tween.propHooks[this.prop];\n\n\t\t\treturn hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n\t\t},\n\t\trun: function run(percent) {\n\t\t\tvar eased,\n\t\t\t    hooks = Tween.propHooks[this.prop];\n\n\t\t\tif (this.options.duration) {\n\t\t\t\tthis.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = (this.end - this.start) * eased + this.start;\n\n\t\t\tif (this.options.step) {\n\t\t\t\tthis.options.step.call(this.elem, this.now, this);\n\t\t\t}\n\n\t\t\tif (hooks && hooks.set) {\n\t\t\t\thooks.set(this);\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set(this);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\n\tTween.prototype.init.prototype = Tween.prototype;\n\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function get(tween) {\n\t\t\t\tvar result;\n\n\t\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t\t// or when there is no matching style property that exists.\n\t\t\t\tif (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n\t\t\t\t\treturn tween.elem[tween.prop];\n\t\t\t\t}\n\n\t\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\t\tresult = jQuery.css(tween.elem, tween.prop, \"\");\n\n\t\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t\t},\n\t\t\tset: function set(tween) {\n\n\t\t\t\t// Use step hook for back compat.\n\t\t\t\t// Use cssHook if its there.\n\t\t\t\t// Use .style if available and use plain properties where available.\n\t\t\t\tif (jQuery.fx.step[tween.prop]) {\n\t\t\t\t\tjQuery.fx.step[tween.prop](tween);\n\t\t\t\t} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {\n\t\t\t\t\tjQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[tween.prop] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Support: IE <=9 only\n\t// Panic based approach to setting things on disconnected nodes\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function set(tween) {\n\t\t\tif (tween.elem.nodeType && tween.elem.parentNode) {\n\t\t\t\ttween.elem[tween.prop] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.easing = {\n\t\tlinear: function linear(p) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function swing(p) {\n\t\t\treturn 0.5 - Math.cos(p * Math.PI) / 2;\n\t\t},\n\t\t_default: \"swing\"\n\t};\n\n\tjQuery.fx = Tween.prototype.init;\n\n\t// Back compat <1.8 extension point\n\tjQuery.fx.step = {};\n\n\tvar fxNow,\n\t    inProgress,\n\t    rfxtypes = /^(?:toggle|show|hide)$/,\n\t    rrun = /queueHooks$/;\n\n\tfunction schedule() {\n\t\tif (inProgress) {\n\t\t\tif (document.hidden === false && window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(schedule);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(schedule, jQuery.fx.interval);\n\t\t\t}\n\n\t\t\tjQuery.fx.tick();\n\t\t}\n\t}\n\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\twindow.setTimeout(function () {\n\t\t\tfxNow = undefined;\n\t\t});\n\t\treturn fxNow = Date.now();\n\t}\n\n\t// Generate parameters to create a standard animation\n\tfunction genFx(type, includeWidth) {\n\t\tvar which,\n\t\t    i = 0,\n\t\t    attrs = { height: type };\n\n\t\t// If we include width, step value is 1 to do all cssExpand values,\n\t\t// otherwise step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor (; i < 4; i += 2 - includeWidth) {\n\t\t\twhich = cssExpand[i];\n\t\t\tattrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n\t\t}\n\n\t\tif (includeWidth) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\n\t\treturn attrs;\n\t}\n\n\tfunction createTween(value, prop, animation) {\n\t\tvar tween,\n\t\t    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]),\n\t\t    index = 0,\n\t\t    length = collection.length;\n\t\tfor (; index < length; index++) {\n\t\t\tif (tween = collection[index].call(animation, prop, value)) {\n\n\t\t\t\t// We're done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction defaultPrefilter(elem, props, opts) {\n\t\tvar prop,\n\t\t    value,\n\t\t    toggle,\n\t\t    hooks,\n\t\t    oldfire,\n\t\t    propTween,\n\t\t    restoreDisplay,\n\t\t    display,\n\t\t    isBox = \"width\" in props || \"height\" in props,\n\t\t    anim = this,\n\t\t    orig = {},\n\t\t    style = elem.style,\n\t\t    hidden = elem.nodeType && isHiddenWithinTree(elem),\n\t\t    dataShow = dataPriv.get(elem, \"fxshow\");\n\n\t\t// Queue-skipping animations hijack the fx hooks\n\t\tif (!opts.queue) {\n\t\t\thooks = jQuery._queueHooks(elem, \"fx\");\n\t\t\tif (hooks.unqueued == null) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function () {\n\t\t\t\t\tif (!hooks.unqueued) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\n\t\t\tanim.always(function () {\n\n\t\t\t\t// Ensure the complete handler is called before this completes\n\t\t\t\tanim.always(function () {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif (!jQuery.queue(elem, \"fx\").length) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Detect show/hide animations\n\t\tfor (prop in props) {\n\t\t\tvalue = props[prop];\n\t\t\tif (rfxtypes.test(value)) {\n\t\t\t\tdelete props[prop];\n\t\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\t\tif (value === (hidden ? \"hide\" : \"show\")) {\n\n\t\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\t\tif (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n\t\t\t\t\t\thidden = true;\n\n\t\t\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n\t\t\t}\n\t\t}\n\n\t\t// Bail out if this is a no-op like .hide().hide()\n\t\tpropTween = !jQuery.isEmptyObject(props);\n\t\tif (!propTween && jQuery.isEmptyObject(orig)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Restrict \"overflow\" and \"display\" styles during box animations\n\t\tif (isBox && elem.nodeType === 1) {\n\n\t\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t\t// the overflowX value there.\n\t\t\topts.overflow = [style.overflow, style.overflowX, style.overflowY];\n\n\t\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\t\trestoreDisplay = dataShow && dataShow.display;\n\t\t\tif (restoreDisplay == null) {\n\t\t\t\trestoreDisplay = dataPriv.get(elem, \"display\");\n\t\t\t}\n\t\t\tdisplay = jQuery.css(elem, \"display\");\n\t\t\tif (display === \"none\") {\n\t\t\t\tif (restoreDisplay) {\n\t\t\t\t\tdisplay = restoreDisplay;\n\t\t\t\t} else {\n\n\t\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\t\tshowHide([elem], true);\n\t\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\t\tdisplay = jQuery.css(elem, \"display\");\n\t\t\t\t\tshowHide([elem]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Animate inline elements as inline-block\n\t\t\tif (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\n\t\t\t\tif (jQuery.css(elem, \"float\") === \"none\") {\n\n\t\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\t\tif (!propTween) {\n\t\t\t\t\t\tanim.done(function () {\n\t\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (restoreDisplay == null) {\n\t\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (opts.overflow) {\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tanim.always(function () {\n\t\t\t\tstyle.overflow = opts.overflow[0];\n\t\t\t\tstyle.overflowX = opts.overflow[1];\n\t\t\t\tstyle.overflowY = opts.overflow[2];\n\t\t\t});\n\t\t}\n\n\t\t// Implement show/hide animations\n\t\tpropTween = false;\n\t\tfor (prop in orig) {\n\n\t\t\t// General show/hide setup for this element animation\n\t\t\tif (!propTween) {\n\t\t\t\tif (dataShow) {\n\t\t\t\t\tif (\"hidden\" in dataShow) {\n\t\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdataShow = dataPriv.access(elem, \"fxshow\", { display: restoreDisplay });\n\t\t\t\t}\n\n\t\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\t\tif (toggle) {\n\t\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t\t}\n\n\t\t\t\t// Show elements before animating them\n\t\t\t\tif (hidden) {\n\t\t\t\t\tshowHide([elem], true);\n\t\t\t\t}\n\n\t\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\t\tanim.done(function () {\n\n\t\t\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\t\tif (!hidden) {\n\t\t\t\t\t\tshowHide([elem]);\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.remove(elem, \"fxshow\");\n\t\t\t\t\tfor (prop in orig) {\n\t\t\t\t\t\tjQuery.style(elem, prop, orig[prop]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Per-property setup\n\t\t\tpropTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\t\t\tif (!(prop in dataShow)) {\n\t\t\t\tdataShow[prop] = propTween.start;\n\t\t\t\tif (hidden) {\n\t\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\t\tpropTween.start = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction propFilter(props, specialEasing) {\n\t\tvar index, name, easing, value, hooks;\n\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor (index in props) {\n\t\t\tname = camelCase(index);\n\t\t\teasing = specialEasing[name];\n\t\t\tvalue = props[index];\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\teasing = value[1];\n\t\t\t\tvalue = props[index] = value[0];\n\t\t\t}\n\n\t\t\tif (index !== name) {\n\t\t\t\tprops[name] = value;\n\t\t\t\tdelete props[index];\n\t\t\t}\n\n\t\t\thooks = jQuery.cssHooks[name];\n\t\t\tif (hooks && \"expand\" in hooks) {\n\t\t\t\tvalue = hooks.expand(value);\n\t\t\t\tdelete props[name];\n\n\t\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\t\tfor (index in value) {\n\t\t\t\t\tif (!(index in props)) {\n\t\t\t\t\t\tprops[index] = value[index];\n\t\t\t\t\t\tspecialEasing[index] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[name] = easing;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction Animation(elem, properties, options) {\n\t\tvar result,\n\t\t    stopped,\n\t\t    index = 0,\n\t\t    length = Animation.prefilters.length,\n\t\t    deferred = jQuery.Deferred().always(function () {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\t    tick = function tick() {\n\t\t\tif (stopped) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n\n\n\t\t\t// Support: Android 2.3 only\n\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t    percent = 1 - temp,\n\t\t\t    index = 0,\n\t\t\t    length = animation.tweens.length;\n\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tanimation.tweens[index].run(percent);\n\t\t\t}\n\n\t\t\tdeferred.notifyWith(elem, [animation, percent, remaining]);\n\n\t\t\t// If there's more to do, yield\n\t\t\tif (percent < 1 && length) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif (!length) {\n\t\t\t\tdeferred.notifyWith(elem, [animation, 1, 0]);\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith(elem, [animation]);\n\t\t\treturn false;\n\t\t},\n\t\t    animation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend({}, properties),\n\t\t\topts: jQuery.extend(true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function createTween(prop, end) {\n\t\t\t\tvar tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n\t\t\t\tanimation.tweens.push(tween);\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function stop(gotoEnd) {\n\t\t\t\tvar index = 0,\n\n\n\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t// otherwise we skip this part\n\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif (stopped) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor (; index < length; index++) {\n\t\t\t\t\tanimation.tweens[index].run(1);\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif (gotoEnd) {\n\t\t\t\t\tdeferred.notifyWith(elem, [animation, 1, 0]);\n\t\t\t\t\tdeferred.resolveWith(elem, [animation, gotoEnd]);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith(elem, [animation, gotoEnd]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\t    props = animation.props;\n\n\t\tpropFilter(props, animation.opts.specialEasing);\n\n\t\tfor (; index < length; index++) {\n\t\t\tresult = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n\t\t\tif (result) {\n\t\t\t\tif (isFunction(result.stop)) {\n\t\t\t\t\tjQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tjQuery.map(props, createTween, animation);\n\n\t\tif (isFunction(animation.opts.start)) {\n\t\t\tanimation.opts.start.call(elem, animation);\n\t\t}\n\n\t\t// Attach callbacks from options\n\t\tanimation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n\n\t\tjQuery.fx.timer(jQuery.extend(tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t}));\n\n\t\treturn animation;\n\t}\n\n\tjQuery.Animation = jQuery.extend(Animation, {\n\n\t\ttweeners: {\n\t\t\t\"*\": [function (prop, value) {\n\t\t\t\tvar tween = this.createTween(prop, value);\n\t\t\t\tadjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n\t\t\t\treturn tween;\n\t\t\t}]\n\t\t},\n\n\t\ttweener: function tweener(props, callback) {\n\t\t\tif (isFunction(props)) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = [\"*\"];\n\t\t\t} else {\n\t\t\t\tprops = props.match(rnothtmlwhite);\n\t\t\t}\n\n\t\t\tvar prop,\n\t\t\t    index = 0,\n\t\t\t    length = props.length;\n\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tprop = props[index];\n\t\t\t\tAnimation.tweeners[prop] = Animation.tweeners[prop] || [];\n\t\t\t\tAnimation.tweeners[prop].unshift(callback);\n\t\t\t}\n\t\t},\n\n\t\tprefilters: [defaultPrefilter],\n\n\t\tprefilter: function prefilter(callback, prepend) {\n\t\t\tif (prepend) {\n\t\t\t\tAnimation.prefilters.unshift(callback);\n\t\t\t} else {\n\t\t\t\tAnimation.prefilters.push(callback);\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.speed = function (speed, easing, fn) {\n\t\tvar opt = speed && (typeof speed === \"undefined\" ? \"undefined\" : _typeof(speed)) === \"object\" ? jQuery.extend({}, speed) : {\n\t\t\tcomplete: fn || !fn && easing || isFunction(speed) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !isFunction(easing) && easing\n\t\t};\n\n\t\t// Go to the end state if fx are off\n\t\tif (jQuery.fx.off) {\n\t\t\topt.duration = 0;\n\t\t} else {\n\t\t\tif (typeof opt.duration !== \"number\") {\n\t\t\t\tif (opt.duration in jQuery.fx.speeds) {\n\t\t\t\t\topt.duration = jQuery.fx.speeds[opt.duration];\n\t\t\t\t} else {\n\t\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\t\tif (opt.queue == null || opt.queue === true) {\n\t\t\topt.queue = \"fx\";\n\t\t}\n\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\n\t\topt.complete = function () {\n\t\t\tif (isFunction(opt.old)) {\n\t\t\t\topt.old.call(this);\n\t\t\t}\n\n\t\t\tif (opt.queue) {\n\t\t\t\tjQuery.dequeue(this, opt.queue);\n\t\t\t}\n\t\t};\n\n\t\treturn opt;\n\t};\n\n\tjQuery.fn.extend({\n\t\tfadeTo: function fadeTo(speed, to, easing, callback) {\n\n\t\t\t// Show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter(isHiddenWithinTree).css(\"opacity\", 0).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback);\n\t\t},\n\t\tanimate: function animate(prop, speed, easing, callback) {\n\t\t\tvar empty = jQuery.isEmptyObject(prop),\n\t\t\t    optall = jQuery.speed(speed, easing, callback),\n\t\t\t    doAnimation = function doAnimation() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation(this, jQuery.extend({}, prop), optall);\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif (empty || dataPriv.get(this, \"finish\")) {\n\t\t\t\t\tanim.stop(true);\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\t\treturn empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n\t\t},\n\t\tstop: function stop(type, clearQueue, gotoEnd) {\n\t\t\tvar stopQueue = function stopQueue(hooks) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop(gotoEnd);\n\t\t\t};\n\n\t\t\tif (typeof type !== \"string\") {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif (clearQueue && type !== false) {\n\t\t\t\tthis.queue(type || \"fx\", []);\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t    index = type != null && type + \"queueHooks\",\n\t\t\t\t    timers = jQuery.timers,\n\t\t\t\t    data = dataPriv.get(this);\n\n\t\t\t\tif (index) {\n\t\t\t\t\tif (data[index] && data[index].stop) {\n\t\t\t\t\t\tstopQueue(data[index]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (index in data) {\n\t\t\t\t\t\tif (data[index] && data[index].stop && rrun.test(index)) {\n\t\t\t\t\t\t\tstopQueue(data[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (index = timers.length; index--;) {\n\t\t\t\t\tif (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n\n\t\t\t\t\t\ttimers[index].anim.stop(gotoEnd);\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\t\tif (dequeue || !gotoEnd) {\n\t\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tfinish: function finish(type) {\n\t\t\tif (type !== false) {\n\t\t\t\ttype = type || \"fx\";\n\t\t\t}\n\t\t\treturn this.each(function () {\n\t\t\t\tvar index,\n\t\t\t\t    data = dataPriv.get(this),\n\t\t\t\t    queue = data[type + \"queue\"],\n\t\t\t\t    hooks = data[type + \"queueHooks\"],\n\t\t\t\t    timers = jQuery.timers,\n\t\t\t\t    length = queue ? queue.length : 0;\n\n\t\t\t\t// Enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\n\t\t\t\t// Empty the queue first\n\t\t\t\tjQuery.queue(this, type, []);\n\n\t\t\t\tif (hooks && hooks.stop) {\n\t\t\t\t\thooks.stop.call(this, true);\n\t\t\t\t}\n\n\t\t\t\t// Look for any active animations, and finish them\n\t\t\t\tfor (index = timers.length; index--;) {\n\t\t\t\t\tif (timers[index].elem === this && timers[index].queue === type) {\n\t\t\t\t\t\ttimers[index].anim.stop(true);\n\t\t\t\t\t\ttimers.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Look for any animations in the old queue and finish them\n\t\t\t\tfor (index = 0; index < length; index++) {\n\t\t\t\t\tif (queue[index] && queue[index].finish) {\n\t\t\t\t\t\tqueue[index].finish.call(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\n\t\tvar cssFn = jQuery.fn[name];\n\t\tjQuery.fn[name] = function (speed, easing, callback) {\n\t\t\treturn speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n\t\t};\n\t});\n\n\t// Generate shortcuts for custom animations\n\tjQuery.each({\n\t\tslideDown: genFx(\"show\"),\n\t\tslideUp: genFx(\"hide\"),\n\t\tslideToggle: genFx(\"toggle\"),\n\t\tfadeIn: { opacity: \"show\" },\n\t\tfadeOut: { opacity: \"hide\" },\n\t\tfadeToggle: { opacity: \"toggle\" }\n\t}, function (name, props) {\n\t\tjQuery.fn[name] = function (speed, easing, callback) {\n\t\t\treturn this.animate(props, speed, easing, callback);\n\t\t};\n\t});\n\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function () {\n\t\tvar timer,\n\t\t    i = 0,\n\t\t    timers = jQuery.timers;\n\n\t\tfxNow = Date.now();\n\n\t\tfor (; i < timers.length; i++) {\n\t\t\ttimer = timers[i];\n\n\t\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\t\tif (!timer() && timers[i] === timer) {\n\t\t\t\ttimers.splice(i--, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (!timers.length) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\n\tjQuery.fx.timer = function (timer) {\n\t\tjQuery.timers.push(timer);\n\t\tjQuery.fx.start();\n\t};\n\n\tjQuery.fx.interval = 13;\n\tjQuery.fx.start = function () {\n\t\tif (inProgress) {\n\t\t\treturn;\n\t\t}\n\n\t\tinProgress = true;\n\t\tschedule();\n\t};\n\n\tjQuery.fx.stop = function () {\n\t\tinProgress = null;\n\t};\n\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function (time, type) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue(type, function (next, hooks) {\n\t\t\tvar timeout = window.setTimeout(next, time);\n\t\t\thooks.stop = function () {\n\t\t\t\twindow.clearTimeout(timeout);\n\t\t\t};\n\t\t});\n\t};\n\n\t(function () {\n\t\tvar input = document.createElement(\"input\"),\n\t\t    select = document.createElement(\"select\"),\n\t\t    opt = select.appendChild(document.createElement(\"option\"));\n\n\t\tinput.type = \"checkbox\";\n\n\t\t// Support: Android <=4.3 only\n\t\t// Default value for a checkbox should be \"on\"\n\t\tsupport.checkOn = input.value !== \"\";\n\n\t\t// Support: IE <=11 only\n\t\t// Must access selectedIndex to make default options select\n\t\tsupport.optSelected = opt.selected;\n\n\t\t// Support: IE <=11 only\n\t\t// An input loses its value after becoming a radio\n\t\tinput = document.createElement(\"input\");\n\t\tinput.value = \"t\";\n\t\tinput.type = \"radio\";\n\t\tsupport.radioValue = input.value === \"t\";\n\t})();\n\n\tvar boolHook,\n\t    attrHandle = jQuery.expr.attrHandle;\n\n\tjQuery.fn.extend({\n\t\tattr: function attr(name, value) {\n\t\t\treturn access(this, jQuery.attr, name, value, arguments.length > 1);\n\t\t},\n\n\t\tremoveAttr: function removeAttr(name) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.removeAttr(this, name);\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tattr: function attr(elem, name, value) {\n\t\t\tvar ret,\n\t\t\t    hooks,\n\t\t\t    nType = elem.nodeType;\n\n\t\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\t\tif (nType === 3 || nType === 8 || nType === 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif (typeof elem.getAttribute === \"undefined\") {\n\t\t\t\treturn jQuery.prop(elem, name, value);\n\t\t\t}\n\n\t\t\t// Attribute hooks are determined by the lowercase version\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n\t\t\t\thooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n\t\t\t}\n\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (value === null) {\n\t\t\t\t\tjQuery.removeAttr(elem, name);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\telem.setAttribute(name, value + \"\");\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = jQuery.find.attr(elem, name);\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ? undefined : ret;\n\t\t},\n\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function set(elem, value) {\n\t\t\t\t\tif (!support.radioValue && value === \"radio\" && nodeName(elem, \"input\")) {\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute(\"type\", value);\n\t\t\t\t\t\tif (val) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tremoveAttr: function removeAttr(elem, value) {\n\t\t\tvar name,\n\t\t\t    i = 0,\n\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match(rnothtmlwhite);\n\n\t\t\tif (attrNames && elem.nodeType === 1) {\n\t\t\t\twhile (name = attrNames[i++]) {\n\t\t\t\t\telem.removeAttribute(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Hooks for boolean attributes\n\tboolHook = {\n\t\tset: function set(elem, value, name) {\n\t\t\tif (value === false) {\n\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr(elem, name);\n\t\t\t} else {\n\t\t\t\telem.setAttribute(name, name);\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t};\n\n\tjQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n\t\tvar getter = attrHandle[name] || jQuery.find.attr;\n\n\t\tattrHandle[name] = function (elem, name, isXML) {\n\t\t\tvar ret,\n\t\t\t    handle,\n\t\t\t    lowercaseName = name.toLowerCase();\n\n\t\t\tif (!isXML) {\n\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[lowercaseName];\n\t\t\t\tattrHandle[lowercaseName] = ret;\n\t\t\t\tret = getter(elem, name, isXML) != null ? lowercaseName : null;\n\t\t\t\tattrHandle[lowercaseName] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t});\n\n\tvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\t    rclickable = /^(?:a|area)$/i;\n\n\tjQuery.fn.extend({\n\t\tprop: function prop(name, value) {\n\t\t\treturn access(this, jQuery.prop, name, value, arguments.length > 1);\n\t\t},\n\n\t\tremoveProp: function removeProp(name) {\n\t\t\treturn this.each(function () {\n\t\t\t\tdelete this[jQuery.propFix[name] || name];\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tprop: function prop(elem, name, value) {\n\t\t\tvar ret,\n\t\t\t    hooks,\n\t\t\t    nType = elem.nodeType;\n\n\t\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\t\tif (nType === 3 || nType === 8 || nType === 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[name] || name;\n\t\t\t\thooks = jQuery.propHooks[name];\n\t\t\t}\n\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\treturn elem[name] = value;\n\t\t\t}\n\n\t\t\tif (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn elem[name];\n\t\t},\n\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function get(elem) {\n\n\t\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\t\tvar tabindex = jQuery.find.attr(elem, \"tabindex\");\n\n\t\t\t\t\tif (tabindex) {\n\t\t\t\t\t\treturn parseInt(tabindex, 10);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tpropFix: {\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\"class\": \"className\"\n\t\t}\n\t});\n\n\t// Support: IE <=11 only\n\t// Accessing the selectedIndex property\n\t// forces the browser to respect setting selected\n\t// on the option\n\t// The getter ensures a default option is selected\n\t// when in an optgroup\n\t// eslint rule \"no-unused-expressions\" is disabled for this code\n\t// since it considers such accessions noop\n\tif (!support.optSelected) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function get(elem) {\n\n\t\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif (parent && parent.parentNode) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tset: function set(elem) {\n\n\t\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif (parent) {\n\t\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t\tif (parent.parentNode) {\n\t\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tjQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n\t\tjQuery.propFix[this.toLowerCase()] = this;\n\t});\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse(value) {\n\t\tvar tokens = value.match(rnothtmlwhite) || [];\n\t\treturn tokens.join(\" \");\n\t}\n\n\tfunction getClass(elem) {\n\t\treturn elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n\t}\n\n\tfunction classesToArray(value) {\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tif (typeof value === \"string\") {\n\t\t\treturn value.match(rnothtmlwhite) || [];\n\t\t}\n\t\treturn [];\n\t}\n\n\tjQuery.fn.extend({\n\t\taddClass: function addClass(value) {\n\t\t\tvar classes,\n\t\t\t    elem,\n\t\t\t    cur,\n\t\t\t    curValue,\n\t\t\t    clazz,\n\t\t\t    j,\n\t\t\t    finalValue,\n\t\t\t    i = 0;\n\n\t\t\tif (isFunction(value)) {\n\t\t\t\treturn this.each(function (j) {\n\t\t\t\t\tjQuery(this).addClass(value.call(this, j, getClass(this)));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tclasses = classesToArray(value);\n\n\t\t\tif (classes.length) {\n\t\t\t\twhile (elem = this[i++]) {\n\t\t\t\t\tcurValue = getClass(elem);\n\t\t\t\t\tcur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n\t\t\t\t\tif (cur) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile (clazz = classes[j++]) {\n\t\t\t\t\t\t\tif (cur.indexOf(\" \" + clazz + \" \") < 0) {\n\t\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse(cur);\n\t\t\t\t\t\tif (curValue !== finalValue) {\n\t\t\t\t\t\t\telem.setAttribute(\"class\", finalValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tremoveClass: function removeClass(value) {\n\t\t\tvar classes,\n\t\t\t    elem,\n\t\t\t    cur,\n\t\t\t    curValue,\n\t\t\t    clazz,\n\t\t\t    j,\n\t\t\t    finalValue,\n\t\t\t    i = 0;\n\n\t\t\tif (isFunction(value)) {\n\t\t\t\treturn this.each(function (j) {\n\t\t\t\t\tjQuery(this).removeClass(value.call(this, j, getClass(this)));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!arguments.length) {\n\t\t\t\treturn this.attr(\"class\", \"\");\n\t\t\t}\n\n\t\t\tclasses = classesToArray(value);\n\n\t\t\tif (classes.length) {\n\t\t\t\twhile (elem = this[i++]) {\n\t\t\t\t\tcurValue = getClass(elem);\n\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n\t\t\t\t\tif (cur) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile (clazz = classes[j++]) {\n\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile (cur.indexOf(\" \" + clazz + \" \") > -1) {\n\t\t\t\t\t\t\t\tcur = cur.replace(\" \" + clazz + \" \", \" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse(cur);\n\t\t\t\t\t\tif (curValue !== finalValue) {\n\t\t\t\t\t\t\telem.setAttribute(\"class\", finalValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\ttoggleClass: function toggleClass(value, stateVal) {\n\t\t\tvar type = typeof value === \"undefined\" ? \"undefined\" : _typeof(value),\n\t\t\t    isValidValue = type === \"string\" || Array.isArray(value);\n\n\t\t\tif (typeof stateVal === \"boolean\" && isValidValue) {\n\t\t\t\treturn stateVal ? this.addClass(value) : this.removeClass(value);\n\t\t\t}\n\n\t\t\tif (isFunction(value)) {\n\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\tjQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar className, i, self, classNames;\n\n\t\t\t\tif (isValidValue) {\n\n\t\t\t\t\t// Toggle individual class names\n\t\t\t\t\ti = 0;\n\t\t\t\t\tself = jQuery(this);\n\t\t\t\t\tclassNames = classesToArray(value);\n\n\t\t\t\t\twhile (className = classNames[i++]) {\n\n\t\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\t\tif (self.hasClass(className)) {\n\t\t\t\t\t\t\tself.removeClass(className);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass(className);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if (value === undefined || type === \"boolean\") {\n\t\t\t\t\tclassName = getClass(this);\n\t\t\t\t\tif (className) {\n\n\t\t\t\t\t\t// Store className if set\n\t\t\t\t\t\tdataPriv.set(this, \"__className__\", className);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tif (this.setAttribute) {\n\t\t\t\t\t\tthis.setAttribute(\"class\", className || value === false ? \"\" : dataPriv.get(this, \"__className__\") || \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thasClass: function hasClass(selector) {\n\t\t\tvar className,\n\t\t\t    elem,\n\t\t\t    i = 0;\n\n\t\t\tclassName = \" \" + selector + \" \";\n\t\t\twhile (elem = this[i++]) {\n\t\t\t\tif (elem.nodeType === 1 && (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t});\n\n\tvar rreturn = /\\r/g;\n\n\tjQuery.fn.extend({\n\t\tval: function val(value) {\n\t\t\tvar hooks,\n\t\t\t    ret,\n\t\t\t    valueIsFunction,\n\t\t\t    elem = this[0];\n\n\t\t\tif (!arguments.length) {\n\t\t\t\tif (elem) {\n\t\t\t\t\thooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n\t\t\t\t\tif (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = elem.value;\n\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tif (typeof ret === \"string\") {\n\t\t\t\t\t\treturn ret.replace(rreturn, \"\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalueIsFunction = isFunction(value);\n\n\t\t\treturn this.each(function (i) {\n\t\t\t\tvar val;\n\n\t\t\t\tif (this.nodeType !== 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (valueIsFunction) {\n\t\t\t\t\tval = value.call(this, i, jQuery(this).val());\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\n\t\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\t\tif (val == null) {\n\t\t\t\t\tval = \"\";\n\t\t\t\t} else if (typeof val === \"number\") {\n\t\t\t\t\tval += \"\";\n\t\t\t\t} else if (Array.isArray(val)) {\n\t\t\t\t\tval = jQuery.map(val, function (value) {\n\t\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\thooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\n\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function get(elem) {\n\n\t\t\t\t\tvar val = jQuery.find.attr(elem, \"value\");\n\t\t\t\t\treturn val != null ? val :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse(jQuery.text(elem));\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function get(elem) {\n\t\t\t\t\tvar value,\n\t\t\t\t\t    option,\n\t\t\t\t\t    i,\n\t\t\t\t\t    options = elem.options,\n\t\t\t\t\t    index = elem.selectedIndex,\n\t\t\t\t\t    one = elem.type === \"select-one\",\n\t\t\t\t\t    values = one ? null : [],\n\t\t\t\t\t    max = one ? index + 1 : options.length;\n\n\t\t\t\t\tif (index < 0) {\n\t\t\t\t\t\ti = max;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor (; i < max; i++) {\n\t\t\t\t\t\toption = options[i];\n\n\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\t\tif ((option.selected || i === index) &&\n\n\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t!option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, \"optgroup\"))) {\n\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery(option).val();\n\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif (one) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\n\t\t\t\tset: function set(elem, value) {\n\t\t\t\t\tvar optionSet,\n\t\t\t\t\t    option,\n\t\t\t\t\t    options = elem.options,\n\t\t\t\t\t    values = jQuery.makeArray(value),\n\t\t\t\t\t    i = options.length;\n\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\toption = options[i];\n\n\t\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\t\tif (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n\t\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t\t}\n\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif (!optionSet) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Radios and checkboxes getter/setter\n\tjQuery.each([\"radio\", \"checkbox\"], function () {\n\t\tjQuery.valHooks[this] = {\n\t\t\tset: function set(elem, value) {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\treturn elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (!support.checkOn) {\n\t\t\tjQuery.valHooks[this].get = function (elem) {\n\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t\t};\n\t\t}\n\t});\n\n\t// Return jQuery for attributes-only inclusion\n\n\n\tsupport.focusin = \"onfocusin\" in window;\n\n\tvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\t    stopPropagationCallback = function stopPropagationCallback(e) {\n\t\te.stopPropagation();\n\t};\n\n\tjQuery.extend(jQuery.event, {\n\n\t\ttrigger: function trigger(event, data, elem, onlyHandlers) {\n\n\t\t\tvar i,\n\t\t\t    cur,\n\t\t\t    tmp,\n\t\t\t    bubbleType,\n\t\t\t    ontype,\n\t\t\t    handle,\n\t\t\t    special,\n\t\t\t    lastElement,\n\t\t\t    eventPath = [elem || document],\n\t\t\t    type = hasOwn.call(event, \"type\") ? event.type : event,\n\t\t\t    namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n\n\t\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t\t// Don't do events on text and comment nodes\n\t\t\tif (elem.nodeType === 3 || elem.nodeType === 8) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\t\tif (rfocusMorph.test(type + jQuery.event.triggered)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (type.indexOf(\".\") > -1) {\n\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split(\".\");\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === \"undefined\" ? \"undefined\" : _typeof(event)) === \"object\" && event);\n\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join(\".\");\n\t\t\tevent.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null;\n\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif (!event.target) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ? [event] : jQuery.makeArray(data, [event]);\n\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[type] || {};\n\t\t\tif (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\n\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif (!rfocusMorph.test(bubbleType + type)) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor (; cur; cur = cur.parentNode) {\n\t\t\t\t\teventPath.push(cur);\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif (tmp === (elem.ownerDocument || document)) {\n\t\t\t\t\teventPath.push(tmp.defaultView || tmp.parentWindow || window);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n\t\t\t\tlastElement = cur;\n\t\t\t\tevent.type = i > 1 ? bubbleType : special.bindType || type;\n\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = (dataPriv.get(cur, \"events\") || {})[event.type] && dataPriv.get(cur, \"handle\");\n\t\t\t\tif (handle) {\n\t\t\t\t\thandle.apply(cur, data);\n\t\t\t\t}\n\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ontype];\n\t\t\t\tif (handle && handle.apply && acceptData(cur)) {\n\t\t\t\t\tevent.result = handle.apply(cur, data);\n\t\t\t\t\tif (event.result === false) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif (!onlyHandlers && !event.isDefaultPrevented()) {\n\n\t\t\t\tif ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n\n\t\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t\tif (ontype && isFunction(elem[type]) && !isWindow(elem)) {\n\n\t\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ontype];\n\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\telem[ontype] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\t\tif (event.isPropagationStopped()) {\n\t\t\t\t\t\t\tlastElement.addEventListener(type, stopPropagationCallback);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telem[type]();\n\n\t\t\t\t\t\tif (event.isPropagationStopped()) {\n\t\t\t\t\t\t\tlastElement.removeEventListener(type, stopPropagationCallback);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\telem[ontype] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\t// Piggyback on a donor event to simulate a different one\n\t\t// Used only for `focus(in | out)` events\n\t\tsimulate: function simulate(type, elem, event) {\n\t\t\tvar e = jQuery.extend(new jQuery.Event(), event, {\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t});\n\n\t\t\tjQuery.event.trigger(e, null, elem);\n\t\t}\n\n\t});\n\n\tjQuery.fn.extend({\n\n\t\ttrigger: function trigger(type, data) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.event.trigger(type, data, this);\n\t\t\t});\n\t\t},\n\t\ttriggerHandler: function triggerHandler(type, data) {\n\t\t\tvar elem = this[0];\n\t\t\tif (elem) {\n\t\t\t\treturn jQuery.event.trigger(type, data, elem, true);\n\t\t\t}\n\t\t}\n\t});\n\n\t// Support: Firefox <=44\n\t// Firefox doesn't have focus(in | out) events\n\t// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n\t//\n\t// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n\t// focus(in | out) events fire after focus & blur events,\n\t// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n\t// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\tif (!support.focusin) {\n\t\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function (orig, fix) {\n\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function handler(event) {\n\t\t\t\tjQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n\t\t\t};\n\n\t\t\tjQuery.event.special[fix] = {\n\t\t\t\tsetup: function setup() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t    attaches = dataPriv.access(doc, fix);\n\n\t\t\t\t\tif (!attaches) {\n\t\t\t\t\t\tdoc.addEventListener(orig, handler, true);\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.access(doc, fix, (attaches || 0) + 1);\n\t\t\t\t},\n\t\t\t\tteardown: function teardown() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t    attaches = dataPriv.access(doc, fix) - 1;\n\n\t\t\t\t\tif (!attaches) {\n\t\t\t\t\t\tdoc.removeEventListener(orig, handler, true);\n\t\t\t\t\t\tdataPriv.remove(doc, fix);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataPriv.access(doc, fix, attaches);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\tvar location = window.location;\n\n\tvar nonce = Date.now();\n\n\tvar rquery = /\\?/;\n\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function (data) {\n\t\tvar xml;\n\t\tif (!data || typeof data !== \"string\") {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only\n\t\t// IE throws on parseFromString with invalid input.\n\t\ttry {\n\t\t\txml = new window.DOMParser().parseFromString(data, \"text/xml\");\n\t\t} catch (e) {\n\t\t\txml = undefined;\n\t\t}\n\n\t\tif (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n\t\t\tjQuery.error(\"Invalid XML: \" + data);\n\t\t}\n\t\treturn xml;\n\t};\n\n\tvar rbracket = /\\[\\]$/,\n\t    rCRLF = /\\r?\\n/g,\n\t    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t    rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n\tfunction buildParams(prefix, obj, traditional, add) {\n\t\tvar name;\n\n\t\tif (Array.isArray(obj)) {\n\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each(obj, function (i, v) {\n\t\t\t\tif (traditional || rbracket.test(prefix)) {\n\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd(prefix, v);\n\t\t\t\t} else {\n\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams(prefix + \"[\" + ((typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (!traditional && toType(obj) === \"object\") {\n\n\t\t\t// Serialize object item.\n\t\t\tfor (name in obj) {\n\t\t\t\tbuildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Serialize scalar item.\n\t\t\tadd(prefix, obj);\n\t\t}\n\t}\n\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function (a, traditional) {\n\t\tvar prefix,\n\t\t    s = [],\n\t\t    add = function add(key, valueOrFunction) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n\n\t\t\ts[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value == null ? \"\" : value);\n\t\t};\n\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each(a, function () {\n\t\t\t\tadd(this.name, this.value);\n\t\t\t});\n\t\t} else {\n\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor (prefix in a) {\n\t\t\t\tbuildParams(prefix, a[prefix], traditional, add);\n\t\t\t}\n\t\t}\n\n\t\t// Return the resulting serialization\n\t\treturn s.join(\"&\");\n\t};\n\n\tjQuery.fn.extend({\n\t\tserialize: function serialize() {\n\t\t\treturn jQuery.param(this.serializeArray());\n\t\t},\n\t\tserializeArray: function serializeArray() {\n\t\t\treturn this.map(function () {\n\n\t\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop(this, \"elements\");\n\t\t\t\treturn elements ? jQuery.makeArray(elements) : this;\n\t\t\t}).filter(function () {\n\t\t\t\tvar type = this.type;\n\n\t\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n\t\t\t}).map(function (i, elem) {\n\t\t\t\tvar val = jQuery(this).val();\n\n\t\t\t\tif (val == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\treturn jQuery.map(val, function (val) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace(rCRLF, \"\\r\\n\") };\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn { name: elem.name, value: val.replace(rCRLF, \"\\r\\n\") };\n\t\t\t}).get();\n\t\t}\n\t});\n\n\tvar r20 = /%20/g,\n\t    rhash = /#.*$/,\n\t    rantiCache = /([?&])_=[^&]*/,\n\t    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t    rnoContent = /^(?:GET|HEAD)$/,\n\t    rprotocol = /^\\/\\//,\n\n\n\t/* Prefilters\n  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n  * 2) These are called:\n  *    - BEFORE asking for a transport\n  *    - AFTER param serialization (s.data is a string if s.processData is true)\n  * 3) key is the dataType\n  * 4) the catchall symbol \"*\" can be used\n  * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n  */\n\tprefilters = {},\n\n\n\t/* Transports bindings\n  * 1) key is the dataType\n  * 2) the catchall symbol \"*\" can be used\n  * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n  */\n\ttransports = {},\n\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\"),\n\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement(\"a\");\n\toriginAnchor.href = location.href;\n\n\t// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports(structure) {\n\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function (dataTypeExpression, func) {\n\n\t\t\tif (typeof dataTypeExpression !== \"string\") {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\n\t\t\tvar dataType,\n\t\t\t    i = 0,\n\t\t\t    dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n\n\t\t\tif (isFunction(func)) {\n\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile (dataType = dataTypes[i++]) {\n\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif (dataType[0] === \"+\") {\n\t\t\t\t\t\tdataType = dataType.slice(1) || \"*\";\n\t\t\t\t\t\t(structure[dataType] = structure[dataType] || []).unshift(func);\n\n\t\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(structure[dataType] = structure[dataType] || []).push(func);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n\n\t\tvar inspected = {},\n\t\t    seekingTransport = structure === transports;\n\n\t\tfunction inspect(dataType) {\n\t\t\tvar selected;\n\t\t\tinspected[dataType] = true;\n\t\t\tjQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\t\t\t\tif (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n\n\t\t\t\t\toptions.dataTypes.unshift(dataTypeOrTransport);\n\t\t\t\t\tinspect(dataTypeOrTransport);\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (seekingTransport) {\n\t\t\t\t\treturn !(selected = dataTypeOrTransport);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn selected;\n\t\t}\n\n\t\treturn inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n\t}\n\n\t// A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend(target, src) {\n\t\tvar key,\n\t\t    deep,\n\t\t    flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\t\tfor (key in src) {\n\t\t\tif (src[key] !== undefined) {\n\t\t\t\t(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n\t\t\t}\n\t\t}\n\t\tif (deep) {\n\t\t\tjQuery.extend(true, target, deep);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/* Handles responses to an ajax request:\n  * - finds the right dataType (mediates between content-type and expected dataType)\n  * - returns the corresponding response\n  */\n\tfunction ajaxHandleResponses(s, jqXHR, responses) {\n\n\t\tvar ct,\n\t\t    type,\n\t\t    finalDataType,\n\t\t    firstDataType,\n\t\t    contents = s.contents,\n\t\t    dataTypes = s.dataTypes;\n\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile (dataTypes[0] === \"*\") {\n\t\t\tdataTypes.shift();\n\t\t\tif (ct === undefined) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t\t}\n\t\t}\n\n\t\t// Check if we're dealing with a known content-type\n\t\tif (ct) {\n\t\t\tfor (type in contents) {\n\t\t\t\tif (contents[type] && contents[type].test(ct)) {\n\t\t\t\t\tdataTypes.unshift(type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif (dataTypes[0] in responses) {\n\t\t\tfinalDataType = dataTypes[0];\n\t\t} else {\n\n\t\t\t// Try convertible dataTypes\n\t\t\tfor (type in responses) {\n\t\t\t\tif (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!firstDataType) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif (finalDataType) {\n\t\t\tif (finalDataType !== dataTypes[0]) {\n\t\t\t\tdataTypes.unshift(finalDataType);\n\t\t\t}\n\t\t\treturn responses[finalDataType];\n\t\t}\n\t}\n\n\t/* Chain conversions given the request and the original response\n  * Also sets the responseXXX fields on the jqXHR instance\n  */\n\tfunction ajaxConvert(s, response, jqXHR, isSuccess) {\n\t\tvar conv2,\n\t\t    current,\n\t\t    conv,\n\t\t    tmp,\n\t\t    prev,\n\t\t    converters = {},\n\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t\t// Create converters map with lowercased keys\n\t\tif (dataTypes[1]) {\n\t\t\tfor (conv in s.converters) {\n\t\t\t\tconverters[conv.toLowerCase()] = s.converters[conv];\n\t\t\t}\n\t\t}\n\n\t\tcurrent = dataTypes.shift();\n\n\t\t// Convert to each sequential dataType\n\t\twhile (current) {\n\n\t\t\tif (s.responseFields[current]) {\n\t\t\t\tjqXHR[s.responseFields[current]] = response;\n\t\t\t}\n\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif (!prev && isSuccess && s.dataFilter) {\n\t\t\t\tresponse = s.dataFilter(response, s.dataType);\n\t\t\t}\n\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\n\t\t\tif (current) {\n\n\t\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif (current === \"*\") {\n\n\t\t\t\t\tcurrent = prev;\n\n\t\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if (prev !== \"*\" && prev !== current) {\n\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[prev + \" \" + current] || converters[\"* \" + current];\n\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif (!conv) {\n\t\t\t\t\t\tfor (conv2 in converters) {\n\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split(\" \");\n\t\t\t\t\t\t\tif (tmp[1] === current) {\n\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\t\t\t\t\t\t\t\tif (conv) {\n\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif (conv === true) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[conv2];\n\n\t\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if (converters[conv2] !== true) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[0];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift(tmp[1]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif (conv !== true) {\n\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif (conv && s.throws) {\n\t\t\t\t\t\t\tresponse = conv(response);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv(response);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { state: \"success\", data: response };\n\t}\n\n\tjQuery.extend({\n\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\n\t\tajaxSettings: {\n\t\t\turl: location.href,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test(location.protocol),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t\t/*\n   timeout: 0,\n   data: null,\n   dataType: null,\n   username: null,\n   password: null,\n   cache: null,\n   throws: false,\n   traditional: false,\n   headers: {},\n   */\n\n\t\t\taccepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\n\t\t\tcontents: {\n\t\t\t\txml: /\\bxml\\b/,\n\t\t\t\thtml: /\\bhtml/,\n\t\t\t\tjson: /\\bjson\\b/\n\t\t\t},\n\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": JSON.parse,\n\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function ajaxSetup(target, settings) {\n\t\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend(jQuery.ajaxSettings, target);\n\t\t},\n\n\t\tajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n\t\tajaxTransport: addToPrefiltersOrTransports(transports),\n\n\t\t// Main method\n\t\tajax: function ajax(url, options) {\n\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ((typeof url === \"undefined\" ? \"undefined\" : _typeof(url)) === \"object\") {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\n\t\t\tvar transport,\n\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\t    responseHeaders,\n\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup({}, options),\n\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t    completeDeferred = jQuery.Callbacks(\"once memory\"),\n\n\n\t\t\t// Status-dependent callbacks\n\t\t\t_statusCode = s.statusCode || {},\n\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\t    requestHeadersNames = {},\n\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function getResponseHeader(key) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif (completed) {\n\t\t\t\t\t\tif (!responseHeaders) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile (match = rheaders.exec(responseHeadersString)) {\n\t\t\t\t\t\t\t\tresponseHeaders[match[1].toLowerCase()] = match[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[key.toLowerCase()];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function getAllResponseHeaders() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function setRequestHeader(name, value) {\n\t\t\t\t\tif (completed == null) {\n\t\t\t\t\t\tname = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n\t\t\t\t\t\trequestHeaders[name] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function overrideMimeType(type) {\n\t\t\t\t\tif (completed == null) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function statusCode(map) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif (map) {\n\t\t\t\t\t\tif (completed) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always(map[jqXHR.status]);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor (code in map) {\n\t\t\t\t\t\t\t\t_statusCode[code] = [_statusCode[code], map[code]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function abort(statusText) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif (transport) {\n\t\t\t\t\t\ttransport.abort(finalText);\n\t\t\t\t\t}\n\t\t\t\t\tdone(0, finalText);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise(jqXHR);\n\n\t\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ((url || s.url || location.href) + \"\").replace(rprotocol, location.protocol + \"//\");\n\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\"\"];\n\n\t\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\t\tif (s.crossDomain == null) {\n\t\t\t\turlAnchor = document.createElement(\"a\");\n\n\t\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t\t// e.g. http://example.com:80x/\n\t\t\t\ttry {\n\t\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !== urlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\t\ts.crossDomain = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert data if not already a string\n\t\t\tif (s.data && s.processData && typeof s.data !== \"string\") {\n\t\t\t\ts.data = jQuery.param(s.data, s.traditional);\n\t\t\t}\n\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\n\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif (completed) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// We can fire global events as of now if asked to\n\t\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t\t// Watch for a new set of requests\n\t\t\tif (fireGlobals && jQuery.active++ === 0) {\n\t\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t\t}\n\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test(s.type);\n\n\t\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\t// Remove hash to simplify url manipulation\n\t\t\tcacheURL = s.url.replace(rhash, \"\");\n\n\t\t\t// More options handling for requests with no content\n\t\t\tif (!s.hasContent) {\n\n\t\t\t\t// Remember the hash so we can put it back\n\t\t\t\tuncached = s.url.slice(cacheURL.length);\n\n\t\t\t\t// If data is available and should be processed, append data to url\n\t\t\t\tif (s.data && (s.processData || typeof s.data === \"string\")) {\n\t\t\t\t\tcacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data;\n\n\t\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\n\t\t\t\t// Add or update anti-cache param if needed\n\t\t\t\tif (s.cache === false) {\n\t\t\t\t\tcacheURL = cacheURL.replace(rantiCache, \"$1\");\n\t\t\t\t\tuncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce++ + uncached;\n\t\t\t\t}\n\n\t\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\t\ts.url = cacheURL + uncached;\n\n\t\t\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t\t} else if (s.data && s.processData && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n\t\t\t\ts.data = s.data.replace(r20, \"+\");\n\t\t\t}\n\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif (s.ifModified) {\n\t\t\t\tif (jQuery.lastModified[cacheURL]) {\n\t\t\t\t\tjqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n\t\t\t\t}\n\t\t\t\tif (jQuery.etag[cacheURL]) {\n\t\t\t\t\tjqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n\t\t\t\tjqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n\t\t\t}\n\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]);\n\n\t\t\t// Check for headers option\n\t\t\tfor (i in s.headers) {\n\t\t\t\tjqXHR.setRequestHeader(i, s.headers[i]);\n\t\t\t}\n\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\n\t\t\t// Aborting is no longer a cancellation\n\t\t\tstrAbort = \"abort\";\n\n\t\t\t// Install callbacks on deferreds\n\t\t\tcompleteDeferred.add(s.complete);\n\t\t\tjqXHR.done(s.success);\n\t\t\tjqXHR.fail(s.error);\n\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\n\n\t\t\t// If no transport, we auto-abort\n\t\t\tif (!transport) {\n\t\t\t\tdone(-1, \"No Transport\");\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\n\t\t\t\t// Send global event\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n\t\t\t\t}\n\n\t\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\t\tif (completed) {\n\t\t\t\t\treturn jqXHR;\n\t\t\t\t}\n\n\t\t\t\t// Timeout\n\t\t\t\tif (s.async && s.timeout > 0) {\n\t\t\t\t\ttimeoutTimer = window.setTimeout(function () {\n\t\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t\t}, s.timeout);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tcompleted = false;\n\t\t\t\t\ttransport.send(requestHeaders, done);\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\t\tif (completed) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Propagate others as results\n\t\t\t\t\tdone(-1, e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done(status, nativeStatusText, responses, headers) {\n\t\t\t\tvar isSuccess,\n\t\t\t\t    success,\n\t\t\t\t    error,\n\t\t\t\t    response,\n\t\t\t\t    modified,\n\t\t\t\t    statusText = nativeStatusText;\n\n\t\t\t\t// Ignore repeat invocations\n\t\t\t\tif (completed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcompleted = true;\n\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif (timeoutTimer) {\n\t\t\t\t\twindow.clearTimeout(timeoutTimer);\n\t\t\t\t}\n\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t\t// Get response data\n\t\t\t\tif (responses) {\n\t\t\t\t\tresponse = ajaxHandleResponses(s, jqXHR, responses);\n\t\t\t\t}\n\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert(s, response, jqXHR, isSuccess);\n\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif (isSuccess) {\n\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif (s.ifModified) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\tjQuery.lastModified[cacheURL] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\tjQuery.etag[cacheURL] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if no content\n\t\t\t\t\tif (status === 204 || s.type === \"HEAD\") {\n\t\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if (status === 304) {\n\t\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t\t\t// If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif (status || !statusText) {\n\t\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\t\tif (status < 0) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = (nativeStatusText || statusText) + \"\";\n\n\t\t\t\t// Success/Error\n\t\t\t\tif (isSuccess) {\n\t\t\t\t\tdeferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n\t\t\t\t}\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode(_statusCode);\n\t\t\t\t_statusCode = undefined;\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n\t\t\t\t}\n\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]);\n\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif (! --jQuery.active) {\n\t\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn jqXHR;\n\t\t},\n\n\t\tgetJSON: function getJSON(url, data, callback) {\n\t\t\treturn jQuery.get(url, data, callback, \"json\");\n\t\t},\n\n\t\tgetScript: function getScript(url, callback) {\n\t\t\treturn jQuery.get(url, undefined, callback, \"script\");\n\t\t}\n\t});\n\n\tjQuery.each([\"get\", \"post\"], function (i, method) {\n\t\tjQuery[method] = function (url, data, callback, type) {\n\n\t\t\t// Shift arguments if data argument was omitted\n\t\t\tif (isFunction(data)) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\n\t\t\t// The url can be an options object (which then must have .url)\n\t\t\treturn jQuery.ajax(jQuery.extend({\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t}, jQuery.isPlainObject(url) && url));\n\t\t};\n\t});\n\n\tjQuery._evalUrl = function (url) {\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tcache: true,\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t});\n\t};\n\n\tjQuery.fn.extend({\n\t\twrapAll: function wrapAll(html) {\n\t\t\tvar wrap;\n\n\t\t\tif (this[0]) {\n\t\t\t\tif (isFunction(html)) {\n\t\t\t\t\thtml = html.call(this[0]);\n\t\t\t\t}\n\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\twrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n\t\t\t\tif (this[0].parentNode) {\n\t\t\t\t\twrap.insertBefore(this[0]);\n\t\t\t\t}\n\n\t\t\t\twrap.map(function () {\n\t\t\t\t\tvar elem = this;\n\n\t\t\t\t\twhile (elem.firstElementChild) {\n\t\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem;\n\t\t\t\t}).append(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\twrapInner: function wrapInner(html) {\n\t\t\tif (isFunction(html)) {\n\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\tjQuery(this).wrapInner(html.call(this, i));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar self = jQuery(this),\n\t\t\t\t    contents = self.contents();\n\n\t\t\t\tif (contents.length) {\n\t\t\t\t\tcontents.wrapAll(html);\n\t\t\t\t} else {\n\t\t\t\t\tself.append(html);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\twrap: function wrap(html) {\n\t\t\tvar htmlIsFunction = isFunction(html);\n\n\t\t\treturn this.each(function (i) {\n\t\t\t\tjQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\n\t\t\t});\n\t\t},\n\n\t\tunwrap: function unwrap(selector) {\n\t\t\tthis.parent(selector).not(\"body\").each(function () {\n\t\t\t\tjQuery(this).replaceWith(this.childNodes);\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t});\n\n\tjQuery.expr.pseudos.hidden = function (elem) {\n\t\treturn !jQuery.expr.pseudos.visible(elem);\n\t};\n\tjQuery.expr.pseudos.visible = function (elem) {\n\t\treturn !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n\t};\n\n\tjQuery.ajaxSettings.xhr = function () {\n\t\ttry {\n\t\t\treturn new window.XMLHttpRequest();\n\t\t} catch (e) {}\n\t};\n\n\tvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\t    xhrSupported = jQuery.ajaxSettings.xhr();\n\n\tsupport.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n\tsupport.ajax = xhrSupported = !!xhrSupported;\n\n\tjQuery.ajaxTransport(function (options) {\n\t\tvar _callback, errorCallback;\n\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif (support.cors || xhrSupported && !options.crossDomain) {\n\t\t\treturn {\n\t\t\t\tsend: function send(headers, complete) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t    xhr = options.xhr();\n\n\t\t\t\t\txhr.open(options.type, options.url, options.async, options.username, options.password);\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif (options.xhrFields) {\n\t\t\t\t\t\tfor (i in options.xhrFields) {\n\t\t\t\t\t\t\txhr[i] = options.xhrFields[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif (options.mimeType && xhr.overrideMimeType) {\n\t\t\t\t\t\txhr.overrideMimeType(options.mimeType);\n\t\t\t\t\t}\n\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor (i in headers) {\n\t\t\t\t\t\txhr.setRequestHeader(i, headers[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Callback\n\t\t\t\t\t_callback = function callback(type) {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t\t\t_callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\t\tif (type === \"abort\") {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t} else if (type === \"error\") {\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\t\tif (typeof xhr.status !== \"number\") {\n\t\t\t\t\t\t\t\t\t\tcomplete(0, \"error\");\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status, xhr.statusText);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t(xhr.responseType || \"text\") !== \"text\" || typeof xhr.responseText !== \"string\" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\t// Listen to events\n\t\t\t\t\txhr.onload = _callback();\n\t\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = _callback(\"error\");\n\n\t\t\t\t\t// Support: IE 9 only\n\t\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t\t// to handle uncaught aborts\n\t\t\t\t\tif (xhr.onabort !== undefined) {\n\t\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr.onreadystatechange = function () {\n\n\t\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\t\tif (xhr.readyState === 4) {\n\n\t\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\t\twindow.setTimeout(function () {\n\t\t\t\t\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create the abort callback\n\t\t\t\t\t_callback = _callback(\"abort\");\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\t\txhr.send(options.hasContent && options.data || null);\n\t\t\t\t\t} catch (e) {\n\n\t\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function abort() {\n\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t_callback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\n\t// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\tjQuery.ajaxPrefilter(function (s) {\n\t\tif (s.crossDomain) {\n\t\t\ts.contents.script = false;\n\t\t}\n\t});\n\n\t// Install script dataType\n\tjQuery.ajaxSetup({\n\t\taccepts: {\n\t\t\tscript: \"text/javascript, application/javascript, \" + \"application/ecmascript, application/x-ecmascript\"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /\\b(?:java|ecma)script\\b/\n\t\t},\n\t\tconverters: {\n\t\t\t\"text script\": function textScript(text) {\n\t\t\t\tjQuery.globalEval(text);\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Handle cache's special case and crossDomain\n\tjQuery.ajaxPrefilter(\"script\", function (s) {\n\t\tif (s.cache === undefined) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif (s.crossDomain) {\n\t\t\ts.type = \"GET\";\n\t\t}\n\t});\n\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport(\"script\", function (s) {\n\n\t\t// This transport only deals with cross domain requests\n\t\tif (s.crossDomain) {\n\t\t\tvar script, _callback2;\n\t\t\treturn {\n\t\t\t\tsend: function send(_, complete) {\n\t\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\t\tsrc: s.url\n\t\t\t\t\t}).on(\"load error\", _callback2 = function callback(evt) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\t_callback2 = null;\n\t\t\t\t\t\tif (evt) {\n\t\t\t\t\t\t\tcomplete(evt.type === \"error\" ? 404 : 200, evt.type);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\t\tdocument.head.appendChild(script[0]);\n\t\t\t\t},\n\t\t\t\tabort: function abort() {\n\t\t\t\t\tif (_callback2) {\n\t\t\t\t\t\t_callback2();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\n\tvar oldCallbacks = [],\n\t    rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n\t// Default jsonp settings\n\tjQuery.ajaxSetup({\n\t\tjsonp: \"callback\",\n\t\tjsonpCallback: function jsonpCallback() {\n\t\t\tvar callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce++;\n\t\t\tthis[callback] = true;\n\t\t\treturn callback;\n\t\t}\n\t});\n\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n\n\t\tvar callbackName,\n\t\t    overwritten,\n\t\t    responseContainer,\n\t\t    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0 && rjsonp.test(s.data) && \"data\");\n\n\t\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\t\tif (jsonProp || s.dataTypes[0] === \"jsonp\") {\n\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;\n\n\t\t\t// Insert callback into url or form data\n\t\t\tif (jsonProp) {\n\t\t\t\ts[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n\t\t\t} else if (s.jsonp !== false) {\n\t\t\t\ts.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n\t\t\t}\n\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters[\"script json\"] = function () {\n\t\t\t\tif (!responseContainer) {\n\t\t\t\t\tjQuery.error(callbackName + \" was not called\");\n\t\t\t\t}\n\t\t\t\treturn responseContainer[0];\n\t\t\t};\n\n\t\t\t// Force json dataType\n\t\t\ts.dataTypes[0] = \"json\";\n\n\t\t\t// Install callback\n\t\t\toverwritten = window[callbackName];\n\t\t\twindow[callbackName] = function () {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always(function () {\n\n\t\t\t\t// If previous value didn't exist - remove it\n\t\t\t\tif (overwritten === undefined) {\n\t\t\t\t\tjQuery(window).removeProp(callbackName);\n\n\t\t\t\t\t// Otherwise restore preexisting value\n\t\t\t\t} else {\n\t\t\t\t\twindow[callbackName] = overwritten;\n\t\t\t\t}\n\n\t\t\t\t// Save back as free\n\t\t\t\tif (s[callbackName]) {\n\n\t\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t\t// Save the callback name for future use\n\t\t\t\t\toldCallbacks.push(callbackName);\n\t\t\t\t}\n\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif (responseContainer && isFunction(overwritten)) {\n\t\t\t\t\toverwritten(responseContainer[0]);\n\t\t\t\t}\n\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t});\n\n\t\t\t// Delegate to script\n\t\t\treturn \"script\";\n\t\t}\n\t});\n\n\t// Support: Safari 8 only\n\t// In Safari 8 documents created via document.implementation.createHTMLDocument\n\t// collapse sibling forms: the second one becomes a child of the first one.\n\t// Because of that, this security measure has to be disabled in Safari 8.\n\t// https://bugs.webkit.org/show_bug.cgi?id=137337\n\tsupport.createHTMLDocument = function () {\n\t\tvar body = document.implementation.createHTMLDocument(\"\").body;\n\t\tbody.innerHTML = \"<form></form><form></form>\";\n\t\treturn body.childNodes.length === 2;\n\t}();\n\n\t// Argument \"data\" should be string of html\n\t// context (optional): If specified, the fragment will be created in this context,\n\t// defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function (data, context, keepScripts) {\n\t\tif (typeof data !== \"string\") {\n\t\t\treturn [];\n\t\t}\n\t\tif (typeof context === \"boolean\") {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\n\t\tvar base, parsed, scripts;\n\n\t\tif (!context) {\n\n\t\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t\t// by using document.implementation\n\t\t\tif (support.createHTMLDocument) {\n\t\t\t\tcontext = document.implementation.createHTMLDocument(\"\");\n\n\t\t\t\t// Set the base href for the created document\n\t\t\t\t// so any parsed elements with URLs\n\t\t\t\t// are based on the document's URL (gh-2965)\n\t\t\t\tbase = context.createElement(\"base\");\n\t\t\t\tbase.href = document.location.href;\n\t\t\t\tcontext.head.appendChild(base);\n\t\t\t} else {\n\t\t\t\tcontext = document;\n\t\t\t}\n\t\t}\n\n\t\tparsed = rsingleTag.exec(data);\n\t\tscripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif (parsed) {\n\t\t\treturn [context.createElement(parsed[1])];\n\t\t}\n\n\t\tparsed = buildFragment([data], context, scripts);\n\n\t\tif (scripts && scripts.length) {\n\t\t\tjQuery(scripts).remove();\n\t\t}\n\n\t\treturn jQuery.merge([], parsed.childNodes);\n\t};\n\n\t/**\n  * Load a url into a page\n  */\n\tjQuery.fn.load = function (url, params, callback) {\n\t\tvar selector,\n\t\t    type,\n\t\t    response,\n\t\t    self = this,\n\t\t    off = url.indexOf(\" \");\n\n\t\tif (off > -1) {\n\t\t\tselector = stripAndCollapse(url.slice(off));\n\t\t\turl = url.slice(0, off);\n\t\t}\n\n\t\t// If it's a function\n\t\tif (isFunction(params)) {\n\n\t\t\t// We assume that it's the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\n\t\t\t// Otherwise, build a param string\n\t\t} else if (params && (typeof params === \"undefined\" ? \"undefined\" : _typeof(params)) === \"object\") {\n\t\t\ttype = \"POST\";\n\t\t}\n\n\t\t// If we have elements to modify, make the request\n\t\tif (self.length > 0) {\n\t\t\tjQuery.ajax({\n\t\t\t\turl: url,\n\n\t\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t\t// Make value of this field explicit since\n\t\t\t\t// user can override it through ajaxSetup method\n\t\t\t\ttype: type || \"GET\",\n\t\t\t\tdataType: \"html\",\n\t\t\t\tdata: params\n\t\t\t}).done(function (responseText) {\n\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\n\t\t\t\tself.html(selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText);\n\n\t\t\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t\t\t// but they are ignored because response was set above.\n\t\t\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t\t}).always(callback && function (jqXHR, status) {\n\t\t\t\tself.each(function () {\n\t\t\t\t\tcallback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (i, type) {\n\t\tjQuery.fn[type] = function (fn) {\n\t\t\treturn this.on(type, fn);\n\t\t};\n\t});\n\n\tjQuery.expr.pseudos.animated = function (elem) {\n\t\treturn jQuery.grep(jQuery.timers, function (fn) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n\n\tjQuery.offset = {\n\t\tsetOffset: function setOffset(elem, options, i) {\n\t\t\tvar curPosition,\n\t\t\t    curLeft,\n\t\t\t    curCSSTop,\n\t\t\t    curTop,\n\t\t\t    curOffset,\n\t\t\t    curCSSLeft,\n\t\t\t    calculatePosition,\n\t\t\t    position = jQuery.css(elem, \"position\"),\n\t\t\t    curElem = jQuery(elem),\n\t\t\t    props = {};\n\n\t\t\t// Set position first, in-case top/left are set even on static elem\n\t\t\tif (position === \"static\") {\n\t\t\t\telem.style.position = \"relative\";\n\t\t\t}\n\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css(elem, \"top\");\n\t\t\tcurCSSLeft = jQuery.css(elem, \"left\");\n\t\t\tcalculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1;\n\n\t\t\t// Need to be able to calculate position if either\n\t\t\t// top or left is auto and position is either absolute or fixed\n\t\t\tif (calculatePosition) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat(curCSSTop) || 0;\n\t\t\t\tcurLeft = parseFloat(curCSSLeft) || 0;\n\t\t\t}\n\n\t\t\tif (isFunction(options)) {\n\n\t\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\t\toptions = options.call(elem, i, jQuery.extend({}, curOffset));\n\t\t\t}\n\n\t\t\tif (options.top != null) {\n\t\t\t\tprops.top = options.top - curOffset.top + curTop;\n\t\t\t}\n\t\t\tif (options.left != null) {\n\t\t\t\tprops.left = options.left - curOffset.left + curLeft;\n\t\t\t}\n\n\t\t\tif (\"using\" in options) {\n\t\t\t\toptions.using.call(elem, props);\n\t\t\t} else {\n\t\t\t\tcurElem.css(props);\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.fn.extend({\n\n\t\t// offset() relates an element's border box to the document origin\n\t\toffset: function offset(options) {\n\n\t\t\t// Preserve chaining for setter\n\t\t\tif (arguments.length) {\n\t\t\t\treturn options === undefined ? this : this.each(function (i) {\n\t\t\t\t\tjQuery.offset.setOffset(this, options, i);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar rect,\n\t\t\t    win,\n\t\t\t    elem = this[0];\n\n\t\t\tif (!elem) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t\t// Support: IE <=11 only\n\t\t\t// Running getBoundingClientRect on a\n\t\t\t// disconnected node in IE throws an error\n\t\t\tif (!elem.getClientRects().length) {\n\t\t\t\treturn { top: 0, left: 0 };\n\t\t\t}\n\n\t\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\t\trect = elem.getBoundingClientRect();\n\t\t\twin = elem.ownerDocument.defaultView;\n\t\t\treturn {\n\t\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\t\tleft: rect.left + win.pageXOffset\n\t\t\t};\n\t\t},\n\n\t\t// position() relates an element's margin box to its offset parent's padding box\n\t\t// This corresponds to the behavior of CSS absolute positioning\n\t\tposition: function position() {\n\t\t\tif (!this[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar offsetParent,\n\t\t\t    offset,\n\t\t\t    doc,\n\t\t\t    elem = this[0],\n\t\t\t    parentOffset = { top: 0, left: 0 };\n\n\t\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\t\tif (jQuery.css(elem, \"position\") === \"fixed\") {\n\n\t\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\t\toffset = elem.getBoundingClientRect();\n\t\t\t} else {\n\t\t\t\toffset = this.offset();\n\n\t\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t\t// when a statically positioned element is identified\n\t\t\t\tdoc = elem.ownerDocument;\n\t\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\t\twhile (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, \"position\") === \"static\") {\n\n\t\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t\t}\n\t\t\t\tif (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n\n\t\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\t\tparentOffset = jQuery(offsetParent).offset();\n\t\t\t\t\tparentOffset.top += jQuery.css(offsetParent, \"borderTopWidth\", true);\n\t\t\t\t\tparentOffset.left += jQuery.css(offsetParent, \"borderLeftWidth\", true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Subtract parent offsets and element margins\n\t\t\treturn {\n\t\t\t\ttop: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n\t\t\t};\n\t\t},\n\n\t\t// This method will return documentElement in the following cases:\n\t\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t\t//    documentElement of the parent window\n\t\t// 2) For the hidden or detached element\n\t\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t\t//\n\t\t// but those exceptions were never presented as a real life use-cases\n\t\t// and might be considered as more preferable results.\n\t\t//\n\t\t// This logic, however, is not guaranteed and can change at any point in the future\n\t\toffsetParent: function offsetParent() {\n\t\t\treturn this.map(function () {\n\t\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\t\twhile (offsetParent && jQuery.css(offsetParent, \"position\") === \"static\") {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\n\t\t\t\treturn offsetParent || documentElement;\n\t\t\t});\n\t\t}\n\t});\n\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (method, prop) {\n\t\tvar top = \"pageYOffset\" === prop;\n\n\t\tjQuery.fn[method] = function (val) {\n\t\t\treturn access(this, function (elem, method, val) {\n\n\t\t\t\t// Coalesce documents and windows\n\t\t\t\tvar win;\n\t\t\t\tif (isWindow(elem)) {\n\t\t\t\t\twin = elem;\n\t\t\t\t} else if (elem.nodeType === 9) {\n\t\t\t\t\twin = elem.defaultView;\n\t\t\t\t}\n\n\t\t\t\tif (val === undefined) {\n\t\t\t\t\treturn win ? win[prop] : elem[method];\n\t\t\t\t}\n\n\t\t\t\tif (win) {\n\t\t\t\t\twin.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n\t\t\t\t} else {\n\t\t\t\t\telem[method] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length);\n\t\t};\n\t});\n\n\t// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n\t// getComputedStyle returns percent when specified for top/left/bottom/right;\n\t// rather than make the css module depend on the offset module, just check for it here\n\tjQuery.each([\"top\", \"left\"], function (i, prop) {\n\t\tjQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n\t\t\tif (computed) {\n\t\t\t\tcomputed = curCSS(elem, prop);\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n\t\t\t}\n\t\t});\n\t});\n\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each({ Height: \"height\", Width: \"width\" }, function (name, type) {\n\t\tjQuery.each({ padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function (defaultExtra, funcName) {\n\n\t\t\t// Margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[funcName] = function (margin, value) {\n\t\t\t\tvar chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n\t\t\t\t    extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n\n\t\t\t\treturn access(this, function (elem, type, value) {\n\t\t\t\t\tvar doc;\n\n\t\t\t\t\tif (isWindow(elem)) {\n\n\t\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\t\treturn funcName.indexOf(\"outer\") === 0 ? elem[\"inner\" + name] : elem.document.documentElement[\"client\" + name];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif (elem.nodeType === 9) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t\t// whichever is greatest\n\t\t\t\t\t\treturn Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css(elem, type, extra) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style(elem, type, value, extra);\n\t\t\t\t}, type, chainable ? margin : undefined, chainable);\n\t\t\t};\n\t\t});\n\t});\n\n\tjQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function (i, name) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[name] = function (data, fn) {\n\t\t\treturn arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n\t\t};\n\t});\n\n\tjQuery.fn.extend({\n\t\thover: function hover(fnOver, fnOut) {\n\t\t\treturn this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\n\t\tbind: function bind(types, data, fn) {\n\t\t\treturn this.on(types, null, data, fn);\n\t\t},\n\t\tunbind: function unbind(types, fn) {\n\t\t\treturn this.off(types, null, fn);\n\t\t},\n\n\t\tdelegate: function delegate(selector, types, data, fn) {\n\t\t\treturn this.on(types, selector, data, fn);\n\t\t},\n\t\tundelegate: function undelegate(selector, types, fn) {\n\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n\t\t}\n\t});\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\t// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n\t// However, it is not slated for removal any time soon\n\tjQuery.proxy = function (fn, context) {\n\t\tvar tmp, args, proxy;\n\n\t\tif (typeof context === \"string\") {\n\t\t\ttmp = fn[context];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif (!isFunction(fn)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = _slice.call(arguments, 2);\n\t\tproxy = function proxy() {\n\t\t\treturn fn.apply(context || this, args.concat(_slice.call(arguments)));\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t};\n\n\tjQuery.holdReady = function (hold) {\n\t\tif (hold) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready(true);\n\t\t}\n\t};\n\tjQuery.isArray = Array.isArray;\n\tjQuery.parseJSON = JSON.parse;\n\tjQuery.nodeName = nodeName;\n\tjQuery.isFunction = isFunction;\n\tjQuery.isWindow = isWindow;\n\tjQuery.camelCase = camelCase;\n\tjQuery.type = toType;\n\n\tjQuery.now = Date.now;\n\n\tjQuery.isNumeric = function (obj) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type(obj);\n\t\treturn (type === \"number\" || type === \"string\") &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN(obj - parseFloat(obj));\n\t};\n\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\n\t// Note that for maximum portability, libraries that are not jQuery should\n\t// declare themselves as anonymous modules, and avoid setting a global if an\n\t// AMD loader is present. jQuery is a special case. For more information, see\n\t// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn jQuery;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\n\tvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\n\tjQuery.noConflict = function (deep) {\n\t\tif (window.$ === jQuery) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif (deep && window.jQuery === jQuery) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t};\n\n\t// Expose jQuery and $ identifiers, even in AMD\n\t// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif (!noGlobal) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\n\treturn jQuery;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/jquery/dist/jquery.js?");

/***/ }),

/***/ "./node_modules/magnifier/index.es5.js":
/*!*********************************************!*\
  !*** ./node_modules/magnifier/index.es5.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}(); /* global document */\n\nvar _globalOffset = __webpack_require__(/*! global-offset */ \"./node_modules/global-offset/index.es5.js\");\n\nvar _globalOffset2 = _interopRequireDefault(_globalOffset);\n\nvar _insertAfter = __webpack_require__(/*! insert-after */ \"./node_modules/insert-after/index.es5.js\");\n\nvar _insertAfter2 = _interopRequireDefault(_insertAfter);\n\nvar _isPointerInside = __webpack_require__(/*! is-pointer-inside */ \"./node_modules/is-pointer-inside/index.es5.js\");\n\nvar _isPointerInside2 = _interopRequireDefault(_isPointerInside);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Magnifier = function () {\n  function Magnifier(el) {\n    var _this = this;\n\n    _classCallCheck(this, Magnifier);\n\n    this.props = {\n      height: 150,\n      width: 150,\n      backgroundColor: '#fff',\n      borderColor: '#eee',\n      borderRadius: 75,\n      borderWidth: 2\n    };\n\n    this.el = typeof el === 'string' ? document.querySelector(el) : el;\n    this.lens = document.createElement('div');\n    this.lens.className = 'magnifier';\n    this.lens.style.position = 'absolute';\n    this.lens.style.backgroundRepeat = 'no-repeat';\n    this.lens.style.borderStyle = 'solid';\n    this.lens.style.overflow = 'hidden';\n    this.lens.style.visibility = 'hidden';\n    this.lens.style.boxShadow = '0 1px 5px rgba(0, 0, 0, .25)';\n    this.handleLoad = this.handleLoad.bind(this);\n    this.handleTouchMove = this.handleTouchMove.bind(this);\n    this.handleTouchEnd = this.handleTouchEnd.bind(this);\n    Object.keys(this.props).forEach(function (prop) {\n      return _this.setStyle(prop, _this.props[prop]);\n    });\n    (0, _insertAfter2.default)(this.lens, this.el);\n    this.show();\n    this.calcImageSize();\n    this.bind();\n  }\n\n  _createClass(Magnifier, [{\n    key: 'calcImageSize',\n    value: function calcImageSize() {\n      var orig = document.createElement('img');\n      orig.style.position = 'absolute';\n      orig.style.width = 'auto';\n      orig.style.visibility = 'hidden';\n      orig.src = this.el.src;\n      orig.onload = this.handleLoad;\n      this.lens.appendChild(orig);\n    }\n  }, {\n    key: 'bind',\n    value: function bind() {\n      this.el.addEventListener('mousemove', this.handleTouchMove, false);\n      this.el.addEventListener('mouseleave', this.handleTouchEnd, false);\n      this.el.addEventListener('touchstart', this.handleTouchMove, false);\n      this.el.addEventListener('touchmove', this.handleTouchMove, false);\n      this.el.addEventListener('touchend', this.handleTouchEnd, false);\n      this.lens.addEventListener('mousemove', this.handleTouchMove, false);\n      this.lens.addEventListener('mouseleave', this.handleTouchEnd, false);\n      this.lens.addEventListener('touchmove', this.handleTouchMove, false);\n      this.lens.addEventListener('touchend', this.handleTouchEnd, false);\n      return this;\n    }\n  }, {\n    key: 'unbind',\n    value: function unbind() {\n      this.el.removeEventListener('mousemove', this.handleTouchMove, false);\n      this.el.removeEventListener('mouseleave', this.handleTouchEnd, false);\n      this.el.removeEventListener('touchstart', this.handleTouchMove, false);\n      this.el.removeEventListener('touchmove', this.handleTouchMove, false);\n      this.el.removeEventListener('touchend', this.handleTouchEnd, false);\n      this.lens.removeEventListener('mousemove', this.handleTouchMove, false);\n      this.lens.removeEventListener('mouseleave', this.handleTouchEnd, false);\n      this.lens.removeEventListener('touchmove', this.handleTouchMove, false);\n      this.lens.removeEventListener('touchend', this.handleTouchEnd, false);\n      return this;\n    }\n  }, {\n    key: 'handleLoad',\n    value: function handleLoad() {\n      var orig = this.lens.getElementsByTagName('img')[0];\n      this.imageWidth = orig.offsetWidth;\n      this.imageHeight = orig.offsetHeight;\n      this.hide();\n      this.lens.style.visibility = 'visible';\n      this.lens.style.backgroundImage = 'url(' + this.el.src + ')';\n      this.lens.removeChild(orig);\n    }\n  }, {\n    key: 'handleTouchMove',\n    value: function handleTouchMove(event) {\n      event.preventDefault();\n      var touch = event.type.indexOf('touch') === 0 ? event.changedTouches[0] : event;\n\n      if ((0, _isPointerInside2.default)(this.el, touch)) {\n        this.show();\n        var pageX = touch.pageX,\n            pageY = touch.pageY;\n\n        var _offset = (0, _globalOffset2.default)(this.el),\n            left = _offset.left,\n            top = _offset.top;\n\n        var _el = this.el,\n            offsetLeft = _el.offsetLeft,\n            offsetTop = _el.offsetTop,\n            offsetWidth = _el.offsetWidth,\n            offsetHeight = _el.offsetHeight;\n        var _props = this.props,\n            width = _props.width,\n            height = _props.height,\n            borderWidth = _props.borderWidth;\n\n        var ratioX = this.imageWidth / offsetWidth;\n        var ratioY = this.imageHeight / offsetHeight;\n        var imageX = (left - pageX) * ratioX + (width / 2 - borderWidth);\n        var imageY = (top - pageY) * ratioY + (height / 2 - borderWidth);\n        var x = pageX - width / 2 - (left !== offsetLeft ? left - offsetLeft : 0);\n        var y = pageY - height / 2 - (top !== offsetTop ? top - offsetTop : 0);\n        this.lens.style.left = x + 'px';\n        this.lens.style.top = y + 'px';\n        this.lens.style.backgroundPosition = imageX + 'px ' + imageY + 'px';\n      } else {\n        this.hide();\n      }\n    }\n  }, {\n    key: 'handleTouchEnd',\n    value: function handleTouchEnd() {\n      this.hide();\n    }\n  }, {\n    key: 'height',\n    value: function height(n) {\n      return this.setProp('height', n);\n    }\n  }, {\n    key: 'width',\n    value: function width(n) {\n      return this.setProp('width', n);\n    }\n  }, {\n    key: 'backgroundColor',\n    value: function backgroundColor(color) {\n      return this.setProp('backgroundColor', color);\n    }\n  }, {\n    key: 'borderColor',\n    value: function borderColor(color) {\n      return this.setProp('borderColor', color);\n    }\n  }, {\n    key: 'borderRadius',\n    value: function borderRadius(n) {\n      return this.setProp('borderRadius', n);\n    }\n  }, {\n    key: 'borderWidth',\n    value: function borderWidth(n) {\n      return this.setProp('borderWidth', n);\n    }\n  }, {\n    key: 'setProp',\n    value: function setProp(prop, value) {\n      this.props[prop] = value;\n      this.setStyle(prop, value);\n      return this;\n    }\n  }, {\n    key: 'setStyle',\n    value: function setStyle(prop, value) {\n      this.lens.style[prop] = typeof value === 'number' ? value + 'px' : value;\n    }\n  }, {\n    key: 'className',\n    value: function className(name) {\n      this.lens.className = name;\n      return this;\n    }\n  }, {\n    key: 'show',\n    value: function show() {\n      this.lens.style.display = 'block';\n      return this;\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      this.lens.style.display = 'none';\n      return this;\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.unbind();\n      this.lens.remove();\n    }\n  }]);\n\n  return Magnifier;\n}();\n\nexports.default = Magnifier;\nmodule.exports = exports['default'];\n\n//# sourceURL=webpack:///./node_modules/magnifier/index.es5.js?");

/***/ }),

/***/ "./node_modules/pubsub-js/src/pubsub.js":
/*!**********************************************!*\
  !*** ./node_modules/pubsub-js/src/pubsub.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Copyright (c) 2010,2011,2012,2013,2014 Morgan Roderick http://roderick.dk\n * License: MIT - http://mrgnrdrck.mit-license.org\n *\n * https://github.com/mroderick/PubSubJS\n */\n\n(function (root, factory) {\n    'use strict';\n\n    var PubSub = {};\n    root.PubSub = PubSub;\n\n    var define = root.define;\n\n    factory(PubSub);\n\n    // AMD support\n    if (typeof define === 'function' && define.amd) {\n        define(function () {\n            return PubSub;\n        });\n\n        // CommonJS and Node.js module support\n    } else if (( false ? undefined : _typeof(exports)) === 'object') {\n        if (module !== undefined && module.exports) {\n            exports = module.exports = PubSub; // Node.js specific `module.exports`\n        }\n        exports.PubSub = PubSub; // CommonJS module 1.1.1 spec\n        module.exports = exports = PubSub; // CommonJS\n    }\n})((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window || undefined, function (PubSub) {\n    'use strict';\n\n    var messages = {},\n        lastUid = -1;\n\n    function hasKeys(obj) {\n        var key;\n\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns a function that throws the passed exception, for use as argument for setTimeout\n     * @alias throwException\n     * @function\n     * @param { Object } ex An Error object\n     */\n    function throwException(ex) {\n        return function reThrowException() {\n            throw ex;\n        };\n    }\n\n    function callSubscriberWithDelayedExceptions(subscriber, message, data) {\n        try {\n            subscriber(message, data);\n        } catch (ex) {\n            setTimeout(throwException(ex), 0);\n        }\n    }\n\n    function callSubscriberWithImmediateExceptions(subscriber, message, data) {\n        subscriber(message, data);\n    }\n\n    function deliverMessage(originalMessage, matchedMessage, data, immediateExceptions) {\n        var subscribers = messages[matchedMessage],\n            callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions,\n            s;\n\n        if (!messages.hasOwnProperty(matchedMessage)) {\n            return;\n        }\n\n        for (s in subscribers) {\n            if (subscribers.hasOwnProperty(s)) {\n                callSubscriber(subscribers[s], originalMessage, data);\n            }\n        }\n    }\n\n    function createDeliveryFunction(message, data, immediateExceptions) {\n        return function deliverNamespaced() {\n            var topic = String(message),\n                position = topic.lastIndexOf('.');\n\n            // deliver the message as it is now\n            deliverMessage(message, message, data, immediateExceptions);\n\n            // trim the hierarchy and deliver message to each level\n            while (position !== -1) {\n                topic = topic.substr(0, position);\n                position = topic.lastIndexOf('.');\n                deliverMessage(message, topic, data, immediateExceptions);\n            }\n        };\n    }\n\n    function messageHasSubscribers(message) {\n        var topic = String(message),\n            found = Boolean(messages.hasOwnProperty(topic) && hasKeys(messages[topic])),\n            position = topic.lastIndexOf('.');\n\n        while (!found && position !== -1) {\n            topic = topic.substr(0, position);\n            position = topic.lastIndexOf('.');\n            found = Boolean(messages.hasOwnProperty(topic) && hasKeys(messages[topic]));\n        }\n\n        return found;\n    }\n\n    function publish(message, data, sync, immediateExceptions) {\n        var deliver = createDeliveryFunction(message, data, immediateExceptions),\n            hasSubscribers = messageHasSubscribers(message);\n\n        if (!hasSubscribers) {\n            return false;\n        }\n\n        if (sync === true) {\n            deliver();\n        } else {\n            setTimeout(deliver, 0);\n        }\n        return true;\n    }\n\n    /**\n     * Publishes the message, passing the data to it's subscribers\n     * @function\n     * @alias publish\n     * @param { String } message The message to publish\n     * @param {} data The data to pass to subscribers\n     * @return { Boolean }\n     */\n    PubSub.publish = function (message, data) {\n        return publish(message, data, false, PubSub.immediateExceptions);\n    };\n\n    /**\n     * Publishes the the message synchronously, passing the data to it's subscribers\n     * @function\n     * @alias publishSync\n     * @param { String } message The message to publish\n     * @param {} data The data to pass to subscribers\n     * @return { Boolean }\n     */\n    PubSub.publishSync = function (message, data) {\n        return publish(message, data, true, PubSub.immediateExceptions);\n    };\n\n    /**\n     * Subscribes the passed function to the passed message. Every returned token is unique and should be stored if you need to unsubscribe\n     * @function\n     * @alias subscribe\n     * @param { String } message The message to subscribe to\n     * @param { Function } func The function to call when a new message is published\n     * @return { String }\n     */\n    PubSub.subscribe = function (message, func) {\n        if (typeof func !== 'function') {\n            return false;\n        }\n\n        // message is not registered yet\n        if (!messages.hasOwnProperty(message)) {\n            messages[message] = {};\n        }\n\n        // forcing token as String, to allow for future expansions without breaking usage\n        // and allow for easy use as key names for the 'messages' object\n        var token = 'uid_' + String(++lastUid);\n        messages[message][token] = func;\n\n        // return token for unsubscribing\n        return token;\n    };\n\n    /**\n     * Subscribes the passed function to the passed message once\n     * @function\n     * @alias subscribeOnce\n     * @param { String } message The message to subscribe to\n     * @param { Function } func The function to call when a new message is published\n     * @return { PubSub }\n     */\n    PubSub.subscribeOnce = function (message, func) {\n        var token = PubSub.subscribe(message, function () {\n            // before func apply, unsubscribe message\n            PubSub.unsubscribe(token);\n            func.apply(this, arguments);\n        });\n        return PubSub;\n    };\n\n    /**\n     * Clears all subscriptions\n     * @function\n     * @public\n     * @alias clearAllSubscriptions\n     */\n    PubSub.clearAllSubscriptions = function clearAllSubscriptions() {\n        messages = {};\n    };\n\n    /**\n     * Clear subscriptions by the topic\n     * @function\n     * @public\n     * @alias clearAllSubscriptions\n     */\n    PubSub.clearSubscriptions = function clearSubscriptions(topic) {\n        var m;\n        for (m in messages) {\n            if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0) {\n                delete messages[m];\n            }\n        }\n    };\n\n    /**\n     * Removes subscriptions\n     *\n     * - When passed a token, removes a specific subscription.\n     *\n    * - When passed a function, removes all subscriptions for that function\n     *\n    * - When passed a topic, removes all subscriptions for that topic (hierarchy)\n     * @function\n     * @public\n     * @alias subscribeOnce\n     * @param { String | Function } value A token, function or topic to unsubscribe from\n     * @example // Unsubscribing with a token\n     * var token = PubSub.subscribe('mytopic', myFunc);\n     * PubSub.unsubscribe(token);\n     * @example // Unsubscribing with a function\n     * PubSub.unsubscribe(myFunc);\n     * @example // Unsubscribing from a topic\n     * PubSub.unsubscribe('mytopic');\n     */\n    PubSub.unsubscribe = function (value) {\n        var descendantTopicExists = function descendantTopicExists(topic) {\n            var m;\n            for (m in messages) {\n                if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0) {\n                    // a descendant of the topic exists:\n                    return true;\n                }\n            }\n\n            return false;\n        },\n            isTopic = typeof value === 'string' && (messages.hasOwnProperty(value) || descendantTopicExists(value)),\n            isToken = !isTopic && typeof value === 'string',\n            isFunction = typeof value === 'function',\n            result = false,\n            m,\n            message,\n            t;\n\n        if (isTopic) {\n            PubSub.clearSubscriptions(value);\n            return;\n        }\n\n        for (m in messages) {\n            if (messages.hasOwnProperty(m)) {\n                message = messages[m];\n\n                if (isToken && message[value]) {\n                    delete message[value];\n                    result = value;\n                    // tokens are unique, so we can just stop here\n                    break;\n                }\n\n                if (isFunction) {\n                    for (t in message) {\n                        if (message.hasOwnProperty(t) && message[t] === value) {\n                            delete message[t];\n                            result = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/pubsub-js/src/pubsub.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n\tthrow new Error(\"define cannot be used indirect\");\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function () {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/assets/js/index.js":
/*!*******************************************************!*\
  !*** ./wp-content/themes/wappsnet/assets/js/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! modules/artarchive/index.js */ \"./wp-content/themes/wappsnet/modules/artarchive/index.js\");\n\n__webpack_require__(/*! modules/artwork/index.js */ \"./wp-content/themes/wappsnet/modules/artwork/index.js\");\n\n__webpack_require__(/*! modules/footer/index.js */ \"./wp-content/themes/wappsnet/modules/footer/index.js\");\n\n__webpack_require__(/*! modules/header/index.js */ \"./wp-content/themes/wappsnet/modules/header/index.js\");\n\n__webpack_require__(/*! modules/page/index.js */ \"./wp-content/themes/wappsnet/modules/page/index.js\");\n\n__webpack_require__(/*! modules/popular/index.js */ \"./wp-content/themes/wappsnet/modules/popular/index.js\");\n\n__webpack_require__(/*! modules/post/index.js */ \"./wp-content/themes/wappsnet/modules/post/index.js\");\n\n__webpack_require__(/*! modules/profile/index.js */ \"./wp-content/themes/wappsnet/modules/profile/index.js\");\n\n__webpack_require__(/*! modules/search/index.js */ \"./wp-content/themes/wappsnet/modules/search/index.js\");\n\n__webpack_require__(/*! modules/subscribe/index.js */ \"./wp-content/themes/wappsnet/modules/subscribe/index.js\");\n\n__webpack_require__(/*! plugins/artwork/index.js */ \"./wp-content/themes/wappsnet/plugins/artwork/index.js\");\n\n__webpack_require__(/*! plugins/cabinet/index.js */ \"./wp-content/themes/wappsnet/plugins/cabinet/index.js\");\n\n__webpack_require__(/*! plugins/carousel/index.js */ \"./wp-content/themes/wappsnet/plugins/carousel/index.js\");\n\n__webpack_require__(/*! plugins/categories/index.js */ \"./wp-content/themes/wappsnet/plugins/categories/index.js\");\n\n__webpack_require__(/*! plugins/comments/index.js */ \"./wp-content/themes/wappsnet/plugins/comments/index.js\");\n\n__webpack_require__(/*! plugins/contact/index.js */ \"./wp-content/themes/wappsnet/plugins/contact/index.js\");\n\n__webpack_require__(/*! plugins/copyrights/index.js */ \"./wp-content/themes/wappsnet/plugins/copyrights/index.js\");\n\n__webpack_require__(/*! plugins/forgot/index.js */ \"./wp-content/themes/wappsnet/plugins/forgot/index.js\");\n\n__webpack_require__(/*! plugins/login/index.js */ \"./wp-content/themes/wappsnet/plugins/login/index.js\");\n\n__webpack_require__(/*! plugins/mobileIcons/index.js */ \"./wp-content/themes/wappsnet/plugins/mobileIcons/index.js\");\n\n__webpack_require__(/*! plugins/navigation/index.js */ \"./wp-content/themes/wappsnet/plugins/navigation/index.js\");\n\n__webpack_require__(/*! plugins/pagination/index.js */ \"./wp-content/themes/wappsnet/plugins/pagination/index.js\");\n\n__webpack_require__(/*! plugins/post/index.js */ \"./wp-content/themes/wappsnet/plugins/post/index.js\");\n\n__webpack_require__(/*! plugins/product/index.js */ \"./wp-content/themes/wappsnet/plugins/product/index.js\");\n\n__webpack_require__(/*! plugins/register/index.js */ \"./wp-content/themes/wappsnet/plugins/register/index.js\");\n\n__webpack_require__(/*! plugins/socialicons/index.js */ \"./wp-content/themes/wappsnet/plugins/socialicons/index.js\");\n\n__webpack_require__(/*! plugins/socialshare/index.js */ \"./wp-content/themes/wappsnet/plugins/socialshare/index.js\");\n\n__webpack_require__(/*! ./partials/main.js */ \"./wp-content/themes/wappsnet/assets/js/partials/main.js\");\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/assets/js/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/assets/js/partials/auth.js":
/*!***************************************************************!*\
  !*** ./wp-content/themes/wappsnet/assets/js/partials/auth.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nvar _validate = __webpack_require__(/*! ../partials/validate */ \"./wp-content/themes/wappsnet/assets/js/partials/validate.js\");\n\nvar _validate2 = _interopRequireDefault(_validate);\n\nvar _control = __webpack_require__(/*! ../partials/control */ \"./wp-content/themes/wappsnet/assets/js/partials/control.js\");\n\nvar _control2 = _interopRequireDefault(_control);\n\nvar _cores = __webpack_require__(/*! ../partials/cores */ \"./wp-content/themes/wappsnet/assets/js/partials/cores.js\");\n\nvar _cores2 = _interopRequireDefault(_cores);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Auth = {\n    actionUser: function actionUser(type, callBack) {\n        var formIsValid = true;\n\n        var formData = {\n            action: type\n        };\n\n        $(\".\" + type).each(function () {\n            var validator = new _validate2.default();\n            var inputNode = this;\n            var inputType = inputNode.getAttribute('data-type');\n            var inputName = inputNode.getAttribute('name');\n            var inputValue = inputNode.value;\n            var required = validator.hooks.required(inputNode);\n            var noErrors = true;\n\n            if (!required) {\n                noErrors = false;\n            } else {\n                switch (inputType) {\n                    case \"email\":\n                        noErrors = validator.hooks.valid_email(inputNode);\n                        break;\n                    case \"phone\":\n                        noErrors = validator.hooks.mobileNumber(inputNode);\n                        break;\n                    case \"name\":\n                        noErrors = validator.hooks.alpha(inputNode);\n                        break;\n                    case \"text\":\n                        noErrors = validator.hooks.min_length(inputNode, 3);\n                        break;\n                    case \"password\":\n                        noErrors = validator.hooks.password(inputNode);\n                        break;\n                }\n            }\n\n            if (!noErrors) {\n                inputNode.classList.add('auth-error');\n                formIsValid = false;\n            } else {\n                formData[inputName] = inputValue;\n                if (inputNode.classList.contains('auth-error')) {\n                    inputNode.classList.remove('auth-error');\n                }\n            }\n        });\n\n        if (formIsValid) {\n            _control2.default.poster(formData, function (response) {\n                if (response.errors && Object.keys(response.errors).length > 0) {\n                    Object.keys(response.errors).map(function (key) {\n                        $('#' + type + '_' + key).addClass('auth-error');\n                    });\n                }\n\n                if (response.messages && Object.keys(response.messages).length > 0) {\n                    var messageClass = \"auth-message\";\n                    var messagePlace = $('#auth-info-messages');\n\n                    _cores2.default.removeXhrMessages(messageClass);\n\n                    Object.keys(response.messages).map(function (key) {\n                        var messageBlock = _cores2.default.createXhrMessages(response.messages[key], messageClass);\n                        messagePlace.prepend(messageBlock);\n                    });\n\n                    _cores2.default.scrollToNode(messagePlace);\n                }\n\n                if (typeof callBack === 'function') {\n                    callBack(response);\n                }\n\n                if (response.location) {\n                    window.location = response.location;\n                }\n            });\n        } else {\n            _cores2.default.scrollToNode($(\".\" + type + \".auth-error\"));\n        }\n    },\n    subscribe: function subscribe() {\n        var formData = {};\n        var formIsValid = true;\n\n        $('.subscribe-input').each(function () {\n            var inputNode = this;\n            var inputType = inputNode.getAttribute('data-type');\n            var inputName = inputNode.getAttribute('name');\n            var inputValue = inputNode.value;\n            var validator = new _validate2.default();\n            var required = validator.hooks.required(inputNode);\n            var noErrors = true;\n\n            if (!required) {\n                noErrors = false;\n            } else {\n                switch (inputType) {\n                    case \"email\":\n                        noErrors = validator.hooks.valid_email(inputNode);\n                        break;\n                }\n            }\n\n            if (!noErrors) {\n                inputNode.classList.add('error');\n                formIsValid = false;\n            } else {\n                formData[inputName] = inputValue;\n                if (inputNode.classList.contains('error')) {\n                    inputNode.classList.remove('error');\n                }\n            }\n        });\n\n        if (formIsValid) {\n            formData[\"action\"] = \"subscribe\";\n            _control2.default.poster(formData, function (response) {\n                if (response.errors && Object.keys(response.errors).length > 0) {\n                    Object.keys(response.errors).map(function (key) {\n                        $('#' + key).addClass('error');\n                    });\n                }\n\n                var messageClass = \"subscribe-message\";\n                var messagePlace = $('#subscribe-messages');\n\n                Object.keys(response.messages).map(function (key) {\n                    _cores2.default.removeXhrMessages(messageClass);\n                    var messageBlock = _cores2.default.createXhrMessages(response.messages[key], messageClass);\n                    messagePlace.prepend(messageBlock);\n                });\n\n                _cores2.default.scrollToNode(messagePlace);\n            });\n        } else {\n            _cores2.default.scrollToNode($('.subscribe-input.error'));\n        }\n    },\n    goToLocation: function goToLocation(link) {\n        var hostSep = \"//\";\n        var homeUrl = location.protocol + hostSep + location.host;\n        var locateTo = link || \"\";\n        document.location.href = homeUrl + locateTo;\n    }\n};\n\nmodule.exports = Auth;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/assets/js/partials/auth.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/assets/js/partials/carousel.js":
/*!*******************************************************************!*\
  !*** ./wp-content/themes/wappsnet/assets/js/partials/carousel.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (factory) {\n    'use strict';\n\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(function ($) {\n    'use strict';\n\n    var Slick = window.Slick || {};\n\n    Slick = function () {\n\n        var instanceUid = 0;\n\n        function Slick(element, settings) {\n\n            var _ = this,\n                dataSettings;\n\n            _.defaults = {\n                accessibility: true,\n                adaptiveHeight: false,\n                appendArrows: $(element),\n                appendDots: $(element),\n                arrows: true,\n                asNavFor: null,\n                prevArrow: '<button type=\"button\" data-role=\"none\" class=\"slick-prev\" aria-label=\"Previous\" tabindex=\"0\" role=\"button\"><i class=\"fa fa-angle-left\"></i></button>',\n                nextArrow: '<button type=\"button\" data-role=\"none\" class=\"slick-next\" aria-label=\"Next\" tabindex=\"0\" role=\"button\"><i class=\"fa fa-angle-right\"></i></button>',\n                autoplay: false,\n                autoplaySpeed: 3000,\n                centerMode: false,\n                centerPadding: '50px',\n                cssEase: 'ease',\n                customPaging: function customPaging(slider, i) {\n                    return $('<button type=\"button\" data-role=\"none\" role=\"button\" tabindex=\"0\" />').text(i + 1);\n                },\n                dots: false,\n                dotsClass: 'slick-dots',\n                draggable: true,\n                easing: 'linear',\n                edgeFriction: 0.35,\n                fade: false,\n                focusOnSelect: false,\n                infinite: true,\n                initialSlide: 0,\n                lazyLoad: 'ondemand',\n                mobileFirst: false,\n                pauseOnHover: true,\n                pauseOnFocus: true,\n                pauseOnDotsHover: false,\n                respondTo: 'window',\n                responsive: null,\n                rows: 1,\n                rtl: false,\n                slide: '',\n                slidesPerRow: 1,\n                slidesToShow: 1,\n                slidesToScroll: 1,\n                speed: 500,\n                swipe: true,\n                swipeToSlide: false,\n                touchMove: true,\n                touchThreshold: 5,\n                useCSS: true,\n                useTransform: true,\n                variableWidth: false,\n                vertical: false,\n                verticalSwiping: false,\n                waitForAnimate: true,\n                zIndex: 1000\n            };\n\n            _.initials = {\n                animating: false,\n                dragging: false,\n                autoPlayTimer: null,\n                currentDirection: 0,\n                currentLeft: null,\n                currentSlide: 0,\n                direction: 1,\n                $dots: null,\n                listWidth: null,\n                listHeight: null,\n                loadIndex: 0,\n                $nextArrow: null,\n                $prevArrow: null,\n                slideCount: null,\n                slideWidth: null,\n                $slideTrack: null,\n                $slides: null,\n                sliding: false,\n                slideOffset: 0,\n                swipeLeft: null,\n                $list: null,\n                touchObject: {},\n                transformsEnabled: false,\n                unslicked: false\n            };\n\n            $.extend(_, _.initials);\n\n            _.activeBreakpoint = null;\n            _.animType = null;\n            _.animProp = null;\n            _.breakpoints = [];\n            _.breakpointSettings = [];\n            _.cssTransitions = false;\n            _.focussed = false;\n            _.interrupted = false;\n            _.hidden = 'hidden';\n            _.paused = true;\n            _.positionProp = null;\n            _.respondTo = null;\n            _.rowCount = 1;\n            _.shouldClick = true;\n            _.$slider = $(element);\n            _.$slidesCache = null;\n            _.transformType = null;\n            _.transitionType = null;\n            _.visibilityChange = 'visibilitychange';\n            _.windowWidth = 0;\n            _.windowTimer = null;\n\n            dataSettings = $(element).data('slick') || {};\n\n            _.options = $.extend({}, _.defaults, settings, dataSettings);\n\n            _.currentSlide = _.options.initialSlide;\n\n            _.originalSettings = _.options;\n\n            if (typeof document.mozHidden !== 'undefined') {\n                _.hidden = 'mozHidden';\n                _.visibilityChange = 'mozvisibilitychange';\n            } else if (typeof document.webkitHidden !== 'undefined') {\n                _.hidden = 'webkitHidden';\n                _.visibilityChange = 'webkitvisibilitychange';\n            }\n\n            _.autoPlay = $.proxy(_.autoPlay, _);\n            _.autoPlayClear = $.proxy(_.autoPlayClear, _);\n            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);\n            _.changeSlide = $.proxy(_.changeSlide, _);\n            _.clickHandler = $.proxy(_.clickHandler, _);\n            _.selectHandler = $.proxy(_.selectHandler, _);\n            _.setPosition = $.proxy(_.setPosition, _);\n            _.swipeHandler = $.proxy(_.swipeHandler, _);\n            _.dragHandler = $.proxy(_.dragHandler, _);\n            _.keyHandler = $.proxy(_.keyHandler, _);\n\n            _.instanceUid = instanceUid++;\n\n            // A simple way to check for HTML strings\n            // Strict HTML recognition (must start with <)\n            // Extracted from jQuery v1.11 source\n            _.htmlExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*)$/;\n\n            _.registerBreakpoints();\n            _.init(true);\n        }\n\n        return Slick;\n    }();\n\n    Slick.prototype.activateADA = function () {\n        var _ = this;\n\n        _.$slideTrack.find('.slick-active').attr({\n            'aria-hidden': 'false'\n        }).find('a, input, button, select').attr({\n            'tabindex': '0'\n        });\n    };\n\n    Slick.prototype.addSlide = Slick.prototype.slickAdd = function (markup, index, addBefore) {\n\n        var _ = this;\n\n        if (typeof index === 'boolean') {\n            addBefore = index;\n            index = null;\n        } else if (index < 0 || index >= _.slideCount) {\n            return false;\n        }\n\n        _.unload();\n\n        if (typeof index === 'number') {\n            if (index === 0 && _.$slides.length === 0) {\n                $(markup).appendTo(_.$slideTrack);\n            } else if (addBefore) {\n                $(markup).insertBefore(_.$slides.eq(index));\n            } else {\n                $(markup).insertAfter(_.$slides.eq(index));\n            }\n        } else {\n            if (addBefore === true) {\n                $(markup).prependTo(_.$slideTrack);\n            } else {\n                $(markup).appendTo(_.$slideTrack);\n            }\n        }\n\n        _.$slides = _.$slideTrack.children(this.options.slide);\n\n        _.$slideTrack.children(this.options.slide).detach();\n\n        _.$slideTrack.append(_.$slides);\n\n        _.$slides.each(function (index, element) {\n            $(element).attr('data-slick-index', index);\n        });\n\n        _.$slidesCache = _.$slides;\n\n        _.reinit();\n    };\n\n    Slick.prototype.animateHeight = function () {\n        var _ = this;\n        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {\n            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);\n            _.$list.animate({\n                height: targetHeight\n            }, _.options.speed);\n        }\n    };\n\n    Slick.prototype.animateSlide = function (targetLeft, callback) {\n\n        var animProps = {},\n            _ = this;\n\n        _.animateHeight();\n\n        if (_.options.rtl === true && _.options.vertical === false) {\n            targetLeft = -targetLeft;\n        }\n        if (_.transformsEnabled === false) {\n            if (_.options.vertical === false) {\n                _.$slideTrack.animate({\n                    left: targetLeft\n                }, _.options.speed, _.options.easing, callback);\n            } else {\n                _.$slideTrack.animate({\n                    top: targetLeft\n                }, _.options.speed, _.options.easing, callback);\n            }\n        } else {\n\n            if (_.cssTransitions === false) {\n                if (_.options.rtl === true) {\n                    _.currentLeft = -_.currentLeft;\n                }\n                $({\n                    animStart: _.currentLeft\n                }).animate({\n                    animStart: targetLeft\n                }, {\n                    duration: _.options.speed,\n                    easing: _.options.easing,\n                    step: function step(now) {\n                        now = Math.ceil(now);\n                        if (_.options.vertical === false) {\n                            animProps[_.animType] = 'translate(' + now + 'px, 0px)';\n                            _.$slideTrack.css(animProps);\n                        } else {\n                            animProps[_.animType] = 'translate(0px,' + now + 'px)';\n                            _.$slideTrack.css(animProps);\n                        }\n                    },\n                    complete: function complete() {\n                        if (callback) {\n                            callback.call();\n                        }\n                    }\n                });\n            } else {\n\n                _.applyTransition();\n                targetLeft = Math.ceil(targetLeft);\n\n                if (_.options.vertical === false) {\n                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';\n                } else {\n                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';\n                }\n                _.$slideTrack.css(animProps);\n\n                if (callback) {\n                    setTimeout(function () {\n\n                        _.disableTransition();\n\n                        callback.call();\n                    }, _.options.speed);\n                }\n            }\n        }\n    };\n\n    Slick.prototype.getNavTarget = function () {\n\n        var _ = this,\n            asNavFor = _.options.asNavFor;\n\n        if (asNavFor && asNavFor !== null) {\n            asNavFor = $(asNavFor).not(_.$slider);\n        }\n\n        return asNavFor;\n    };\n\n    Slick.prototype.asNavFor = function (index) {\n\n        var _ = this,\n            asNavFor = _.getNavTarget();\n\n        if (asNavFor !== null && (typeof asNavFor === 'undefined' ? 'undefined' : _typeof(asNavFor)) === 'object') {\n            asNavFor.each(function () {\n                var target = $(this).slick('getSlick');\n                if (!target.unslicked) {\n                    target.slideHandler(index, true);\n                }\n            });\n        }\n    };\n\n    Slick.prototype.applyTransition = function (slide) {\n\n        var _ = this,\n            transition = {};\n\n        if (_.options.fade === false) {\n            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;\n        } else {\n            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;\n        }\n\n        if (_.options.fade === false) {\n            _.$slideTrack.css(transition);\n        } else {\n            _.$slides.eq(slide).css(transition);\n        }\n    };\n\n    Slick.prototype.autoPlay = function () {\n\n        var _ = this;\n\n        _.autoPlayClear();\n\n        if (_.slideCount > _.options.slidesToShow) {\n            _.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);\n        }\n    };\n\n    Slick.prototype.autoPlayClear = function () {\n\n        var _ = this;\n\n        if (_.autoPlayTimer) {\n            clearInterval(_.autoPlayTimer);\n        }\n    };\n\n    Slick.prototype.autoPlayIterator = function () {\n\n        var _ = this,\n            slideTo = _.currentSlide + _.options.slidesToScroll;\n\n        if (!_.paused && !_.interrupted && !_.focussed) {\n\n            if (_.options.infinite === false) {\n\n                if (_.direction === 1 && _.currentSlide + 1 === _.slideCount - 1) {\n                    _.direction = 0;\n                } else if (_.direction === 0) {\n\n                    slideTo = _.currentSlide - _.options.slidesToScroll;\n\n                    if (_.currentSlide - 1 === 0) {\n                        _.direction = 1;\n                    }\n                }\n            }\n\n            _.slideHandler(slideTo);\n        }\n    };\n\n    Slick.prototype.buildArrows = function () {\n\n        var _ = this;\n\n        if (_.options.arrows === true) {\n\n            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');\n            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');\n\n            if (_.slideCount > _.options.slidesToShow) {\n\n                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');\n                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');\n\n                if (_.htmlExpr.test(_.options.prevArrow)) {\n                    _.$prevArrow.prependTo(_.options.appendArrows);\n                }\n\n                if (_.htmlExpr.test(_.options.nextArrow)) {\n                    _.$nextArrow.appendTo(_.options.appendArrows);\n                }\n\n                if (_.options.infinite !== true) {\n                    _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\n                }\n            } else {\n\n                _.$prevArrow.add(_.$nextArrow).addClass('slick-hidden').attr({\n                    'aria-disabled': 'true',\n                    'tabindex': '-1'\n                });\n            }\n        }\n    };\n\n    Slick.prototype.buildDots = function () {\n\n        var _ = this,\n            i,\n            dot;\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$slider.addClass('slick-dotted');\n\n            dot = $('<ul />').addClass(_.options.dotsClass);\n\n            for (i = 0; i <= _.getDotCount(); i += 1) {\n                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));\n            }\n\n            _.$dots = dot.appendTo(_.options.appendDots);\n\n            _.$dots.find('li').first().addClass('slick-active').attr('aria-hidden', 'false');\n        }\n    };\n\n    Slick.prototype.buildOut = function () {\n\n        var _ = this;\n\n        _.$slides = _.$slider.children(_.options.slide + ':not(.slick-cloned)').addClass('slick-slide');\n\n        _.slideCount = _.$slides.length;\n\n        _.$slides.each(function (index, element) {\n            $(element).attr('data-slick-index', index).data('originalStyling', $(element).attr('style') || '');\n        });\n\n        _.$slider.addClass('slick-slider');\n\n        _.$slideTrack = _.slideCount === 0 ? $('<div class=\"slick-track\"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class=\"slick-track\"/>').parent();\n\n        _.$list = _.$slideTrack.wrap('<div aria-live=\"polite\" class=\"slick-list\"/>').parent();\n        _.$slideTrack.css('opacity', 0);\n\n        if (_.options.centerMode === true || _.options.swipeToSlide === true) {\n            _.options.slidesToScroll = 1;\n        }\n\n        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');\n\n        _.setupInfinite();\n\n        _.buildArrows();\n\n        _.buildDots();\n\n        _.updateDots();\n\n        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);\n\n        if (_.options.draggable === true) {\n            _.$list.addClass('draggable');\n        }\n    };\n\n    Slick.prototype.buildRows = function () {\n\n        var _ = this,\n            a,\n            b,\n            c,\n            newSlides,\n            numOfSlides,\n            originalSlides,\n            slidesPerSection;\n\n        newSlides = document.createDocumentFragment();\n        originalSlides = _.$slider.children();\n\n        if (_.options.rows > 1) {\n\n            slidesPerSection = _.options.slidesPerRow * _.options.rows;\n            numOfSlides = Math.ceil(originalSlides.length / slidesPerSection);\n\n            for (a = 0; a < numOfSlides; a++) {\n                var slide = document.createElement('div');\n                for (b = 0; b < _.options.rows; b++) {\n                    var row = document.createElement('div');\n                    for (c = 0; c < _.options.slidesPerRow; c++) {\n                        var target = a * slidesPerSection + (b * _.options.slidesPerRow + c);\n                        if (originalSlides.get(target)) {\n                            row.appendChild(originalSlides.get(target));\n                        }\n                    }\n                    slide.appendChild(row);\n                }\n                newSlides.appendChild(slide);\n            }\n\n            _.$slider.empty().append(newSlides);\n            _.$slider.children().children().children().css({\n                'width': 100 / _.options.slidesPerRow + '%',\n                'display': 'inline-block'\n            });\n        }\n    };\n\n    Slick.prototype.checkResponsive = function (initial, forceUpdate) {\n\n        var _ = this,\n            breakpoint,\n            targetBreakpoint,\n            respondToWidth,\n            triggerBreakpoint = false;\n        var sliderWidth = _.$slider.width();\n        var windowWidth = window.innerWidth || $(window).width();\n\n        if (_.respondTo === 'window') {\n            respondToWidth = windowWidth;\n        } else if (_.respondTo === 'slider') {\n            respondToWidth = sliderWidth;\n        } else if (_.respondTo === 'min') {\n            respondToWidth = Math.min(windowWidth, sliderWidth);\n        }\n\n        if (_.options.responsive && _.options.responsive.length && _.options.responsive !== null) {\n\n            targetBreakpoint = null;\n\n            for (breakpoint in _.breakpoints) {\n                if (_.breakpoints.hasOwnProperty(breakpoint)) {\n                    if (_.originalSettings.mobileFirst === false) {\n                        if (respondToWidth < _.breakpoints[breakpoint]) {\n                            targetBreakpoint = _.breakpoints[breakpoint];\n                        }\n                    } else {\n                        if (respondToWidth > _.breakpoints[breakpoint]) {\n                            targetBreakpoint = _.breakpoints[breakpoint];\n                        }\n                    }\n                }\n            }\n\n            if (targetBreakpoint !== null) {\n                if (_.activeBreakpoint !== null) {\n                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {\n                        _.activeBreakpoint = targetBreakpoint;\n                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {\n                            _.unslick(targetBreakpoint);\n                        } else {\n                            _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);\n                            if (initial === true) {\n                                _.currentSlide = _.options.initialSlide;\n                            }\n                            _.refresh(initial);\n                        }\n                        triggerBreakpoint = targetBreakpoint;\n                    }\n                } else {\n                    _.activeBreakpoint = targetBreakpoint;\n                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {\n                        _.unslick(targetBreakpoint);\n                    } else {\n                        _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);\n                        if (initial === true) {\n                            _.currentSlide = _.options.initialSlide;\n                        }\n                        _.refresh(initial);\n                    }\n                    triggerBreakpoint = targetBreakpoint;\n                }\n            } else {\n                if (_.activeBreakpoint !== null) {\n                    _.activeBreakpoint = null;\n                    _.options = _.originalSettings;\n                    if (initial === true) {\n                        _.currentSlide = _.options.initialSlide;\n                    }\n                    _.refresh(initial);\n                    triggerBreakpoint = targetBreakpoint;\n                }\n            }\n\n            // only trigger breakpoints during an actual break. not on initialize.\n            if (!initial && triggerBreakpoint !== false) {\n                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);\n            }\n        }\n    };\n\n    Slick.prototype.changeSlide = function (event, dontAnimate) {\n\n        var _ = this,\n            $target = $(event.currentTarget),\n            indexOffset,\n            slideOffset,\n            unevenOffset;\n\n        // If target is a link, prevent default action.\n        if ($target.is('a')) {\n            event.preventDefault();\n        }\n\n        // If target is not the <li> element (ie: a child), find the <li>.\n        if (!$target.is('li')) {\n            $target = $target.closest('li');\n        }\n\n        unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;\n        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;\n\n        switch (event.data.message) {\n\n            case 'previous':\n                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;\n                if (_.slideCount > _.options.slidesToShow) {\n                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);\n                }\n                break;\n\n            case 'next':\n                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;\n                if (_.slideCount > _.options.slidesToShow) {\n                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);\n                }\n                break;\n\n            case 'index':\n                var index = event.data.index === 0 ? 0 : event.data.index || $target.index() * _.options.slidesToScroll;\n\n                _.slideHandler(_.checkNavigable(index), false, dontAnimate);\n                $target.children().trigger('focus');\n                break;\n\n            default:\n                return;\n        }\n    };\n\n    Slick.prototype.checkNavigable = function (index) {\n\n        var _ = this,\n            navigables,\n            prevNavigable;\n\n        navigables = _.getNavigableIndexes();\n        prevNavigable = 0;\n        if (index > navigables[navigables.length - 1]) {\n            index = navigables[navigables.length - 1];\n        } else {\n            for (var n in navigables) {\n                if (index < navigables[n]) {\n                    index = prevNavigable;\n                    break;\n                }\n                prevNavigable = navigables[n];\n            }\n        }\n\n        return index;\n    };\n\n    Slick.prototype.cleanUpEvents = function () {\n\n        var _ = this;\n\n        if (_.options.dots && _.$dots !== null) {\n\n            $('li', _.$dots).off('click.slick', _.changeSlide).off('mouseenter.slick', $.proxy(_.interrupt, _, true)).off('mouseleave.slick', $.proxy(_.interrupt, _, false));\n        }\n\n        _.$slider.off('focus.slick blur.slick');\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);\n            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);\n        }\n\n        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);\n        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);\n        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);\n        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);\n\n        _.$list.off('click.slick', _.clickHandler);\n\n        $(document).off(_.visibilityChange, _.visibility);\n\n        _.cleanUpSlideEvents();\n\n        if (_.options.accessibility === true) {\n            _.$list.off('keydown.slick', _.keyHandler);\n        }\n\n        if (_.options.focusOnSelect === true) {\n            $(_.$slideTrack).children().off('click.slick', _.selectHandler);\n        }\n\n        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);\n\n        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);\n\n        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);\n\n        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);\n        $(document).off('ready.slick.slick-' + _.instanceUid, _.setPosition);\n    };\n\n    Slick.prototype.cleanUpSlideEvents = function () {\n\n        var _ = this;\n\n        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));\n        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));\n    };\n\n    Slick.prototype.cleanUpRows = function () {\n\n        var _ = this,\n            originalSlides;\n\n        if (_.options.rows > 1) {\n            originalSlides = _.$slides.children().children();\n            originalSlides.removeAttr('style');\n            _.$slider.empty().append(originalSlides);\n        }\n    };\n\n    Slick.prototype.clickHandler = function (event) {\n\n        var _ = this;\n\n        if (_.shouldClick === false) {\n            event.stopImmediatePropagation();\n            event.stopPropagation();\n            event.preventDefault();\n        }\n    };\n\n    Slick.prototype.destroy = function (refresh) {\n\n        var _ = this;\n\n        _.autoPlayClear();\n\n        _.touchObject = {};\n\n        _.cleanUpEvents();\n\n        $('.slick-cloned', _.$slider).detach();\n\n        if (_.$dots) {\n            _.$dots.remove();\n        }\n\n        if (_.$prevArrow && _.$prevArrow.length) {\n\n            _.$prevArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');\n\n            if (_.htmlExpr.test(_.options.prevArrow)) {\n                _.$prevArrow.remove();\n            }\n        }\n\n        if (_.$nextArrow && _.$nextArrow.length) {\n\n            _.$nextArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');\n\n            if (_.htmlExpr.test(_.options.nextArrow)) {\n                _.$nextArrow.remove();\n            }\n        }\n\n        if (_.$slides) {\n\n            _.$slides.removeClass('slick-slide slick-active slick-center slick-visible slick-current').removeAttr('aria-hidden').removeAttr('data-slick-index').each(function () {\n                $(this).attr('style', $(this).data('originalStyling'));\n            });\n\n            _.$slideTrack.children(this.options.slide).detach();\n\n            _.$slideTrack.detach();\n\n            _.$list.detach();\n\n            _.$slider.append(_.$slides);\n        }\n\n        _.cleanUpRows();\n\n        _.$slider.removeClass('slick-slider');\n        _.$slider.removeClass('slick-initialized');\n        _.$slider.removeClass('slick-dotted');\n\n        _.unslicked = true;\n\n        if (!refresh) {\n            _.$slider.trigger('destroy', [_]);\n        }\n    };\n\n    Slick.prototype.disableTransition = function (slide) {\n\n        var _ = this,\n            transition = {};\n\n        transition[_.transitionType] = '';\n\n        if (_.options.fade === false) {\n            _.$slideTrack.css(transition);\n        } else {\n            _.$slides.eq(slide).css(transition);\n        }\n    };\n\n    Slick.prototype.fadeSlide = function (slideIndex, callback) {\n\n        var _ = this;\n\n        if (_.cssTransitions === false) {\n\n            _.$slides.eq(slideIndex).css({\n                zIndex: _.options.zIndex\n            });\n\n            _.$slides.eq(slideIndex).animate({\n                opacity: 1\n            }, _.options.speed, _.options.easing, callback);\n        } else {\n\n            _.applyTransition(slideIndex);\n\n            _.$slides.eq(slideIndex).css({\n                opacity: 1,\n                zIndex: _.options.zIndex\n            });\n\n            if (callback) {\n                setTimeout(function () {\n\n                    _.disableTransition(slideIndex);\n\n                    callback.call();\n                }, _.options.speed);\n            }\n        }\n    };\n\n    Slick.prototype.fadeSlideOut = function (slideIndex) {\n\n        var _ = this;\n\n        if (_.cssTransitions === false) {\n\n            _.$slides.eq(slideIndex).animate({\n                opacity: 0,\n                zIndex: _.options.zIndex - 2\n            }, _.options.speed, _.options.easing);\n        } else {\n\n            _.applyTransition(slideIndex);\n\n            _.$slides.eq(slideIndex).css({\n                opacity: 0,\n                zIndex: _.options.zIndex - 2\n            });\n        }\n    };\n\n    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function (filter) {\n\n        var _ = this;\n\n        if (filter !== null) {\n\n            _.$slidesCache = _.$slides;\n\n            _.unload();\n\n            _.$slideTrack.children(this.options.slide).detach();\n\n            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);\n\n            _.reinit();\n        }\n    };\n\n    Slick.prototype.focusHandler = function () {\n\n        var _ = this;\n\n        _.$slider.off('focus.slick blur.slick').on('focus.slick blur.slick', '*:not(.slick-arrow)', function (event) {\n\n            event.stopImmediatePropagation();\n            var $sf = $(this);\n\n            setTimeout(function () {\n\n                if (_.options.pauseOnFocus) {\n                    _.focussed = $sf.is(':focus');\n                    _.autoPlay();\n                }\n            }, 0);\n        });\n    };\n\n    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function () {\n\n        var _ = this;\n        return _.currentSlide;\n    };\n\n    Slick.prototype.getDotCount = function () {\n\n        var _ = this;\n\n        var breakPoint = 0;\n        var counter = 0;\n        var pagerQty = 0;\n\n        if (_.options.infinite === true) {\n            while (breakPoint < _.slideCount) {\n                ++pagerQty;\n                breakPoint = counter + _.options.slidesToScroll;\n                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\n            }\n        } else if (_.options.centerMode === true) {\n            pagerQty = _.slideCount;\n        } else if (!_.options.asNavFor) {\n            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);\n        } else {\n            while (breakPoint < _.slideCount) {\n                ++pagerQty;\n                breakPoint = counter + _.options.slidesToScroll;\n                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\n            }\n        }\n\n        return pagerQty - 1;\n    };\n\n    Slick.prototype.getLeft = function (slideIndex) {\n\n        var _ = this,\n            targetLeft,\n            verticalHeight,\n            verticalOffset = 0,\n            targetSlide;\n\n        _.slideOffset = 0;\n        verticalHeight = _.$slides.first().outerHeight(true);\n\n        if (_.options.infinite === true) {\n            if (_.slideCount > _.options.slidesToShow) {\n                _.slideOffset = _.slideWidth * _.options.slidesToShow * -1;\n                verticalOffset = verticalHeight * _.options.slidesToShow * -1;\n            }\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\n                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {\n                    if (slideIndex > _.slideCount) {\n                        _.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1;\n                        verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1;\n                    } else {\n                        _.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1;\n                        verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1;\n                    }\n                }\n            }\n        } else {\n            if (slideIndex + _.options.slidesToShow > _.slideCount) {\n                _.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;\n                verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;\n            }\n        }\n\n        if (_.slideCount <= _.options.slidesToShow) {\n            _.slideOffset = 0;\n            verticalOffset = 0;\n        }\n\n        if (_.options.centerMode === true && _.options.infinite === true) {\n            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;\n        } else if (_.options.centerMode === true) {\n            _.slideOffset = 0;\n            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);\n        }\n\n        if (_.options.vertical === false) {\n            targetLeft = slideIndex * _.slideWidth * -1 + _.slideOffset;\n        } else {\n            targetLeft = slideIndex * verticalHeight * -1 + verticalOffset;\n        }\n\n        if (_.options.variableWidth === true) {\n\n            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {\n                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);\n            } else {\n                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);\n            }\n\n            if (_.options.rtl === true) {\n                if (targetSlide[0]) {\n                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;\n                } else {\n                    targetLeft = 0;\n                }\n            } else {\n                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;\n            }\n\n            if (_.options.centerMode === true) {\n                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {\n                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);\n                } else {\n                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);\n                }\n\n                if (_.options.rtl === true) {\n                    if (targetSlide[0]) {\n                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;\n                    } else {\n                        targetLeft = 0;\n                    }\n                } else {\n                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;\n                }\n\n                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;\n            }\n        }\n\n        return targetLeft;\n    };\n\n    Slick.prototype.getOption = Slick.prototype.slickGetOption = function (option) {\n\n        var _ = this;\n\n        return _.options[option];\n    };\n\n    Slick.prototype.getNavigableIndexes = function () {\n\n        var _ = this,\n            breakPoint = 0,\n            counter = 0,\n            indexes = [],\n            max;\n\n        if (_.options.infinite === false) {\n            max = _.slideCount;\n        } else {\n            breakPoint = _.options.slidesToScroll * -1;\n            counter = _.options.slidesToScroll * -1;\n            max = _.slideCount * 2;\n        }\n\n        while (breakPoint < max) {\n            indexes.push(breakPoint);\n            breakPoint = counter + _.options.slidesToScroll;\n            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;\n        }\n\n        return indexes;\n    };\n\n    Slick.prototype.getSlick = function () {\n\n        return this;\n    };\n\n    Slick.prototype.getSlideCount = function () {\n\n        var _ = this,\n            slidesTraversed,\n            swipedSlide,\n            centerOffset;\n\n        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;\n\n        if (_.options.swipeToSlide === true) {\n            _.$slideTrack.find('.slick-slide').each(function (index, slide) {\n                if (slide.offsetLeft - centerOffset + $(slide).outerWidth() / 2 > _.swipeLeft * -1) {\n                    swipedSlide = slide;\n                    return false;\n                }\n            });\n\n            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;\n\n            return slidesTraversed;\n        } else {\n            return _.options.slidesToScroll;\n        }\n    };\n\n    Slick.prototype.goTo = Slick.prototype.slickGoTo = function (slide, dontAnimate) {\n\n        var _ = this;\n\n        _.changeSlide({\n            data: {\n                message: 'index',\n                index: parseInt(slide)\n            }\n        }, dontAnimate);\n    };\n\n    Slick.prototype.init = function (creation) {\n\n        var _ = this;\n\n        if (!$(_.$slider).hasClass('slick-initialized')) {\n\n            $(_.$slider).addClass('slick-initialized');\n\n            _.buildRows();\n            _.buildOut();\n            _.setProps();\n            _.startLoad();\n            _.loadSlider();\n            _.initializeEvents();\n            _.updateArrows();\n            _.updateDots();\n            _.checkResponsive(true);\n            _.focusHandler();\n        }\n\n        if (creation) {\n            _.$slider.trigger('init', [_]);\n        }\n\n        if (_.options.accessibility === true) {\n            _.initADA();\n        }\n\n        if (_.options.autoplay) {\n\n            _.paused = false;\n            _.autoPlay();\n        }\n    };\n\n    Slick.prototype.initADA = function () {\n        var _ = this;\n        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({\n            'aria-hidden': 'true',\n            'tabindex': '-1'\n        }).find('a, input, button, select').attr({\n            'tabindex': '-1'\n        });\n\n        _.$slideTrack.attr('role', 'listbox');\n\n        _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function (i) {\n            $(this).attr({\n                'role': 'option',\n                'aria-describedby': 'slick-slide' + _.instanceUid + i + ''\n            });\n        });\n\n        if (_.$dots !== null) {\n            _.$dots.attr('role', 'tablist').find('li').each(function (i) {\n                $(this).attr({\n                    'role': 'presentation',\n                    'aria-selected': 'false',\n                    'aria-controls': 'navigation' + _.instanceUid + i + '',\n                    'id': 'slick-slide' + _.instanceUid + i + ''\n                });\n            }).first().attr('aria-selected', 'true').end().find('button').attr('role', 'button').end().closest('div').attr('role', 'toolbar');\n        }\n        _.activateADA();\n    };\n\n    Slick.prototype.initArrowEvents = function () {\n\n        var _ = this;\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n            _.$prevArrow.off('click.slick').on('click.slick', {\n                message: 'previous'\n            }, _.changeSlide);\n            _.$nextArrow.off('click.slick').on('click.slick', {\n                message: 'next'\n            }, _.changeSlide);\n        }\n    };\n\n    Slick.prototype.initDotEvents = function () {\n\n        var _ = this;\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n            $('li', _.$dots).on('click.slick', {\n                message: 'index'\n            }, _.changeSlide);\n        }\n\n        if (_.options.dots === true && _.options.pauseOnDotsHover === true) {\n\n            $('li', _.$dots).on('mouseenter.slick', $.proxy(_.interrupt, _, true)).on('mouseleave.slick', $.proxy(_.interrupt, _, false));\n        }\n    };\n\n    Slick.prototype.initSlideEvents = function () {\n\n        var _ = this;\n\n        if (_.options.pauseOnHover) {\n\n            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));\n            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));\n        }\n    };\n\n    Slick.prototype.initializeEvents = function () {\n\n        var _ = this;\n\n        _.initArrowEvents();\n\n        _.initDotEvents();\n        _.initSlideEvents();\n\n        _.$list.on('touchstart.slick mousedown.slick', {\n            action: 'start'\n        }, _.swipeHandler);\n        _.$list.on('touchmove.slick mousemove.slick', {\n            action: 'move'\n        }, _.swipeHandler);\n        _.$list.on('touchend.slick mouseup.slick', {\n            action: 'end'\n        }, _.swipeHandler);\n        _.$list.on('touchcancel.slick mouseleave.slick', {\n            action: 'end'\n        }, _.swipeHandler);\n\n        _.$list.on('click.slick', _.clickHandler);\n\n        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));\n\n        if (_.options.accessibility === true) {\n            _.$list.on('keydown.slick', _.keyHandler);\n        }\n\n        if (_.options.focusOnSelect === true) {\n            $(_.$slideTrack).children().on('click.slick', _.selectHandler);\n        }\n\n        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));\n\n        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));\n\n        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);\n\n        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);\n        $(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);\n    };\n\n    Slick.prototype.initUI = function () {\n\n        var _ = this;\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$prevArrow.show();\n            _.$nextArrow.show();\n        }\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$dots.show();\n        }\n    };\n\n    Slick.prototype.keyHandler = function (event) {\n\n        var _ = this;\n        //Dont slide if the cursor is inside the form fields and arrow keys are pressed\n        if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {\n            if (event.keyCode === 37 && _.options.accessibility === true) {\n                _.changeSlide({\n                    data: {\n                        message: _.options.rtl === true ? 'next' : 'previous'\n                    }\n                });\n            } else if (event.keyCode === 39 && _.options.accessibility === true) {\n                _.changeSlide({\n                    data: {\n                        message: _.options.rtl === true ? 'previous' : 'next'\n                    }\n                });\n            }\n        }\n    };\n\n    Slick.prototype.lazyLoad = function () {\n\n        var _ = this,\n            loadRange,\n            cloneRange,\n            rangeStart,\n            rangeEnd;\n\n        function loadImages(imagesScope) {\n\n            $('img[data-lazy]', imagesScope).each(function () {\n\n                var image = $(this),\n                    imageSource = $(this).attr('data-lazy'),\n                    imageToLoad = document.createElement('img');\n\n                imageToLoad.onload = function () {\n\n                    image.animate({ opacity: 0 }, 100, function () {\n                        image.attr('src', imageSource).animate({ opacity: 1 }, 200, function () {\n                            image.removeAttr('data-lazy').removeClass('slick-loading');\n                        });\n                        _.$slider.trigger('lazyLoaded', [_, image, imageSource]);\n                    });\n                };\n\n                imageToLoad.onerror = function () {\n\n                    image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');\n\n                    _.$slider.trigger('lazyLoadError', [_, image, imageSource]);\n                };\n\n                imageToLoad.src = imageSource;\n            });\n        }\n\n        if (_.options.centerMode === true) {\n            if (_.options.infinite === true) {\n                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);\n                rangeEnd = rangeStart + _.options.slidesToShow + 2;\n            } else {\n                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));\n                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;\n            }\n        } else {\n            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;\n            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);\n            if (_.options.fade === true) {\n                if (rangeStart > 0) rangeStart--;\n                if (rangeEnd <= _.slideCount) rangeEnd++;\n            }\n        }\n\n        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);\n        loadImages(loadRange);\n\n        if (_.slideCount <= _.options.slidesToShow) {\n            cloneRange = _.$slider.find('.slick-slide');\n            loadImages(cloneRange);\n        } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {\n            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);\n            loadImages(cloneRange);\n        } else if (_.currentSlide === 0) {\n            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);\n            loadImages(cloneRange);\n        }\n    };\n\n    Slick.prototype.loadSlider = function () {\n\n        var _ = this;\n\n        _.setPosition();\n\n        _.$slideTrack.css({\n            opacity: 1\n        });\n\n        _.$slider.removeClass('slick-loading');\n\n        _.initUI();\n\n        if (_.options.lazyLoad === 'progressive') {\n            _.progressiveLazyLoad();\n        }\n    };\n\n    Slick.prototype.next = Slick.prototype.slickNext = function () {\n\n        var _ = this;\n\n        _.changeSlide({\n            data: {\n                message: 'next'\n            }\n        });\n    };\n\n    Slick.prototype.orientationChange = function () {\n\n        var _ = this;\n\n        _.checkResponsive();\n        _.setPosition();\n    };\n\n    Slick.prototype.pause = Slick.prototype.slickPause = function () {\n\n        var _ = this;\n\n        _.autoPlayClear();\n        _.paused = true;\n    };\n\n    Slick.prototype.play = Slick.prototype.slickPlay = function () {\n\n        var _ = this;\n\n        _.autoPlay();\n        _.options.autoplay = true;\n        _.paused = false;\n        _.focussed = false;\n        _.interrupted = false;\n    };\n\n    Slick.prototype.postSlide = function (index) {\n\n        var _ = this;\n\n        if (!_.unslicked) {\n\n            _.$slider.trigger('afterChange', [_, index]);\n\n            _.animating = false;\n\n            _.setPosition();\n\n            _.swipeLeft = null;\n\n            if (_.options.autoplay) {\n                _.autoPlay();\n            }\n\n            if (_.options.accessibility === true) {\n                _.initADA();\n            }\n        }\n    };\n\n    Slick.prototype.prev = Slick.prototype.slickPrev = function () {\n\n        var _ = this;\n\n        _.changeSlide({\n            data: {\n                message: 'previous'\n            }\n        });\n    };\n\n    Slick.prototype.preventDefault = function (event) {\n\n        event.preventDefault();\n    };\n\n    Slick.prototype.progressiveLazyLoad = function (tryCount) {\n\n        tryCount = tryCount || 1;\n\n        var _ = this,\n            $imgsToLoad = $('img[data-lazy]', _.$slider),\n            image,\n            imageSource,\n            imageToLoad;\n\n        if ($imgsToLoad.length) {\n\n            image = $imgsToLoad.first();\n            imageSource = image.attr('data-lazy');\n            imageToLoad = document.createElement('img');\n\n            imageToLoad.onload = function () {\n\n                image.attr('src', imageSource).removeAttr('data-lazy').removeClass('slick-loading');\n\n                if (_.options.adaptiveHeight === true) {\n                    _.setPosition();\n                }\n\n                _.$slider.trigger('lazyLoaded', [_, image, imageSource]);\n                _.progressiveLazyLoad();\n            };\n\n            imageToLoad.onerror = function () {\n\n                if (tryCount < 3) {\n\n                    /**\r\n                     * try to load the image 3 times,\r\n                     * leave a slight delay so we don't get\r\n                     * servers blocking the request.\r\n                     */\n                    setTimeout(function () {\n                        _.progressiveLazyLoad(tryCount + 1);\n                    }, 500);\n                } else {\n\n                    image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');\n\n                    _.$slider.trigger('lazyLoadError', [_, image, imageSource]);\n\n                    _.progressiveLazyLoad();\n                }\n            };\n\n            imageToLoad.src = imageSource;\n        } else {\n\n            _.$slider.trigger('allImagesLoaded', [_]);\n        }\n    };\n\n    Slick.prototype.refresh = function (initializing) {\n\n        var _ = this,\n            currentSlide,\n            lastVisibleIndex;\n\n        lastVisibleIndex = _.slideCount - _.options.slidesToShow;\n\n        // in non-infinite sliders, we don't want to go past the\n        // last visible index.\n        if (!_.options.infinite && _.currentSlide > lastVisibleIndex) {\n            _.currentSlide = lastVisibleIndex;\n        }\n\n        // if less slides than to show, go to start.\n        if (_.slideCount <= _.options.slidesToShow) {\n            _.currentSlide = 0;\n        }\n\n        currentSlide = _.currentSlide;\n\n        _.destroy(true);\n\n        $.extend(_, _.initials, { currentSlide: currentSlide });\n\n        _.init();\n\n        if (!initializing) {\n\n            _.changeSlide({\n                data: {\n                    message: 'index',\n                    index: currentSlide\n                }\n            }, false);\n        }\n    };\n\n    Slick.prototype.registerBreakpoints = function () {\n\n        var _ = this,\n            breakpoint,\n            currentBreakpoint,\n            l,\n            responsiveSettings = _.options.responsive || null;\n\n        if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {\n\n            _.respondTo = _.options.respondTo || 'window';\n\n            for (breakpoint in responsiveSettings) {\n\n                l = _.breakpoints.length - 1;\n                currentBreakpoint = responsiveSettings[breakpoint].breakpoint;\n\n                if (responsiveSettings.hasOwnProperty(breakpoint)) {\n\n                    // loop through the breakpoints and cut out any existing\n                    // ones with the same breakpoint number, we don't want dupes.\n                    while (l >= 0) {\n                        if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {\n                            _.breakpoints.splice(l, 1);\n                        }\n                        l--;\n                    }\n\n                    _.breakpoints.push(currentBreakpoint);\n                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;\n                }\n            }\n\n            _.breakpoints.sort(function (a, b) {\n                return _.options.mobileFirst ? a - b : b - a;\n            });\n        }\n    };\n\n    Slick.prototype.reinit = function () {\n\n        var _ = this;\n\n        _.$slides = _.$slideTrack.children(_.options.slide).addClass('slick-slide');\n\n        _.slideCount = _.$slides.length;\n\n        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {\n            _.currentSlide = _.currentSlide - _.options.slidesToScroll;\n        }\n\n        if (_.slideCount <= _.options.slidesToShow) {\n            _.currentSlide = 0;\n        }\n\n        _.registerBreakpoints();\n\n        _.setProps();\n        _.setupInfinite();\n        _.buildArrows();\n        _.updateArrows();\n        _.initArrowEvents();\n        _.buildDots();\n        _.updateDots();\n        _.initDotEvents();\n        _.cleanUpSlideEvents();\n        _.initSlideEvents();\n\n        _.checkResponsive(false, true);\n\n        if (_.options.focusOnSelect === true) {\n            $(_.$slideTrack).children().on('click.slick', _.selectHandler);\n        }\n\n        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);\n\n        _.setPosition();\n        _.focusHandler();\n\n        _.paused = !_.options.autoplay;\n        _.autoPlay();\n\n        _.$slider.trigger('reInit', [_]);\n    };\n\n    Slick.prototype.resize = function () {\n\n        var _ = this;\n\n        if ($(window).width() !== _.windowWidth) {\n            clearTimeout(_.windowDelay);\n            _.windowDelay = window.setTimeout(function () {\n                _.windowWidth = $(window).width();\n                _.checkResponsive();\n                if (!_.unslicked) {\n                    _.setPosition();\n                }\n            }, 50);\n        }\n    };\n\n    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function (index, removeBefore, removeAll) {\n\n        var _ = this;\n\n        if (typeof index === 'boolean') {\n            removeBefore = index;\n            index = removeBefore === true ? 0 : _.slideCount - 1;\n        } else {\n            index = removeBefore === true ? --index : index;\n        }\n\n        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {\n            return false;\n        }\n\n        _.unload();\n\n        if (removeAll === true) {\n            _.$slideTrack.children().remove();\n        } else {\n            _.$slideTrack.children(this.options.slide).eq(index).remove();\n        }\n\n        _.$slides = _.$slideTrack.children(this.options.slide);\n\n        _.$slideTrack.children(this.options.slide).detach();\n\n        _.$slideTrack.append(_.$slides);\n\n        _.$slidesCache = _.$slides;\n\n        _.reinit();\n    };\n\n    Slick.prototype.setCSS = function (position) {\n\n        var _ = this,\n            positionProps = {},\n            x,\n            y;\n\n        if (_.options.rtl === true) {\n            position = -position;\n        }\n        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';\n        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';\n\n        positionProps[_.positionProp] = position;\n\n        if (_.transformsEnabled === false) {\n            _.$slideTrack.css(positionProps);\n        } else {\n            positionProps = {};\n            if (_.cssTransitions === false) {\n                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';\n                _.$slideTrack.css(positionProps);\n            } else {\n                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';\n                _.$slideTrack.css(positionProps);\n            }\n        }\n    };\n\n    Slick.prototype.setDimensions = function () {\n\n        var _ = this;\n\n        if (_.options.vertical === false) {\n            if (_.options.centerMode === true) {\n                _.$list.css({\n                    padding: '0px ' + _.options.centerPadding\n                });\n            }\n        } else {\n            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);\n            if (_.options.centerMode === true) {\n                _.$list.css({\n                    padding: _.options.centerPadding + ' 0px'\n                });\n            }\n        }\n\n        _.listWidth = _.$list.width();\n        _.listHeight = _.$list.height();\n\n        if (_.options.vertical === false && _.options.variableWidth === false) {\n            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);\n            _.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children('.slick-slide').length));\n        } else if (_.options.variableWidth === true) {\n            _.$slideTrack.width(5000 * _.slideCount);\n        } else {\n            _.slideWidth = Math.ceil(_.listWidth);\n            _.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length));\n        }\n\n        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();\n        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);\n    };\n\n    Slick.prototype.setFade = function () {\n\n        var _ = this,\n            targetLeft;\n\n        _.$slides.each(function (index, element) {\n            targetLeft = _.slideWidth * index * -1;\n            if (_.options.rtl === true) {\n                $(element).css({\n                    position: 'relative',\n                    right: targetLeft,\n                    top: 0,\n                    zIndex: _.options.zIndex - 2,\n                    opacity: 0\n                });\n            } else {\n                $(element).css({\n                    position: 'relative',\n                    left: targetLeft,\n                    top: 0,\n                    zIndex: _.options.zIndex - 2,\n                    opacity: 0\n                });\n            }\n        });\n\n        _.$slides.eq(_.currentSlide).css({\n            zIndex: _.options.zIndex - 1,\n            opacity: 1\n        });\n    };\n\n    Slick.prototype.setHeight = function () {\n\n        var _ = this;\n\n        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {\n            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);\n            _.$list.css('height', targetHeight);\n        }\n    };\n\n    Slick.prototype.setOption = Slick.prototype.slickSetOption = function () {\n\n        /**\r\n         * accepts arguments in format of:\r\n         *\r\n         *  - for changing a single option's value:\r\n         *     .slick(\"setOption\", option, value, refresh )\r\n         *\r\n         *  - for changing a set of responsive options:\r\n         *     .slick(\"setOption\", 'responsive', [{}, ...], refresh )\r\n         *\r\n         *  - for updating multiple values at once (not responsive)\r\n         *     .slick(\"setOption\", { 'option': value, ... }, refresh )\r\n         */\n\n        var _ = this,\n            l,\n            item,\n            option,\n            value,\n            refresh = false,\n            type;\n\n        if ($.type(arguments[0]) === 'object') {\n\n            option = arguments[0];\n            refresh = arguments[1];\n            type = 'multiple';\n        } else if ($.type(arguments[0]) === 'string') {\n\n            option = arguments[0];\n            value = arguments[1];\n            refresh = arguments[2];\n\n            if (arguments[0] === 'responsive' && $.type(arguments[1]) === 'array') {\n\n                type = 'responsive';\n            } else if (typeof arguments[1] !== 'undefined') {\n\n                type = 'single';\n            }\n        }\n\n        if (type === 'single') {\n\n            _.options[option] = value;\n        } else if (type === 'multiple') {\n\n            $.each(option, function (opt, val) {\n\n                _.options[opt] = val;\n            });\n        } else if (type === 'responsive') {\n\n            for (item in value) {\n\n                if ($.type(_.options.responsive) !== 'array') {\n\n                    _.options.responsive = [value[item]];\n                } else {\n\n                    l = _.options.responsive.length - 1;\n\n                    // loop through the responsive object and splice out duplicates.\n                    while (l >= 0) {\n\n                        if (_.options.responsive[l].breakpoint === value[item].breakpoint) {\n\n                            _.options.responsive.splice(l, 1);\n                        }\n\n                        l--;\n                    }\n\n                    _.options.responsive.push(value[item]);\n                }\n            }\n        }\n\n        if (refresh) {\n\n            _.unload();\n            _.reinit();\n        }\n    };\n\n    Slick.prototype.setPosition = function () {\n\n        var _ = this;\n\n        _.setDimensions();\n\n        _.setHeight();\n\n        if (_.options.fade === false) {\n            _.setCSS(_.getLeft(_.currentSlide));\n        } else {\n            _.setFade();\n        }\n\n        _.$slider.trigger('setPosition', [_]);\n    };\n\n    Slick.prototype.setProps = function () {\n\n        var _ = this,\n            bodyStyle = document.body.style;\n\n        _.positionProp = _.options.vertical === true ? 'top' : 'left';\n\n        if (_.positionProp === 'top') {\n            _.$slider.addClass('slick-vertical');\n        } else {\n            _.$slider.removeClass('slick-vertical');\n        }\n\n        if (bodyStyle.WebkitTransition !== undefined || bodyStyle.MozTransition !== undefined || bodyStyle.msTransition !== undefined) {\n            if (_.options.useCSS === true) {\n                _.cssTransitions = true;\n            }\n        }\n\n        if (_.options.fade) {\n            if (typeof _.options.zIndex === 'number') {\n                if (_.options.zIndex < 3) {\n                    _.options.zIndex = 3;\n                }\n            } else {\n                _.options.zIndex = _.defaults.zIndex;\n            }\n        }\n\n        if (bodyStyle.OTransform !== undefined) {\n            _.animType = 'OTransform';\n            _.transformType = '-o-transform';\n            _.transitionType = 'OTransition';\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;\n        }\n        if (bodyStyle.MozTransform !== undefined) {\n            _.animType = 'MozTransform';\n            _.transformType = '-moz-transform';\n            _.transitionType = 'MozTransition';\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;\n        }\n        if (bodyStyle.webkitTransform !== undefined) {\n            _.animType = 'webkitTransform';\n            _.transformType = '-webkit-transform';\n            _.transitionType = 'webkitTransition';\n            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;\n        }\n        if (bodyStyle.msTransform !== undefined) {\n            _.animType = 'msTransform';\n            _.transformType = '-ms-transform';\n            _.transitionType = 'msTransition';\n            if (bodyStyle.msTransform === undefined) _.animType = false;\n        }\n        if (bodyStyle.transform !== undefined && _.animType !== false) {\n            _.animType = 'transform';\n            _.transformType = 'transform';\n            _.transitionType = 'transition';\n        }\n        _.transformsEnabled = _.options.useTransform && _.animType !== null && _.animType !== false;\n    };\n\n    Slick.prototype.setSlideClasses = function (index) {\n\n        var _ = this,\n            centerOffset,\n            allSlides,\n            indexOffset,\n            remainder;\n\n        allSlides = _.$slider.find('.slick-slide').removeClass('slick-active slick-center slick-current').attr('aria-hidden', 'true');\n\n        _.$slides.eq(index).addClass('slick-current');\n\n        if (_.options.centerMode === true) {\n\n            centerOffset = Math.floor(_.options.slidesToShow / 2);\n\n            if (_.options.infinite === true) {\n\n                if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) {\n\n                    _.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass('slick-active').attr('aria-hidden', 'false');\n                } else {\n\n                    indexOffset = _.options.slidesToShow + index;\n                    allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass('slick-active').attr('aria-hidden', 'false');\n                }\n\n                if (index === 0) {\n\n                    allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slick-center');\n                } else if (index === _.slideCount - 1) {\n\n                    allSlides.eq(_.options.slidesToShow).addClass('slick-center');\n                }\n            }\n\n            _.$slides.eq(index).addClass('slick-center');\n        } else {\n\n            if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) {\n\n                _.$slides.slice(index, index + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');\n            } else if (allSlides.length <= _.options.slidesToShow) {\n\n                allSlides.addClass('slick-active').attr('aria-hidden', 'false');\n            } else {\n\n                remainder = _.slideCount % _.options.slidesToShow;\n                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;\n\n                if (_.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow) {\n\n                    allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass('slick-active').attr('aria-hidden', 'false');\n                } else {\n\n                    allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');\n                }\n            }\n        }\n\n        if (_.options.lazyLoad === 'ondemand') {\n            _.lazyLoad();\n        }\n    };\n\n    Slick.prototype.setupInfinite = function () {\n\n        var _ = this,\n            i,\n            slideIndex,\n            infiniteCount;\n\n        if (_.options.fade === true) {\n            _.options.centerMode = false;\n        }\n\n        if (_.options.infinite === true && _.options.fade === false) {\n\n            slideIndex = null;\n\n            if (_.slideCount > _.options.slidesToShow) {\n\n                if (_.options.centerMode === true) {\n                    infiniteCount = _.options.slidesToShow + 1;\n                } else {\n                    infiniteCount = _.options.slidesToShow;\n                }\n\n                for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {\n                    slideIndex = i - 1;\n                    $(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass('slick-cloned');\n                }\n                for (i = 0; i < infiniteCount; i += 1) {\n                    slideIndex = i;\n                    $(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass('slick-cloned');\n                }\n                _.$slideTrack.find('.slick-cloned').find('[id]').each(function () {\n                    $(this).attr('id', '');\n                });\n            }\n        }\n    };\n\n    Slick.prototype.interrupt = function (toggle) {\n\n        var _ = this;\n\n        if (!toggle) {\n            _.autoPlay();\n        }\n        _.interrupted = toggle;\n    };\n\n    Slick.prototype.selectHandler = function (event) {\n\n        var _ = this;\n\n        var targetElement = $(event.target).is('.slick-slide') ? $(event.target) : $(event.target).parents('.slick-slide');\n\n        var index = parseInt(targetElement.attr('data-slick-index'));\n\n        if (!index) index = 0;\n\n        if (_.slideCount <= _.options.slidesToShow) {\n\n            _.setSlideClasses(index);\n            _.asNavFor(index);\n            return;\n        }\n\n        _.slideHandler(index);\n    };\n\n    Slick.prototype.slideHandler = function (index, sync, dontAnimate) {\n\n        var targetSlide,\n            animSlide,\n            oldSlide,\n            slideLeft,\n            targetLeft = null,\n            _ = this,\n            navTarget;\n\n        sync = sync || false;\n\n        if (_.animating === true && _.options.waitForAnimate === true) {\n            return;\n        }\n\n        if (_.options.fade === true && _.currentSlide === index) {\n            return;\n        }\n\n        if (_.slideCount <= _.options.slidesToShow) {\n            return;\n        }\n\n        if (sync === false) {\n            _.asNavFor(index);\n        }\n\n        targetSlide = index;\n        targetLeft = _.getLeft(targetSlide);\n        slideLeft = _.getLeft(_.currentSlide);\n\n        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;\n\n        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {\n            if (_.options.fade === false) {\n                targetSlide = _.currentSlide;\n                if (dontAnimate !== true) {\n                    _.animateSlide(slideLeft, function () {\n                        _.postSlide(targetSlide);\n                    });\n                } else {\n                    _.postSlide(targetSlide);\n                }\n            }\n            return;\n        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > _.slideCount - _.options.slidesToScroll)) {\n            if (_.options.fade === false) {\n                targetSlide = _.currentSlide;\n                if (dontAnimate !== true) {\n                    _.animateSlide(slideLeft, function () {\n                        _.postSlide(targetSlide);\n                    });\n                } else {\n                    _.postSlide(targetSlide);\n                }\n            }\n            return;\n        }\n\n        if (_.options.autoplay) {\n            clearInterval(_.autoPlayTimer);\n        }\n\n        if (targetSlide < 0) {\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\n                animSlide = _.slideCount - _.slideCount % _.options.slidesToScroll;\n            } else {\n                animSlide = _.slideCount + targetSlide;\n            }\n        } else if (targetSlide >= _.slideCount) {\n            if (_.slideCount % _.options.slidesToScroll !== 0) {\n                animSlide = 0;\n            } else {\n                animSlide = targetSlide - _.slideCount;\n            }\n        } else {\n            animSlide = targetSlide;\n        }\n\n        _.animating = true;\n\n        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);\n\n        oldSlide = _.currentSlide;\n        _.currentSlide = animSlide;\n\n        _.setSlideClasses(_.currentSlide);\n\n        if (_.options.asNavFor) {\n\n            navTarget = _.getNavTarget();\n            navTarget = navTarget.slick('getSlick');\n\n            if (navTarget.slideCount <= navTarget.options.slidesToShow) {\n                navTarget.setSlideClasses(_.currentSlide);\n            }\n        }\n\n        _.updateDots();\n        _.updateArrows();\n\n        if (_.options.fade === true) {\n            if (dontAnimate !== true) {\n\n                _.fadeSlideOut(oldSlide);\n\n                _.fadeSlide(animSlide, function () {\n                    _.postSlide(animSlide);\n                });\n            } else {\n                _.postSlide(animSlide);\n            }\n            _.animateHeight();\n            return;\n        }\n\n        if (dontAnimate !== true) {\n            _.animateSlide(targetLeft, function () {\n                _.postSlide(animSlide);\n            });\n        } else {\n            _.postSlide(animSlide);\n        }\n    };\n\n    Slick.prototype.startLoad = function () {\n\n        var _ = this;\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$prevArrow.hide();\n            _.$nextArrow.hide();\n        }\n\n        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {\n\n            _.$dots.hide();\n        }\n\n        _.$slider.addClass('slick-loading');\n    };\n\n    Slick.prototype.swipeDirection = function () {\n\n        var xDist,\n            yDist,\n            r,\n            swipeAngle,\n            _ = this;\n\n        xDist = _.touchObject.startX - _.touchObject.curX;\n        yDist = _.touchObject.startY - _.touchObject.curY;\n        r = Math.atan2(yDist, xDist);\n\n        swipeAngle = Math.round(r * 180 / Math.PI);\n        if (swipeAngle < 0) {\n            swipeAngle = 360 - Math.abs(swipeAngle);\n        }\n\n        if (swipeAngle <= 45 && swipeAngle >= 0) {\n            return _.options.rtl === false ? 'left' : 'right';\n        }\n        if (swipeAngle <= 360 && swipeAngle >= 315) {\n            return _.options.rtl === false ? 'left' : 'right';\n        }\n        if (swipeAngle >= 135 && swipeAngle <= 225) {\n            return _.options.rtl === false ? 'right' : 'left';\n        }\n        if (_.options.verticalSwiping === true) {\n            if (swipeAngle >= 35 && swipeAngle <= 135) {\n                return 'down';\n            } else {\n                return 'up';\n            }\n        }\n\n        return 'vertical';\n    };\n\n    Slick.prototype.swipeEnd = function (event) {\n\n        var _ = this,\n            slideCount,\n            direction;\n\n        _.dragging = false;\n        _.interrupted = false;\n        _.shouldClick = _.touchObject.swipeLength > 10 ? false : true;\n\n        if (_.touchObject.curX === undefined) {\n            return false;\n        }\n\n        if (_.touchObject.edgeHit === true) {\n            _.$slider.trigger('edge', [_, _.swipeDirection()]);\n        }\n\n        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {\n\n            direction = _.swipeDirection();\n\n            switch (direction) {\n\n                case 'left':\n                case 'down':\n\n                    slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();\n\n                    _.currentDirection = 0;\n\n                    break;\n\n                case 'right':\n                case 'up':\n\n                    slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();\n\n                    _.currentDirection = 1;\n\n                    break;\n\n                default:\n\n            }\n\n            if (direction != 'vertical') {\n\n                _.slideHandler(slideCount);\n                _.touchObject = {};\n                _.$slider.trigger('swipe', [_, direction]);\n            }\n        } else {\n\n            if (_.touchObject.startX !== _.touchObject.curX) {\n\n                _.slideHandler(_.currentSlide);\n                _.touchObject = {};\n            }\n        }\n    };\n\n    Slick.prototype.swipeHandler = function (event) {\n\n        var _ = this;\n\n        if (_.options.swipe === false || 'ontouchend' in document && _.options.swipe === false) {\n            return;\n        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {\n            return;\n        }\n\n        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ? event.originalEvent.touches.length : 1;\n\n        _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;\n\n        if (_.options.verticalSwiping === true) {\n            _.touchObject.minSwipe = _.listHeight / _.options.touchThreshold;\n        }\n\n        switch (event.data.action) {\n\n            case 'start':\n                _.swipeStart(event);\n                break;\n\n            case 'move':\n                _.swipeMove(event);\n                break;\n\n            case 'end':\n                _.swipeEnd(event);\n                break;\n\n        }\n    };\n\n    Slick.prototype.swipeMove = function (event) {\n\n        var _ = this,\n            edgeWasHit = false,\n            curLeft,\n            swipeDirection,\n            swipeLength,\n            positionOffset,\n            touches;\n\n        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;\n\n        if (!_.dragging || touches && touches.length !== 1) {\n            return false;\n        }\n\n        curLeft = _.getLeft(_.currentSlide);\n\n        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;\n        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;\n\n        _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));\n\n        if (_.options.verticalSwiping === true) {\n            _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));\n        }\n\n        swipeDirection = _.swipeDirection();\n\n        if (swipeDirection === 'vertical') {\n            return;\n        }\n\n        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {\n            event.preventDefault();\n        }\n\n        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);\n        if (_.options.verticalSwiping === true) {\n            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;\n        }\n\n        swipeLength = _.touchObject.swipeLength;\n\n        _.touchObject.edgeHit = false;\n\n        if (_.options.infinite === false) {\n            if (_.currentSlide === 0 && swipeDirection === 'right' || _.currentSlide >= _.getDotCount() && swipeDirection === 'left') {\n                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;\n                _.touchObject.edgeHit = true;\n            }\n        }\n\n        if (_.options.vertical === false) {\n            _.swipeLeft = curLeft + swipeLength * positionOffset;\n        } else {\n            _.swipeLeft = curLeft + swipeLength * (_.$list.height() / _.listWidth) * positionOffset;\n        }\n        if (_.options.verticalSwiping === true) {\n            _.swipeLeft = curLeft + swipeLength * positionOffset;\n        }\n\n        if (_.options.fade === true || _.options.touchMove === false) {\n            return false;\n        }\n\n        if (_.animating === true) {\n            _.swipeLeft = null;\n            return false;\n        }\n\n        _.setCSS(_.swipeLeft);\n    };\n\n    Slick.prototype.swipeStart = function (event) {\n\n        var _ = this,\n            touches;\n\n        _.interrupted = true;\n\n        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {\n            _.touchObject = {};\n            return false;\n        }\n\n        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {\n            touches = event.originalEvent.touches[0];\n        }\n\n        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;\n        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;\n\n        _.dragging = true;\n    };\n\n    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function () {\n\n        var _ = this;\n\n        if (_.$slidesCache !== null) {\n\n            _.unload();\n\n            _.$slideTrack.children(this.options.slide).detach();\n\n            _.$slidesCache.appendTo(_.$slideTrack);\n\n            _.reinit();\n        }\n    };\n\n    Slick.prototype.unload = function () {\n\n        var _ = this;\n\n        $('.slick-cloned', _.$slider).remove();\n\n        if (_.$dots) {\n            _.$dots.remove();\n        }\n\n        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {\n            _.$prevArrow.remove();\n        }\n\n        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {\n            _.$nextArrow.remove();\n        }\n\n        _.$slides.removeClass('slick-slide slick-active slick-visible slick-current').attr('aria-hidden', 'true').css('width', '');\n    };\n\n    Slick.prototype.unslick = function (fromBreakpoint) {\n\n        var _ = this;\n        _.$slider.trigger('unslick', [_, fromBreakpoint]);\n        _.destroy();\n    };\n\n    Slick.prototype.updateArrows = function () {\n\n        var _ = this,\n            centerOffset;\n\n        centerOffset = Math.floor(_.options.slidesToShow / 2);\n\n        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow && !_.options.infinite) {\n\n            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n\n            if (_.currentSlide === 0) {\n\n                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\n                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {\n\n                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\n                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {\n\n                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');\n                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');\n            }\n        }\n    };\n\n    Slick.prototype.updateDots = function () {\n\n        var _ = this;\n\n        if (_.$dots !== null) {\n\n            _.$dots.find('li').removeClass('slick-active').attr('aria-hidden', 'true');\n\n            _.$dots.find('li').eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass('slick-active').attr('aria-hidden', 'false');\n        }\n    };\n\n    Slick.prototype.visibility = function () {\n\n        var _ = this;\n\n        if (_.options.autoplay) {\n\n            if (document[_.hidden]) {\n\n                _.interrupted = true;\n            } else {\n\n                _.interrupted = false;\n            }\n        }\n    };\n\n    $.fn.slick = function () {\n        var _ = this,\n            opt = arguments[0],\n            args = Array.prototype.slice.call(arguments, 1),\n            l = _.length,\n            i,\n            ret;\n        for (i = 0; i < l; i++) {\n            if ((typeof opt === 'undefined' ? 'undefined' : _typeof(opt)) == 'object' || typeof opt == 'undefined') _[i].slick = new Slick(_[i], opt);else ret = _[i].slick[opt].apply(_[i].slick, args);\n            if (typeof ret != 'undefined') return ret;\n        }\n        return _;\n    };\n});\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/assets/js/partials/carousel.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/assets/js/partials/control.js":
/*!******************************************************************!*\
  !*** ./wp-content/themes/wappsnet/assets/js/partials/control.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($, Materialize) {\n\nvar Control = {\n    ajaxUrl: window.location.origin + '/wp-admin/admin-ajax.php',\n\n    poster: function poster(data, successCallback, failCallback) {\n        data = $.param(data);\n\n        $.post(this.ajaxUrl, data, function (response) {\n            if (response) {\n                var responseData = response;\n                try {\n                    responseData = JSON.parse(response);\n                } catch (e) {}\n                successCallback(responseData);\n            } else {\n                if (typeof failCallback === 'function') {\n                    failCallback(response);\n                } else {\n                    Materialize.toast('Server Error!', 5000);\n                }\n            }\n        });\n    },\n\n    uploader: function uploader(data, successCallback, failCallback) {\n        $.ajax({\n            method: \"POST\",\n            url: this.ajaxUrl,\n            dataType: \"json\",\n            contentType: false,\n            processData: false,\n            data: data,\n\n            success: function success(response) {\n                try {\n                    successCallback(JSON.parse(response));\n                } catch (e) {\n                    successCallback(response);\n                }\n            },\n\n            error: function error(response) {\n                failCallback(response);\n            }\n        });\n    },\n\n    request: function request(data, successCallback, failCallback) {\n        $.ajax({\n            method: 'POST',\n            url: this.ajaxUrl,\n            dataType: 'html',\n            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',\n            data: data,\n\n            success: function success(response) {\n                try {\n                    successCallback(JSON.parse(response));\n                } catch (e) {\n                    successCallback(response);\n                }\n            },\n\n            error: function error(response) {\n                try {\n                    failCallback(JSON.parse(response));\n                } catch (e) {\n                    failCallback(response);\n                }\n            }\n        });\n    }\n};\n\nmodule.exports = Control;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! ./wp-content/themes/wappsnet/assets/js/partials/materialize.js */ \"./wp-content/themes/wappsnet/assets/js/partials/materialize.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/assets/js/partials/control.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/assets/js/partials/cores.js":
/*!****************************************************************!*\
  !*** ./wp-content/themes/wappsnet/assets/js/partials/cores.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar AppCore = {\n    Random: {\n        used: [],\n        possible: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n\n        make: function make(length) {\n            length = length || 5;\n            var randomString = \"\";\n            for (var i = 0; i < length; i++) {\n                randomString += AppCore.Random.possible.charAt(Math.floor(Math.random() * AppCore.Random.possible.length));\n            }\n            if (AppCore.Random.possible.indexOf(randomString) === -1) {\n                AppCore.Random.used.push(randomString);\n                return randomString;\n            } else {\n                return AppCore.Random.make();\n            }\n        },\n\n        int: function int(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        },\n        float: function float(min, max) {\n            return Math.random() * (max - min) + min;\n        }\n    },\n\n    createScript: function createScript(src, htmlId, removeIfExist, options) {\n        if (removeIfExist) {\n            var oldScript = document.getElementById(htmlId);\n            oldScript.parentNode.removeChild(oldScript);\n        }\n\n        var script = document.createElement('script');\n        script.src = src;\n        if (htmlId) {\n            script.id = htmlId;\n        }\n\n        if (options !== undefined && options.onLoad !== undefined) {\n            script.onload = function () {\n                AppCore.executeFunctionByName(options.onLoad, window);\n            };\n        }\n\n        script.type = \"text/javascript\";\n        document.getElementsByTagName('head')[0].appendChild(script);\n    },\n\n    cloneObject: function cloneObject(object) {\n        if (Array.isArray(object)) {\n            return Object.assign([], object);\n        } else if ((typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) === 'object') {\n            return Object.assign({}, object);\n        } else {\n            return object;\n        }\n    },\n\n    executeFunctionByName: function executeFunctionByName(functionName, context /*, args */) {\n        var args = [].slice.call(arguments).splice(2);\n        var namespaces = functionName.split(\".\");\n        var func = namespaces.pop();\n        var len = namespaces.length;\n        for (var i = 0; i < len; i++) {\n            context = context[namespaces[i]];\n        }\n        return context[func].apply(context, args);\n    },\n\n    findFunctionFromDom: function findFunctionFromDom(functionName, context) {\n        var namespaces = functionName.split(\".\");\n        var func = namespaces.pop();\n        var len = namespaces.length;\n        for (var i = 0; i < len; i++) {\n            context = context[namespaces[i]];\n        }\n        return context[func];\n    },\n\n    /*\r\n     * remove value from array by value\r\n     * @arr - array\r\n     * @val value\r\n     * */\n    removeFromArrayByValue: function removeFromArrayByValue(arr, val) {\n        var index = arr.indexOf(val);\n        if (index > -1) {\n            arr.splice(index, 1);\n        }\n    },\n\n    createNumbersArray: function createNumbersArray(min, max, step) {\n        var newArray = [];\n        var len = max + 1;\n        for (var i = min; i < len; i = i + step) {\n            newArray.push(i);\n        }\n        return newArray;\n    },\n\n    getKeyByValue: function getKeyByValue(object, value, objectKey) {\n        for (var key in object) {\n            if (typeof objectKey == \"undefined\") {\n                if (object[key] == value) {\n                    return key;\n                }\n            } else {\n                if (object[key][objectKey] == value) {\n                    return key;\n                }\n            }\n        }\n        return false;\n    },\n\n    createArrayByLength: function createArrayByLength(length) {\n        return Array.apply(null, { length: length }).map(Number.call, Number);\n    },\n\n    getAverageRGB: function getAverageRGB(imgEl) {\n        var blockSize = 5,\n            // only visit every 5 pixels\n        defaultRGB = { r: 0, g: 0, b: 0 },\n            // for non-supporting envs\n        canvas = document.createElement('canvas');\n        var context = canvas.getContext && canvas.getContext('2d');\n\n        var data = void 0,\n            width = void 0,\n            height = void 0,\n            length = void 0,\n            i = -4,\n            rgb = { r: 0, g: 0, b: 0 },\n            count = 0;\n\n        if (!context) {\n            return defaultRGB;\n        }\n\n        height = canvas.height = imgEl.naturalHeight || imgEl.offsetHeight || imgEl.height;\n        width = canvas.width = imgEl.naturalWidth || imgEl.offsetWidth || imgEl.width;\n\n        context.drawImage(imgEl.embed, 0, 0);\n\n        try {\n            data = context.getImageData(0, 0, width, height);\n        } catch (e) {\n            /* security error, img on diff domain */\n            return defaultRGB;\n        }\n\n        length = data.data.length;\n\n        while ((i += blockSize * 4) < length) {\n            ++count;\n            rgb.r += data.data[i];\n            rgb.g += data.data[i + 1];\n            rgb.b += data.data[i + 2];\n        }\n\n        // ~~ used to floor values\n        rgb.r = ~~(rgb.r / count);\n        rgb.g = ~~(rgb.g / count);\n        rgb.b = ~~(rgb.b / count);\n        return rgb;\n    },\n\n    getAbsolutePos: function getAbsolutePos(element, all) {\n        var position = element.getBoundingClientRect();\n        if (typeof all === 'undefined' || !all) {\n            return {\n                x: position.left,\n                y: position.top\n            };\n        } else {\n            return position;\n        }\n    },\n\n    getPosition: function getPosition(el) {\n        var xPos = 0,\n            yPos = 0,\n            width = el.offsetWidth,\n            height = el.offsetHeight,\n            parentCount = 0,\n            points = {},\n            element = el;\n\n        while (el) {\n            if (el.tagName == \"BODY\") {\n                // deal with browser quirks with body/window/document and page scroll\n                var xScroll = el.scrollLeft || document.documentElement.scrollLeft;\n                var yScroll = el.scrollTop || document.documentElement.scrollTop;\n\n                xPos += el.offsetLeft - xScroll + el.clientLeft;\n                yPos += el.offsetTop - yScroll + el.clientTop;\n            } else {\n                // for all other non-BODY elements\n                xPos += el.offsetLeft - el.scrollLeft + el.clientLeft;\n                yPos += el.offsetTop - el.scrollTop + el.clientTop;\n            }\n\n            parentCount += 1;\n            if (parentCount >= 2) {\n                break;\n            }\n            el = el.offsetParent;\n        }\n\n        //if hierarchical structure is very large count with clientRect\n        if (parentCount >= 2) {\n            points = AppCore.getAbsolutePos(element, true);\n        } else {\n            var documentWidth = document.body.offsetWidth,\n                documentHeight = document.body.offsetHeight;\n            var right = documentWidth - xPos,\n                bottom = documentHeight - yPos;\n\n            points = {\n                left: xPos,\n                top: yPos,\n                right: right,\n                bottom: bottom,\n                width: width,\n                height: height\n            };\n        }\n\n        return points;\n    },\n\n    circularMotionByNode: function circularMotionByNode(fromElem, toElem, options) {\n        var fromPosition = AppCore.getAbsolutePos(fromElem);\n        var toPosition = AppCore.getAbsolutePos(toElem);\n\n        AppCore.circularMotionByPos(fromPosition, toPosition, options);\n    },\n\n    /**\r\n     * curvilinear motion iteration\r\n     * @param fromPosition - pos from where motion start\r\n     * @param toPosition - pos on which motion end\r\n     * @param options - object {\r\n     * count: \"iterations count\",\r\n      * delay: \"animation delay in ms\",\r\n      * variation: \"middlePos variation 0-2\",\r\n      * className: motion element class\r\n      * image: motion element image\r\n      * }\r\n     */\n    circularMotionByPos: function circularMotionByPos(fromPosition, toPosition, options) {\n        //motion options\n        var counter = 0;\n        var itCount = options.count || 100;\n        var increase = 1 / itCount;\n        var delay = options.delay || 500;\n        var interval = delay / itCount;\n        var scaleAble = options.scaleAble || \"disable\";\n        var blinkAble = options.blinkAble || \"enable\";\n        var variationX = options.variationX || 1;\n        var variationY = options.variationY || 0.5;\n\n        //calculate 3 points coordinates\n        var distanceToX = toPosition.x - fromPosition.x;\n        var distanceToY = toPosition.y - fromPosition.y;\n        var middlePosX = fromPosition.x + distanceToX * variationX;\n        var middlePosY = fromPosition.y + distanceToY * variationY;\n        var middlePosition = { x: middlePosX, y: middlePosY };\n\n        var newElement = undefined;\n        if (options.element === undefined) {\n            //create motioning element\n            newElement = document.createElement(\"div\");\n            newElement.style.top = fromPosition.y + \"px\";\n            newElement.style.left = fromPosition.x + \"px\";\n            newElement.classList.add(\"motion-element\");\n            newElement.classList.add(\"g-bright150\");\n        } else {\n            newElement = options.element;\n        }\n\n        if (options.hasOwnProperty(\"className\")) {\n            options.className.map(function (value) {\n                newElement.classList.add(value);\n            });\n        }\n\n        if (options.hasOwnProperty(\"image\")) {\n            newElement.style.backgroundImage = \"url(\" + options.image + \")\";\n            newElement.classList.add(\"motion-image\");\n        }\n\n        if (options.hasOwnProperty(\"icon\")) {\n            newElement.innerHTML = '<i class=\"fa fa-' + options.icon + '\"></i>';\n        }\n\n        document.body.appendChild(newElement);\n\n        if (options.hasOwnProperty(\"content\")) {\n            newElement.appendChild(options.content);\n        }\n\n        var newOptions = {\n            itCount: itCount,\n            increase: increase,\n            delay: delay,\n            interval: interval,\n            scaleAble: scaleAble,\n            blinkAble: blinkAble,\n            endNode: options.endNode,\n            variationX: variationX,\n            variationY: variationY\n        };\n\n        var newPositions = {\n            x1: fromPosition.x,\n            y1: fromPosition.y,\n            x2: middlePosition.x,\n            y2: middlePosition.y,\n            x3: toPosition.x,\n            y3: toPosition.y\n        };\n\n        this.motionIterator(newElement, newOptions, counter, newPositions);\n    },\n\n    motionIterator: function motionIterator(newElement, options, counter, positions) {\n        var intervalTimer = setInterval(function () {\n            if (counter >= 1) {\n                newElement.classList.add(\"motion-hide\");\n\n                if (options.endNode !== undefined) {\n                    options.endNode.classList.add(\"primary-z\");\n                    if (options.blinkAble == \"enable\") {\n                        AppCore.animate(options.endNode, 1, 70, \"blinkBright\");\n                    }\n                }\n\n                setTimeout(function () {\n                    if (options.endNode !== undefined) {\n                        options.endNode.classList.remove(\"primary-z\");\n                    }\n\n                    if (newElement && newElement.parentNode) {\n                        newElement.parentNode.removeChild(newElement);\n                    }\n                }, 300);\n\n                clearInterval(intervalTimer);\n            }\n\n            counter += options.increase;\n\n            var newX = Math.pow(1 - counter, 2) * positions.x1 + 2 * (1 - counter) * counter * positions.x2 + Math.pow(counter, 2) * positions.x3;\n            var newY = Math.pow(1 - counter, 2) * positions.y1 + 2 * (1 - counter) * counter * positions.y2 + Math.pow(counter, 2) * positions.y3;\n\n            newElement.style.left = newX + \"px\";\n            newElement.style.top = newY + \"px\";\n\n            if (options.scaleAble == \"enable\" && counter >= 0.5) {\n\n                var distanceToX = positions.x3 - newX;\n                var distanceToY = positions.y3 - newY;\n                var middlePosX = newX + distanceToX * options.variationX;\n                var middlePosY = newY + distanceToY * options.variationY;\n\n                var newPositions = {\n                    x1: newX,\n                    y1: newY,\n                    x2: middlePosX,\n                    y2: middlePosY,\n                    x3: positions.x3,\n                    y3: positions.y3\n                };\n\n                var newOptions = options;\n                newOptions.scaleAble = false;\n                newOptions.interval = options.interval / 2;\n\n                setTimeout(function () {\n                    AppCore.motionIterator(newElement, newOptions, counter, newPositions);\n                }, 100);\n\n                AppCore.animate(newElement, 1, 300, \"blinkBright\");\n                clearInterval(intervalTimer);\n            }\n        }, options.interval);\n    },\n\n    animate: function animate(element, count, duration, name) {\n        var animationElement = element;\n        var animateDuration = count * duration;\n        animationElement.style.animationName = name;\n        animationElement.style.animationDuration = duration + \"ms\";\n        animationElement.style.animationIterationCount = count;\n\n        setTimeout(function () {\n            animationElement.style.animationName = null;\n            animationElement.style.animationDuration = null;\n            animationElement.style.animationIterationCount = null;\n        }, animateDuration);\n    },\n\n    filterByLatCyr: function filterByLatCyr(string, from, to) {\n        var language = {\n            ru: ['а', 'б', 'в', 'г', 'д', 'e', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ь', 'ю', 'я', 'А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ь', 'Ю', 'Я'],\n\n            us: ['a', 'b', 'v', 'g', 'd', 'e', 'zh', 'z', 'i', 'y', 'k', 'l', 'm', 'n', 'o', 'p', 'r', 's', 't', 'u', 'f', 'h', 'ts', 'ch', 'sh', 'sht', 'a', 'y', 'yu', 'ya', 'A', 'B', 'V', 'G', 'D', 'E', 'Zh', 'Z', 'I', 'Y', 'K', 'L', 'M', 'N', 'O', 'P', 'R', 'S', 'T', 'U', 'F', 'H', 'Ts', 'Ch', 'Sh', 'Sht', 'A', 'Y', 'Yu', 'Ya']\n        };\n\n        var search = string;\n\n        for (var i = 0; i < language[from].length; i++) {\n            search = search.replace(new RegExp(language[from][i], \"g\"), language[to][i]);\n        }\n\n        return search;\n    },\n\n    addListener: function addListener(eventType, eventFunction, node) {\n        var nodeElement = node || document;\n        if (nodeElement.addEventListener) {\n            nodeElement.addEventListener(eventType, eventFunction);\n        } else {\n            nodeElement.attachEvent(eventType, eventFunction);\n        }\n    },\n\n    deleteListener: function deleteListener(eventType, eventFunction, node) {\n        var nodeElement = node || document;\n        nodeElement.removeEventListener(eventType, eventFunction);\n    },\n\n    removeXhrMessages: function removeXhrMessages(className) {\n        var existMessages = document.getElementsByClassName(className);\n\n        for (var i = 0; i < existMessages.length; i++) {\n            existMessages[i].parentNode.removeChild(existMessages[i]);\n        }\n    },\n\n    createXhrMessages: function createXhrMessages(message, className, error) {\n        var messageBlock = document.createElement('div');\n        messageBlock.classList.add(className);\n\n        if (error) {\n            messageBlock.classList.add(error);\n        }\n\n        messageBlock.innerHTML = message;\n        return messageBlock;\n    },\n\n    scrollToNode: function scrollToNode(scrollNode) {\n        var scrollPoint = scrollNode.offset().top - 70;\n        $('html, body').animate({ scrollTop: scrollPoint }, 300);\n    }\n};\n\nexports.default = AppCore;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/assets/js/partials/cores.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/assets/js/partials/main.js":
/*!***************************************************************!*\
  !*** ./wp-content/themes/wappsnet/assets/js/partials/main.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(jQuery, PubSub) {\n\n__webpack_require__(/*! ./carousel.js */ \"./wp-content/themes/wappsnet/assets/js/partials/carousel.js\");\n\n(function ($, PubSub) {\n    $(document).ready(function (e) {\n        PubSub.publish('document.ready', e);\n    });\n\n    $(window).on('load', function (e) {\n        PubSub.publish('window.load', e);\n    });\n\n    $(window).on('resize', function (e) {\n        PubSub.publish('window.resize', e);\n    });\n\n    $(window).on('scroll', function (e) {\n        PubSub.publish('window.scroll', e);\n    });\n})(jQuery, PubSub);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/assets/js/partials/main.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/assets/js/partials/materialize.js":
/*!**********************************************************************!*\
  !*** ./wp-content/themes/wappsnet/assets/js/partials/materialize.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($, __webpack_provided_window_dot_jQuery, module, Materialize) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nif (typeof jQuery === 'undefined') {\n    var jQuery;\n    // Check if require is a defined function.\n    if (true) {\n        jQuery = $ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n        // Else use the dollar sign alias.\n    } else {}\n}\n\njQuery.easing['jswing'] = jQuery.easing['swing'];\n\njQuery.extend(jQuery.easing, {\n    def: 'easeOutQuad',\n    swing: function swing(x, t, b, c, d) {\n        //alert(jQuery.easing.default);\n        return jQuery.easing[jQuery.easing.def](x, t, b, c, d);\n    },\n    easeInQuad: function easeInQuad(x, t, b, c, d) {\n        return c * (t /= d) * t + b;\n    },\n    easeOutQuad: function easeOutQuad(x, t, b, c, d) {\n        return -c * (t /= d) * (t - 2) + b;\n    },\n    easeInOutQuad: function easeInOutQuad(x, t, b, c, d) {\n        if ((t /= d / 2) < 1) return c / 2 * t * t + b;\n        return -c / 2 * (--t * (t - 2) - 1) + b;\n    },\n    easeInCubic: function easeInCubic(x, t, b, c, d) {\n        return c * (t /= d) * t * t + b;\n    },\n    easeOutCubic: function easeOutCubic(x, t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t + 1) + b;\n    },\n    easeInOutCubic: function easeInOutCubic(x, t, b, c, d) {\n        if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;\n        return c / 2 * ((t -= 2) * t * t + 2) + b;\n    },\n    easeInQuart: function easeInQuart(x, t, b, c, d) {\n        return c * (t /= d) * t * t * t + b;\n    },\n    easeOutQuart: function easeOutQuart(x, t, b, c, d) {\n        return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n    },\n    easeInOutQuart: function easeInOutQuart(x, t, b, c, d) {\n        if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\n        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n    },\n    easeInQuint: function easeInQuint(x, t, b, c, d) {\n        return c * (t /= d) * t * t * t * t + b;\n    },\n    easeOutQuint: function easeOutQuint(x, t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n    },\n    easeInOutQuint: function easeInOutQuint(x, t, b, c, d) {\n        if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b;\n        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n    },\n    easeInSine: function easeInSine(x, t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    },\n    easeOutSine: function easeOutSine(x, t, b, c, d) {\n        return c * Math.sin(t / d * (Math.PI / 2)) + b;\n    },\n    easeInOutSine: function easeInOutSine(x, t, b, c, d) {\n        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n    },\n    easeInExpo: function easeInExpo(x, t, b, c, d) {\n        return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n    },\n    easeOutExpo: function easeOutExpo(x, t, b, c, d) {\n        return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n    },\n    easeInOutExpo: function easeInOutExpo(x, t, b, c, d) {\n        if (t == 0) return b;\n        if (t == d) return b + c;\n        if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n    },\n    easeInCirc: function easeInCirc(x, t, b, c, d) {\n        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n    },\n    easeOutCirc: function easeOutCirc(x, t, b, c, d) {\n        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n    },\n    easeInOutCirc: function easeInOutCirc(x, t, b, c, d) {\n        if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n    },\n    easeInElastic: function easeInElastic(x, t, b, c, d) {\n        var s = 1.70158;\n        var p = 0;\n        var a = c;\n        if (t == 0) return b;\n        if ((t /= d) == 1) return b + c;\n        if (!p) p = d * .3;\n        if (a < Math.abs(c)) {\n            a = c;\n            var s = p / 4;\n        } else var s = p / (2 * Math.PI) * Math.asin(c / a);\n        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n    },\n    easeOutElastic: function easeOutElastic(x, t, b, c, d) {\n        var s = 1.70158;\n        var p = 0;\n        var a = c;\n        if (t == 0) return b;\n        if ((t /= d) == 1) return b + c;\n        if (!p) p = d * .3;\n        if (a < Math.abs(c)) {\n            a = c;\n            var s = p / 4;\n        } else var s = p / (2 * Math.PI) * Math.asin(c / a);\n        return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n    },\n    easeInOutElastic: function easeInOutElastic(x, t, b, c, d) {\n        var s = 1.70158;\n        var p = 0;\n        var a = c;\n        if (t == 0) return b;\n        if ((t /= d / 2) == 2) return b + c;\n        if (!p) p = d * (.3 * 1.5);\n        if (a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        } else {\n            s = p / (2 * Math.PI) * Math.asin(c / a);\n        }\n        if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;\n    },\n    easeInBack: function easeInBack(x, t, b, c, d, s) {\n        if (s == undefined) s = 1.70158;\n        return c * (t /= d) * t * ((s + 1) * t - s) + b;\n    },\n    easeOutBack: function easeOutBack(x, t, b, c, d, s) {\n        if (s == undefined) s = 1.70158;\n        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n    },\n    easeInOutBack: function easeInOutBack(x, t, b, c, d, s) {\n        if (s == undefined) s = 1.70158;\n        if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n        return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n    },\n    easeInBounce: function easeInBounce(x, t, b, c, d) {\n        return c - jQuery.easing.easeOutBounce(x, d - t, 0, c, d) + b;\n    },\n    easeOutBounce: function easeOutBounce(x, t, b, c, d) {\n        if ((t /= d) < 1 / 2.75) {\n            return c * (7.5625 * t * t) + b;\n        } else if (t < 2 / 2.75) {\n            return c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b;\n        } else if (t < 2.5 / 2.75) {\n            return c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b;\n        } else {\n            return c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b;\n        }\n    },\n    easeInOutBounce: function easeInOutBounce(x, t, b, c, d) {\n        if (t < d / 2) return jQuery.easing.easeInBounce(x, t * 2, 0, c, d) * .5 + b;\n        return jQuery.easing.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;\n    }\n});\n\njQuery.extend(jQuery.easing, {\n    easeInOutMaterial: function easeInOutMaterial(x, t, b, c, d) {\n        if ((t /= d / 2) < 1) return c / 2 * t * t + b;\n        return c / 4 * ((t -= 2) * t * t + 2) + b;\n    }\n});\n\njQuery.Velocity ? console.log(\"Velocity is already loaded. You may be needlessly importing Velocity again; note that Materialize includes Velocity.\") : (!function (e) {\n    function t(e) {\n        var t = e.length,\n            a = r.type(e);\n        return \"function\" === a || r.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : \"array\" === a || 0 === t || \"number\" == typeof t && t > 0 && t - 1 in e;\n    }\n    if (!__webpack_provided_window_dot_jQuery) {\n        var r = function r(e, t) {\n            return new r.fn.init(e, t);\n        };\n        r.isWindow = function (e) {\n            return null != e && e == e.window;\n        }, r.type = function (e) {\n            return null == e ? e + \"\" : \"object\" == (typeof e === 'undefined' ? 'undefined' : _typeof(e)) || \"function\" == typeof e ? n[i.call(e)] || \"object\" : typeof e === 'undefined' ? 'undefined' : _typeof(e);\n        }, r.isArray = Array.isArray || function (e) {\n            return \"array\" === r.type(e);\n        }, r.isPlainObject = function (e) {\n            var t;\n            if (!e || \"object\" !== r.type(e) || e.nodeType || r.isWindow(e)) return !1;\n            try {\n                if (e.constructor && !o.call(e, \"constructor\") && !o.call(e.constructor.prototype, \"isPrototypeOf\")) return !1;\n            } catch (a) {\n                return !1;\n            }\n            for (t in e) {}\n            return void 0 === t || o.call(e, t);\n        }, r.each = function (e, r, a) {\n            var n,\n                o = 0,\n                i = e.length,\n                s = t(e);\n            if (a) {\n                if (s) for (; i > o && (n = r.apply(e[o], a), n !== !1); o++) {} else for (o in e) {\n                    if (n = r.apply(e[o], a), n === !1) break;\n                }\n            } else if (s) for (; i > o && (n = r.call(e[o], o, e[o]), n !== !1); o++) {} else for (o in e) {\n                if (n = r.call(e[o], o, e[o]), n === !1) break;\n            }return e;\n        }, r.data = function (e, t, n) {\n            if (void 0 === n) {\n                var o = e[r.expando],\n                    i = o && a[o];\n                if (void 0 === t) return i;\n                if (i && t in i) return i[t];\n            } else if (void 0 !== t) {\n                var o = e[r.expando] || (e[r.expando] = ++r.uuid);\n                return a[o] = a[o] || {}, a[o][t] = n, n;\n            }\n        }, r.removeData = function (e, t) {\n            var n = e[r.expando],\n                o = n && a[n];\n            o && r.each(t, function (e, t) {\n                delete o[t];\n            });\n        }, r.extend = function () {\n            var e,\n                t,\n                a,\n                n,\n                o,\n                i,\n                s = arguments[0] || {},\n                l = 1,\n                u = arguments.length,\n                c = !1;\n            for (\"boolean\" == typeof s && (c = s, s = arguments[l] || {}, l++), \"object\" != (typeof s === 'undefined' ? 'undefined' : _typeof(s)) && \"function\" !== r.type(s) && (s = {}), l === u && (s = this, l--); u > l; l++) {\n                if (null != (o = arguments[l])) for (n in o) {\n                    e = s[n], a = o[n], s !== a && (c && a && (r.isPlainObject(a) || (t = r.isArray(a))) ? (t ? (t = !1, i = e && r.isArray(e) ? e : []) : i = e && r.isPlainObject(e) ? e : {}, s[n] = r.extend(c, i, a)) : void 0 !== a && (s[n] = a));\n                }\n            }return s;\n        }, r.queue = function (e, a, n) {\n            function o(e, r) {\n                var a = r || [];\n                return null != e && (t(Object(e)) ? !function (e, t) {\n                    for (var r = +t.length, a = 0, n = e.length; r > a;) {\n                        e[n++] = t[a++];\n                    }if (r !== r) for (; void 0 !== t[a];) {\n                        e[n++] = t[a++];\n                    }return e.length = n, e;\n                }(a, \"string\" == typeof e ? [e] : e) : [].push.call(a, e)), a;\n            }\n            if (e) {\n                a = (a || \"fx\") + \"queue\";\n                var i = r.data(e, a);\n                return n ? (!i || r.isArray(n) ? i = r.data(e, a, o(n)) : i.push(n), i) : i || [];\n            }\n        }, r.dequeue = function (e, t) {\n            r.each(e.nodeType ? [e] : e, function (e, a) {\n                t = t || \"fx\";\n                var n = r.queue(a, t),\n                    o = n.shift();\n                \"inprogress\" === o && (o = n.shift()), o && (\"fx\" === t && n.unshift(\"inprogress\"), o.call(a, function () {\n                    r.dequeue(a, t);\n                }));\n            });\n        }, r.fn = r.prototype = {\n            init: function init(e) {\n                if (e.nodeType) return this[0] = e, this;\n                throw new Error(\"Not a DOM node.\");\n            },\n            offset: function offset() {\n                var t = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {\n                    top: 0,\n                    left: 0\n                };\n                return {\n                    top: t.top + (e.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),\n                    left: t.left + (e.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)\n                };\n            },\n            position: function position() {\n                function e() {\n                    for (var e = this.offsetParent || document; e && \"html\" === !e.nodeType.toLowerCase && \"static\" === e.style.position;) {\n                        e = e.offsetParent;\n                    }return e || document;\n                }\n                var t = this[0],\n                    e = e.apply(t),\n                    a = this.offset(),\n                    n = /^(?:body|html)$/i.test(e.nodeName) ? {\n                    top: 0,\n                    left: 0\n                } : r(e).offset();\n                return a.top -= parseFloat(t.style.marginTop) || 0, a.left -= parseFloat(t.style.marginLeft) || 0, e.style && (n.top += parseFloat(e.style.borderTopWidth) || 0, n.left += parseFloat(e.style.borderLeftWidth) || 0), {\n                    top: a.top - n.top,\n                    left: a.left - n.left\n                };\n            }\n        };\n        var a = {};\n        r.expando = \"velocity\" + new Date().getTime(), r.uuid = 0;\n        for (var n = {}, o = n.hasOwnProperty, i = n.toString, s = \"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), l = 0; l < s.length; l++) {\n            n[\"[object \" + s[l] + \"]\"] = s[l].toLowerCase();\n        }r.fn.init.prototype = r.fn, e.Velocity = {\n            Utilities: r\n        };\n    }\n}(window), function (e) {\n    \"object\" == ( false ? undefined : _typeof(module)) && \"object\" == _typeof(module.exports) ? module.exports = e() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n}(function () {\n    return function (e, t, r, a) {\n        function n(e) {\n            for (var t = -1, r = e ? e.length : 0, a = []; ++t < r;) {\n                var n = e[t];\n                n && a.push(n);\n            }\n            return a;\n        }\n\n        function o(e) {\n            return m.isWrapped(e) ? e = [].slice.call(e) : m.isNode(e) && (e = [e]), e;\n        }\n\n        function i(e) {\n            var t = f.data(e, \"velocity\");\n            return null === t ? a : t;\n        }\n\n        function s(e) {\n            return function (t) {\n                return Math.round(t * e) * (1 / e);\n            };\n        }\n\n        function l(e, r, a, n) {\n            function o(e, t) {\n                return 1 - 3 * t + 3 * e;\n            }\n\n            function i(e, t) {\n                return 3 * t - 6 * e;\n            }\n\n            function s(e) {\n                return 3 * e;\n            }\n\n            function l(e, t, r) {\n                return ((o(t, r) * e + i(t, r)) * e + s(t)) * e;\n            }\n\n            function u(e, t, r) {\n                return 3 * o(t, r) * e * e + 2 * i(t, r) * e + s(t);\n            }\n\n            function c(t, r) {\n                for (var n = 0; m > n; ++n) {\n                    var o = u(r, e, a);\n                    if (0 === o) return r;\n                    var i = l(r, e, a) - t;\n                    r -= i / o;\n                }\n                return r;\n            }\n\n            function p() {\n                for (var t = 0; b > t; ++t) {\n                    w[t] = l(t * x, e, a);\n                }\n            }\n\n            function f(t, r, n) {\n                var o,\n                    i,\n                    s = 0;\n                do {\n                    i = r + (n - r) / 2, o = l(i, e, a) - t, o > 0 ? n = i : r = i;\n                } while (Math.abs(o) > h && ++s < v);\n                return i;\n            }\n\n            function d(t) {\n                for (var r = 0, n = 1, o = b - 1; n != o && w[n] <= t; ++n) {\n                    r += x;\n                }--n;\n                var i = (t - w[n]) / (w[n + 1] - w[n]),\n                    s = r + i * x,\n                    l = u(s, e, a);\n                return l >= y ? c(t, s) : 0 == l ? s : f(t, r, r + x);\n            }\n\n            function g() {\n                V = !0, (e != r || a != n) && p();\n            }\n            var m = 4,\n                y = .001,\n                h = 1e-7,\n                v = 10,\n                b = 11,\n                x = 1 / (b - 1),\n                S = \"Float32Array\" in t;\n            if (4 !== arguments.length) return !1;\n            for (var P = 0; 4 > P; ++P) {\n                if (\"number\" != typeof arguments[P] || isNaN(arguments[P]) || !isFinite(arguments[P])) return !1;\n            }e = Math.min(e, 1), a = Math.min(a, 1), e = Math.max(e, 0), a = Math.max(a, 0);\n            var w = S ? new Float32Array(b) : new Array(b),\n                V = !1,\n                C = function C(t) {\n                return V || g(), e === r && a === n ? t : 0 === t ? 0 : 1 === t ? 1 : l(d(t), r, n);\n            };\n            C.getControlPoints = function () {\n                return [{\n                    x: e,\n                    y: r\n                }, {\n                    x: a,\n                    y: n\n                }];\n            };\n            var T = \"generateBezier(\" + [e, r, a, n] + \")\";\n            return C.toString = function () {\n                return T;\n            }, C;\n        }\n\n        function u(e, t) {\n            var r = e;\n            return m.isString(e) ? b.Easings[e] || (r = !1) : r = m.isArray(e) && 1 === e.length ? s.apply(null, e) : m.isArray(e) && 2 === e.length ? x.apply(null, e.concat([t])) : m.isArray(e) && 4 === e.length ? l.apply(null, e) : !1, r === !1 && (r = b.Easings[b.defaults.easing] ? b.defaults.easing : v), r;\n        }\n\n        function c(e) {\n            if (e) {\n                var t = new Date().getTime(),\n                    r = b.State.calls.length;\n                r > 1e4 && (b.State.calls = n(b.State.calls));\n                for (var o = 0; r > o; o++) {\n                    if (b.State.calls[o]) {\n                        var s = b.State.calls[o],\n                            l = s[0],\n                            u = s[2],\n                            d = s[3],\n                            g = !!d,\n                            y = null;\n                        d || (d = b.State.calls[o][3] = t - 16);\n                        for (var h = Math.min((t - d) / u.duration, 1), v = 0, x = l.length; x > v; v++) {\n                            var P = l[v],\n                                V = P.element;\n                            if (i(V)) {\n                                var C = !1;\n                                if (u.display !== a && null !== u.display && \"none\" !== u.display) {\n                                    if (\"flex\" === u.display) {\n                                        var T = [\"-webkit-box\", \"-moz-box\", \"-ms-flexbox\", \"-webkit-flex\"];\n                                        f.each(T, function (e, t) {\n                                            S.setPropertyValue(V, \"display\", t);\n                                        });\n                                    }\n                                    S.setPropertyValue(V, \"display\", u.display);\n                                }\n                                u.visibility !== a && \"hidden\" !== u.visibility && S.setPropertyValue(V, \"visibility\", u.visibility);\n                                for (var k in P) {\n                                    if (\"element\" !== k) {\n                                        var A,\n                                            F = P[k],\n                                            j = m.isString(F.easing) ? b.Easings[F.easing] : F.easing;\n                                        if (1 === h) A = F.endValue;else {\n                                            var E = F.endValue - F.startValue;\n                                            if (A = F.startValue + E * j(h, u, E), !g && A === F.currentValue) continue;\n                                        }\n                                        if (F.currentValue = A, \"tween\" === k) y = A;else {\n                                            if (S.Hooks.registered[k]) {\n                                                var H = S.Hooks.getRoot(k),\n                                                    N = i(V).rootPropertyValueCache[H];\n                                                N && (F.rootPropertyValue = N);\n                                            }\n                                            var L = S.setPropertyValue(V, k, F.currentValue + (0 === parseFloat(A) ? \"\" : F.unitType), F.rootPropertyValue, F.scrollData);\n                                            S.Hooks.registered[k] && (i(V).rootPropertyValueCache[H] = S.Normalizations.registered[H] ? S.Normalizations.registered[H](\"extract\", null, L[1]) : L[1]), \"transform\" === L[0] && (C = !0);\n                                        }\n                                    }\n                                }u.mobileHA && i(V).transformCache.translate3d === a && (i(V).transformCache.translate3d = \"(0px, 0px, 0px)\", C = !0), C && S.flushTransformCache(V);\n                            }\n                        }\n                        u.display !== a && \"none\" !== u.display && (b.State.calls[o][2].display = !1), u.visibility !== a && \"hidden\" !== u.visibility && (b.State.calls[o][2].visibility = !1), u.progress && u.progress.call(s[1], s[1], h, Math.max(0, d + u.duration - t), d, y), 1 === h && p(o);\n                    }\n                }\n            }\n            b.State.isTicking && w(c);\n        }\n\n        function p(e, t) {\n            if (!b.State.calls[e]) return !1;\n            for (var r = b.State.calls[e][0], n = b.State.calls[e][1], o = b.State.calls[e][2], s = b.State.calls[e][4], l = !1, u = 0, c = r.length; c > u; u++) {\n                var p = r[u].element;\n                if (t || o.loop || (\"none\" === o.display && S.setPropertyValue(p, \"display\", o.display), \"hidden\" === o.visibility && S.setPropertyValue(p, \"visibility\", o.visibility)), o.loop !== !0 && (f.queue(p)[1] === a || !/\\.velocityQueueEntryFlag/i.test(f.queue(p)[1])) && i(p)) {\n                    i(p).isAnimating = !1, i(p).rootPropertyValueCache = {};\n                    var d = !1;\n                    f.each(S.Lists.transforms3D, function (e, t) {\n                        var r = /^scale/.test(t) ? 1 : 0,\n                            n = i(p).transformCache[t];\n                        i(p).transformCache[t] !== a && new RegExp(\"^\\\\(\" + r + \"[^.]\").test(n) && (d = !0, delete i(p).transformCache[t]);\n                    }), o.mobileHA && (d = !0, delete i(p).transformCache.translate3d), d && S.flushTransformCache(p), S.Values.removeClass(p, \"velocity-animating\");\n                }\n                if (!t && o.complete && !o.loop && u === c - 1) try {\n                    o.complete.call(n, n);\n                } catch (g) {\n                    setTimeout(function () {\n                        throw g;\n                    }, 1);\n                }\n                s && o.loop !== !0 && s(n), i(p) && o.loop === !0 && !t && (f.each(i(p).tweensContainer, function (e, t) {\n                    /^rotate/.test(e) && 360 === parseFloat(t.endValue) && (t.endValue = 0, t.startValue = 360), /^backgroundPosition/.test(e) && 100 === parseFloat(t.endValue) && \"%\" === t.unitType && (t.endValue = 0, t.startValue = 100);\n                }), b(p, \"reverse\", {\n                    loop: !0,\n                    delay: o.delay\n                })), o.queue !== !1 && f.dequeue(p, o.queue);\n            }\n            b.State.calls[e] = !1;\n            for (var m = 0, y = b.State.calls.length; y > m; m++) {\n                if (b.State.calls[m] !== !1) {\n                    l = !0;\n                    break;\n                }\n            }l === !1 && (b.State.isTicking = !1, delete b.State.calls, b.State.calls = []);\n        }\n        var f,\n            d = function () {\n            if (r.documentMode) return r.documentMode;\n            for (var e = 7; e > 4; e--) {\n                var t = r.createElement(\"div\");\n                if (t.innerHTML = \"<!--[if IE \" + e + \"]><span></span><![endif]-->\" && t.getElementsByTagName(\"span\").length) return t = null, e;\n            }\n            return a;\n        }(),\n            g = function () {\n            var e = 0;\n            return t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || function (t) {\n                var r,\n                    a = new Date().getTime();\n                return r = Math.max(0, 16 - (a - e)), e = a + r, setTimeout(function () {\n                    t(a + r);\n                }, r);\n            };\n        }(),\n            m = {\n            isString: function isString(e) {\n                return \"string\" == typeof e;\n            },\n            isArray: Array.isArray || function (e) {\n                return \"[object Array]\" === Object.prototype.toString.call(e);\n            },\n            isFunction: function isFunction(e) {\n                return \"[object Function]\" === Object.prototype.toString.call(e);\n            },\n            isNode: function isNode(e) {\n                return e && e.nodeType;\n            },\n            isNodeList: function isNodeList(e) {\n                return \"object\" == (typeof e === 'undefined' ? 'undefined' : _typeof(e)) && /^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(e)) && e.length !== a && (0 === e.length || \"object\" == _typeof(e[0]) && e[0].nodeType > 0);\n            },\n            isWrapped: function isWrapped(e) {\n                return e && (e.jquery || t.Zepto && t.Zepto.zepto.isZ(e));\n            },\n            isSVG: function isSVG(e) {\n                return t.SVGElement && e instanceof t.SVGElement;\n            },\n            isEmptyObject: function isEmptyObject(e) {\n                for (var t in e) {\n                    return !1;\n                }return !0;\n            }\n        },\n            y = !1;\n        if (e.fn && e.fn.jquery ? (f = e, y = !0) : f = t.Velocity.Utilities, 8 >= d && !y) throw new Error(\"Velocity: IE8 and below require jQuery to be loaded before Velocity.\");\n        if (7 >= d) return void (jQuery.fn.velocity = jQuery.fn.animate);\n        var h = 400,\n            v = \"swing\",\n            b = {\n            State: {\n                isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),\n                isAndroid: /Android/i.test(navigator.userAgent),\n                isGingerbread: /Android 2\\.3\\.[3-7]/i.test(navigator.userAgent),\n                isChrome: t.chrome,\n                isFirefox: /Firefox/i.test(navigator.userAgent),\n                prefixElement: r.createElement(\"div\"),\n                prefixMatches: {},\n                scrollAnchor: null,\n                scrollPropertyLeft: null,\n                scrollPropertyTop: null,\n                isTicking: !1,\n                calls: []\n            },\n            CSS: {},\n            Utilities: f,\n            Redirects: {},\n            Easings: {},\n            Promise: t.Promise,\n            defaults: {\n                queue: \"\",\n                duration: h,\n                easing: v,\n                begin: a,\n                complete: a,\n                progress: a,\n                display: a,\n                visibility: a,\n                loop: !1,\n                delay: !1,\n                mobileHA: !0,\n                _cacheValues: !0\n            },\n            init: function init(e) {\n                f.data(e, \"velocity\", {\n                    isSVG: m.isSVG(e),\n                    isAnimating: !1,\n                    computedStyle: null,\n                    tweensContainer: null,\n                    rootPropertyValueCache: {},\n                    transformCache: {}\n                });\n            },\n            hook: null,\n            mock: !1,\n            version: {\n                major: 1,\n                minor: 2,\n                patch: 2\n            },\n            debug: !1\n        };\n        t.pageYOffset !== a ? (b.State.scrollAnchor = t, b.State.scrollPropertyLeft = \"pageXOffset\", b.State.scrollPropertyTop = \"pageYOffset\") : (b.State.scrollAnchor = r.documentElement || r.body.parentNode || r.body, b.State.scrollPropertyLeft = \"scrollLeft\", b.State.scrollPropertyTop = \"scrollTop\");\n        var x = function () {\n            function e(e) {\n                return -e.tension * e.x - e.friction * e.v;\n            }\n\n            function t(t, r, a) {\n                var n = {\n                    x: t.x + a.dx * r,\n                    v: t.v + a.dv * r,\n                    tension: t.tension,\n                    friction: t.friction\n                };\n                return {\n                    dx: n.v,\n                    dv: e(n)\n                };\n            }\n\n            function r(r, a) {\n                var n = {\n                    dx: r.v,\n                    dv: e(r)\n                },\n                    o = t(r, .5 * a, n),\n                    i = t(r, .5 * a, o),\n                    s = t(r, a, i),\n                    l = 1 / 6 * (n.dx + 2 * (o.dx + i.dx) + s.dx),\n                    u = 1 / 6 * (n.dv + 2 * (o.dv + i.dv) + s.dv);\n                return r.x = r.x + l * a, r.v = r.v + u * a, r;\n            }\n            return function a(e, t, n) {\n                var o,\n                    i,\n                    s,\n                    l = {\n                    x: -1,\n                    v: 0,\n                    tension: null,\n                    friction: null\n                },\n                    u = [0],\n                    c = 0,\n                    p = 1e-4,\n                    f = .016;\n                for (e = parseFloat(e) || 500, t = parseFloat(t) || 20, n = n || null, l.tension = e, l.friction = t, o = null !== n, o ? (c = a(e, t), i = c / n * f) : i = f; s = r(s || l, i), u.push(1 + s.x), c += 16, Math.abs(s.x) > p && Math.abs(s.v) > p;) {}\n                return o ? function (e) {\n                    return u[e * (u.length - 1) | 0];\n                } : c;\n            };\n        }();\n        b.Easings = {\n            linear: function linear(e) {\n                return e;\n            },\n            swing: function swing(e) {\n                return .5 - Math.cos(e * Math.PI) / 2;\n            },\n            spring: function spring(e) {\n                return 1 - Math.cos(4.5 * e * Math.PI) * Math.exp(6 * -e);\n            }\n        }, f.each([[\"ease\", [.25, .1, .25, 1]], [\"ease-in\", [.42, 0, 1, 1]], [\"ease-out\", [0, 0, .58, 1]], [\"ease-in-out\", [.42, 0, .58, 1]], [\"easeInSine\", [.47, 0, .745, .715]], [\"easeOutSine\", [.39, .575, .565, 1]], [\"easeInOutSine\", [.445, .05, .55, .95]], [\"easeInQuad\", [.55, .085, .68, .53]], [\"easeOutQuad\", [.25, .46, .45, .94]], [\"easeInOutQuad\", [.455, .03, .515, .955]], [\"easeInCubic\", [.55, .055, .675, .19]], [\"easeOutCubic\", [.215, .61, .355, 1]], [\"easeInOutCubic\", [.645, .045, .355, 1]], [\"easeInQuart\", [.895, .03, .685, .22]], [\"easeOutQuart\", [.165, .84, .44, 1]], [\"easeInOutQuart\", [.77, 0, .175, 1]], [\"easeInQuint\", [.755, .05, .855, .06]], [\"easeOutQuint\", [.23, 1, .32, 1]], [\"easeInOutQuint\", [.86, 0, .07, 1]], [\"easeInExpo\", [.95, .05, .795, .035]], [\"easeOutExpo\", [.19, 1, .22, 1]], [\"easeInOutExpo\", [1, 0, 0, 1]], [\"easeInCirc\", [.6, .04, .98, .335]], [\"easeOutCirc\", [.075, .82, .165, 1]], [\"easeInOutCirc\", [.785, .135, .15, .86]]], function (e, t) {\n            b.Easings[t[0]] = l.apply(null, t[1]);\n        });\n        var S = b.CSS = {\n            RegEx: {\n                isHex: /^#([A-f\\d]{3}){1,2}$/i,\n                valueUnwrap: /^[A-z]+\\((.*)\\)$/i,\n                wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,\n                valueSplit: /([A-z]+\\(.+\\))|(([A-z0-9#-.]+?)(?=\\s|$))/gi\n            },\n            Lists: {\n                colors: [\"fill\", \"stroke\", \"stopColor\", \"color\", \"backgroundColor\", \"borderColor\", \"borderTopColor\", \"borderRightColor\", \"borderBottomColor\", \"borderLeftColor\", \"outlineColor\"],\n                transformsBase: [\"translateX\", \"translateY\", \"scale\", \"scaleX\", \"scaleY\", \"skewX\", \"skewY\", \"rotateZ\"],\n                transforms3D: [\"transformPerspective\", \"translateZ\", \"scaleZ\", \"rotateX\", \"rotateY\"]\n            },\n            Hooks: {\n                templates: {\n                    textShadow: [\"Color X Y Blur\", \"black 0px 0px 0px\"],\n                    boxShadow: [\"Color X Y Blur Spread\", \"black 0px 0px 0px 0px\"],\n                    clip: [\"Top Right Bottom Left\", \"0px 0px 0px 0px\"],\n                    backgroundPosition: [\"X Y\", \"0% 0%\"],\n                    transformOrigin: [\"X Y Z\", \"50% 50% 0px\"],\n                    perspectiveOrigin: [\"X Y\", \"50% 50%\"]\n                },\n                registered: {},\n                register: function register() {\n                    for (var e = 0; e < S.Lists.colors.length; e++) {\n                        var t = \"color\" === S.Lists.colors[e] ? \"0 0 0 1\" : \"255 255 255 1\";\n                        S.Hooks.templates[S.Lists.colors[e]] = [\"Red Green Blue Alpha\", t];\n                    }\n                    var r, a, n;\n                    if (d) for (r in S.Hooks.templates) {\n                        a = S.Hooks.templates[r], n = a[0].split(\" \");\n                        var o = a[1].match(S.RegEx.valueSplit);\n                        \"Color\" === n[0] && (n.push(n.shift()), o.push(o.shift()), S.Hooks.templates[r] = [n.join(\" \"), o.join(\" \")]);\n                    }\n                    for (r in S.Hooks.templates) {\n                        a = S.Hooks.templates[r], n = a[0].split(\" \");\n                        for (var e in n) {\n                            var i = r + n[e],\n                                s = e;\n                            S.Hooks.registered[i] = [r, s];\n                        }\n                    }\n                },\n                getRoot: function getRoot(e) {\n                    var t = S.Hooks.registered[e];\n                    return t ? t[0] : e;\n                },\n                cleanRootPropertyValue: function cleanRootPropertyValue(e, t) {\n                    return S.RegEx.valueUnwrap.test(t) && (t = t.match(S.RegEx.valueUnwrap)[1]), S.Values.isCSSNullValue(t) && (t = S.Hooks.templates[e][1]), t;\n                },\n                extractValue: function extractValue(e, t) {\n                    var r = S.Hooks.registered[e];\n                    if (r) {\n                        var a = r[0],\n                            n = r[1];\n                        return t = S.Hooks.cleanRootPropertyValue(a, t), t.toString().match(S.RegEx.valueSplit)[n];\n                    }\n                    return t;\n                },\n                injectValue: function injectValue(e, t, r) {\n                    var a = S.Hooks.registered[e];\n                    if (a) {\n                        var n,\n                            o,\n                            i = a[0],\n                            s = a[1];\n                        return r = S.Hooks.cleanRootPropertyValue(i, r), n = r.toString().match(S.RegEx.valueSplit), n[s] = t, o = n.join(\" \");\n                    }\n                    return r;\n                }\n            },\n            Normalizations: {\n                registered: {\n                    clip: function clip(e, t, r) {\n                        switch (e) {\n                            case \"name\":\n                                return \"clip\";\n                            case \"extract\":\n                                var a;\n                                return S.RegEx.wrappedValueAlreadyExtracted.test(r) ? a = r : (a = r.toString().match(S.RegEx.valueUnwrap), a = a ? a[1].replace(/,(\\s+)?/g, \" \") : r), a;\n                            case \"inject\":\n                                return \"rect(\" + r + \")\";\n                        }\n                    },\n                    blur: function blur(e, t, r) {\n                        switch (e) {\n                            case \"name\":\n                                return b.State.isFirefox ? \"filter\" : \"-webkit-filter\";\n                            case \"extract\":\n                                var a = parseFloat(r);\n                                if (!a && 0 !== a) {\n                                    var n = r.toString().match(/blur\\(([0-9]+[A-z]+)\\)/i);\n                                    a = n ? n[1] : 0;\n                                }\n                                return a;\n                            case \"inject\":\n                                return parseFloat(r) ? \"blur(\" + r + \")\" : \"none\";\n                        }\n                    },\n                    opacity: function opacity(e, t, r) {\n                        if (8 >= d) switch (e) {\n                            case \"name\":\n                                return \"filter\";\n                            case \"extract\":\n                                var a = r.toString().match(/alpha\\(opacity=(.*)\\)/i);\n                                return r = a ? a[1] / 100 : 1;\n                            case \"inject\":\n                                return t.style.zoom = 1, parseFloat(r) >= 1 ? \"\" : \"alpha(opacity=\" + parseInt(100 * parseFloat(r), 10) + \")\";\n                        } else switch (e) {\n                            case \"name\":\n                                return \"opacity\";\n                            case \"extract\":\n                                return r;\n                            case \"inject\":\n                                return r;\n                        }\n                    }\n                },\n                register: function register() {\n                    9 >= d || b.State.isGingerbread || (S.Lists.transformsBase = S.Lists.transformsBase.concat(S.Lists.transforms3D));\n                    for (var e = 0; e < S.Lists.transformsBase.length; e++) {\n                        !function () {\n                            var t = S.Lists.transformsBase[e];\n                            S.Normalizations.registered[t] = function (e, r, n) {\n                                switch (e) {\n                                    case \"name\":\n                                        return \"transform\";\n                                    case \"extract\":\n                                        return i(r) === a || i(r).transformCache[t] === a ? /^scale/i.test(t) ? 1 : 0 : i(r).transformCache[t].replace(/[()]/g, \"\");\n                                    case \"inject\":\n                                        var o = !1;\n                                        switch (t.substr(0, t.length - 1)) {\n                                            case \"translate\":\n                                                o = !/(%|px|em|rem|vw|vh|\\d)$/i.test(n);\n                                                break;\n                                            case \"scal\":\n                                            case \"scale\":\n                                                b.State.isAndroid && i(r).transformCache[t] === a && 1 > n && (n = 1), o = !/(\\d)$/i.test(n);\n                                                break;\n                                            case \"skew\":\n                                                o = !/(deg|\\d)$/i.test(n);\n                                                break;\n                                            case \"rotate\":\n                                                o = !/(deg|\\d)$/i.test(n);\n                                        }\n                                        return o || (i(r).transformCache[t] = \"(\" + n + \")\"), i(r).transformCache[t];\n                                }\n                            };\n                        }();\n                    }for (var e = 0; e < S.Lists.colors.length; e++) {\n                        !function () {\n                            var t = S.Lists.colors[e];\n                            S.Normalizations.registered[t] = function (e, r, n) {\n                                switch (e) {\n                                    case \"name\":\n                                        return t;\n                                    case \"extract\":\n                                        var o;\n                                        if (S.RegEx.wrappedValueAlreadyExtracted.test(n)) o = n;else {\n                                            var i,\n                                                s = {\n                                                black: \"rgb(0, 0, 0)\",\n                                                blue: \"rgb(0, 0, 255)\",\n                                                gray: \"rgb(128, 128, 128)\",\n                                                green: \"rgb(0, 128, 0)\",\n                                                red: \"rgb(255, 0, 0)\",\n                                                white: \"rgb(255, 255, 255)\"\n                                            };\n                                            /^[A-z]+$/i.test(n) ? i = s[n] !== a ? s[n] : s.black : S.RegEx.isHex.test(n) ? i = \"rgb(\" + S.Values.hexToRgb(n).join(\" \") + \")\" : /^rgba?\\(/i.test(n) || (i = s.black), o = (i || n).toString().match(S.RegEx.valueUnwrap)[1].replace(/,(\\s+)?/g, \" \");\n                                        }\n                                        return 8 >= d || 3 !== o.split(\" \").length || (o += \" 1\"), o;\n                                    case \"inject\":\n                                        return 8 >= d ? 4 === n.split(\" \").length && (n = n.split(/\\s+/).slice(0, 3).join(\" \")) : 3 === n.split(\" \").length && (n += \" 1\"), (8 >= d ? \"rgb\" : \"rgba\") + \"(\" + n.replace(/\\s+/g, \",\").replace(/\\.(\\d)+(?=,)/g, \"\") + \")\";\n                                }\n                            };\n                        }();\n                    }\n                }\n            },\n            Names: {\n                camelCase: function camelCase(e) {\n                    return e.replace(/-(\\w)/g, function (e, t) {\n                        return t.toUpperCase();\n                    });\n                },\n                SVGAttribute: function SVGAttribute(e) {\n                    var t = \"width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2\";\n                    return (d || b.State.isAndroid && !b.State.isChrome) && (t += \"|transform\"), new RegExp(\"^(\" + t + \")$\", \"i\").test(e);\n                },\n                prefixCheck: function prefixCheck(e) {\n                    if (b.State.prefixMatches[e]) return [b.State.prefixMatches[e], !0];\n                    for (var t = [\"\", \"Webkit\", \"Moz\", \"ms\", \"O\"], r = 0, a = t.length; a > r; r++) {\n                        var n;\n                        if (n = 0 === r ? e : t[r] + e.replace(/^\\w/, function (e) {\n                            return e.toUpperCase();\n                        }), m.isString(b.State.prefixElement.style[n])) return b.State.prefixMatches[e] = n, [n, !0];\n                    }\n                    return [e, !1];\n                }\n            },\n            Values: {\n                hexToRgb: function hexToRgb(e) {\n                    var t,\n                        r = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n                        a = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n                    return e = e.replace(r, function (e, t, r, a) {\n                        return t + t + r + r + a + a;\n                    }), t = a.exec(e), t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] : [0, 0, 0];\n                },\n                isCSSNullValue: function isCSSNullValue(e) {\n                    return 0 == e || /^(none|auto|transparent|(rgba\\(0, ?0, ?0, ?0\\)))$/i.test(e);\n                },\n                getUnitType: function getUnitType(e) {\n                    return (/^(rotate|skew)/i.test(e) ? \"deg\" : /(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e) ? \"\" : \"px\"\n                    );\n                },\n                getDisplayType: function getDisplayType(e) {\n                    var t = e && e.tagName.toString().toLowerCase();\n                    return (/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t) ? \"inline\" : /^(li)$/i.test(t) ? \"list-item\" : /^(tr)$/i.test(t) ? \"table-row\" : /^(table)$/i.test(t) ? \"table\" : /^(tbody)$/i.test(t) ? \"table-row-group\" : \"block\"\n                    );\n                },\n                addClass: function addClass(e, t) {\n                    e.classList ? e.classList.add(t) : e.className += (e.className.length ? \" \" : \"\") + t;\n                },\n                removeClass: function removeClass(e, t) {\n                    e.classList ? e.classList.remove(t) : e.className = e.className.toString().replace(new RegExp(\"(^|\\\\s)\" + t.split(\" \").join(\"|\") + \"(\\\\s|$)\", \"gi\"), \" \");\n                }\n            },\n            getPropertyValue: function getPropertyValue(e, r, n, o) {\n                function s(e, r) {\n                    function n() {\n                        u && S.setPropertyValue(e, \"display\", \"none\");\n                    }\n                    var l = 0;\n                    if (8 >= d) l = f.css(e, r);else {\n                        var u = !1;\n                        if (/^(width|height)$/.test(r) && 0 === S.getPropertyValue(e, \"display\") && (u = !0, S.setPropertyValue(e, \"display\", S.Values.getDisplayType(e))), !o) {\n                            if (\"height\" === r && \"border-box\" !== S.getPropertyValue(e, \"boxSizing\").toString().toLowerCase()) {\n                                var c = e.offsetHeight - (parseFloat(S.getPropertyValue(e, \"borderTopWidth\")) || 0) - (parseFloat(S.getPropertyValue(e, \"borderBottomWidth\")) || 0) - (parseFloat(S.getPropertyValue(e, \"paddingTop\")) || 0) - (parseFloat(S.getPropertyValue(e, \"paddingBottom\")) || 0);\n                                return n(), c;\n                            }\n                            if (\"width\" === r && \"border-box\" !== S.getPropertyValue(e, \"boxSizing\").toString().toLowerCase()) {\n                                var p = e.offsetWidth - (parseFloat(S.getPropertyValue(e, \"borderLeftWidth\")) || 0) - (parseFloat(S.getPropertyValue(e, \"borderRightWidth\")) || 0) - (parseFloat(S.getPropertyValue(e, \"paddingLeft\")) || 0) - (parseFloat(S.getPropertyValue(e, \"paddingRight\")) || 0);\n                                return n(), p;\n                            }\n                        }\n                        var g;\n                        g = i(e) === a ? t.getComputedStyle(e, null) : i(e).computedStyle ? i(e).computedStyle : i(e).computedStyle = t.getComputedStyle(e, null), \"borderColor\" === r && (r = \"borderTopColor\"), l = 9 === d && \"filter\" === r ? g.getPropertyValue(r) : g[r], (\"\" === l || null === l) && (l = e.style[r]), n();\n                    }\n                    if (\"auto\" === l && /^(top|right|bottom|left)$/i.test(r)) {\n                        var m = s(e, \"position\");\n                        (\"fixed\" === m || \"absolute\" === m && /top|left/i.test(r)) && (l = f(e).position()[r] + \"px\");\n                    }\n                    return l;\n                }\n                var l;\n                if (S.Hooks.registered[r]) {\n                    var u = r,\n                        c = S.Hooks.getRoot(u);\n                    n === a && (n = S.getPropertyValue(e, S.Names.prefixCheck(c)[0])), S.Normalizations.registered[c] && (n = S.Normalizations.registered[c](\"extract\", e, n)), l = S.Hooks.extractValue(u, n);\n                } else if (S.Normalizations.registered[r]) {\n                    var p, g;\n                    p = S.Normalizations.registered[r](\"name\", e), \"transform\" !== p && (g = s(e, S.Names.prefixCheck(p)[0]), S.Values.isCSSNullValue(g) && S.Hooks.templates[r] && (g = S.Hooks.templates[r][1])), l = S.Normalizations.registered[r](\"extract\", e, g);\n                }\n                if (!/^[\\d-]/.test(l)) if (i(e) && i(e).isSVG && S.Names.SVGAttribute(r)) {\n                    if (/^(height|width)$/i.test(r)) try {\n                        l = e.getBBox()[r];\n                    } catch (m) {\n                        l = 0;\n                    } else l = e.getAttribute(r);\n                } else l = s(e, S.Names.prefixCheck(r)[0]);\n                return S.Values.isCSSNullValue(l) && (l = 0), b.debug >= 2 && console.log(\"Get \" + r + \": \" + l), l;\n            },\n            setPropertyValue: function setPropertyValue(e, r, a, n, o) {\n                var s = r;\n                if (\"scroll\" === r) o.container ? o.container[\"scroll\" + o.direction] = a : \"Left\" === o.direction ? t.scrollTo(a, o.alternateValue) : t.scrollTo(o.alternateValue, a);else if (S.Normalizations.registered[r] && \"transform\" === S.Normalizations.registered[r](\"name\", e)) S.Normalizations.registered[r](\"inject\", e, a), s = \"transform\", a = i(e).transformCache[r];else {\n                    if (S.Hooks.registered[r]) {\n                        var l = r,\n                            u = S.Hooks.getRoot(r);\n                        n = n || S.getPropertyValue(e, u), a = S.Hooks.injectValue(l, a, n), r = u;\n                    }\n                    if (S.Normalizations.registered[r] && (a = S.Normalizations.registered[r](\"inject\", e, a), r = S.Normalizations.registered[r](\"name\", e)), s = S.Names.prefixCheck(r)[0], 8 >= d) try {\n                        e.style[s] = a;\n                    } catch (c) {\n                        b.debug && console.log(\"Browser does not support [\" + a + \"] for [\" + s + \"]\");\n                    } else i(e) && i(e).isSVG && S.Names.SVGAttribute(r) ? e.setAttribute(r, a) : e.style[s] = a;\n                    b.debug >= 2 && console.log(\"Set \" + r + \" (\" + s + \"): \" + a);\n                }\n                return [s, a];\n            },\n            flushTransformCache: function flushTransformCache(e) {\n                function t(t) {\n                    return parseFloat(S.getPropertyValue(e, t));\n                }\n                var r = \"\";\n                if ((d || b.State.isAndroid && !b.State.isChrome) && i(e).isSVG) {\n                    var a = {\n                        translate: [t(\"translateX\"), t(\"translateY\")],\n                        skewX: [t(\"skewX\")],\n                        skewY: [t(\"skewY\")],\n                        scale: 1 !== t(\"scale\") ? [t(\"scale\"), t(\"scale\")] : [t(\"scaleX\"), t(\"scaleY\")],\n                        rotate: [t(\"rotateZ\"), 0, 0]\n                    };\n                    f.each(i(e).transformCache, function (e) {\n                        /^translate/i.test(e) ? e = \"translate\" : /^scale/i.test(e) ? e = \"scale\" : /^rotate/i.test(e) && (e = \"rotate\"), a[e] && (r += e + \"(\" + a[e].join(\" \") + \") \", delete a[e]);\n                    });\n                } else {\n                    var n, o;\n                    f.each(i(e).transformCache, function (t) {\n                        return n = i(e).transformCache[t], \"transformPerspective\" === t ? (o = n, !0) : (9 === d && \"rotateZ\" === t && (t = \"rotate\"), void (r += t + n + \" \"));\n                    }), o && (r = \"perspective\" + o + \" \" + r);\n                }\n                S.setPropertyValue(e, \"transform\", r);\n            }\n        };\n        S.Hooks.register(), S.Normalizations.register(), b.hook = function (e, t, r) {\n            var n = a;\n            return e = o(e), f.each(e, function (e, o) {\n                if (i(o) === a && b.init(o), r === a) n === a && (n = b.CSS.getPropertyValue(o, t));else {\n                    var s = b.CSS.setPropertyValue(o, t, r);\n                    \"transform\" === s[0] && b.CSS.flushTransformCache(o), n = s;\n                }\n            }), n;\n        };\n        var P = function P() {\n            function e() {\n                return s ? k.promise || null : l;\n            }\n\n            function n() {\n                function e(e) {\n                    function p(e, t) {\n                        var r = a,\n                            n = a,\n                            i = a;\n                        return m.isArray(e) ? (r = e[0], !m.isArray(e[1]) && /^[\\d-]/.test(e[1]) || m.isFunction(e[1]) || S.RegEx.isHex.test(e[1]) ? i = e[1] : (m.isString(e[1]) && !S.RegEx.isHex.test(e[1]) || m.isArray(e[1])) && (n = t ? e[1] : u(e[1], s.duration), e[2] !== a && (i = e[2]))) : r = e, t || (n = n || s.easing), m.isFunction(r) && (r = r.call(o, V, w)), m.isFunction(i) && (i = i.call(o, V, w)), [r || 0, n, i];\n                    }\n\n                    function d(e, t) {\n                        var r, a;\n                        return a = (t || \"0\").toString().toLowerCase().replace(/[%A-z]+$/, function (e) {\n                            return r = e, \"\";\n                        }), r || (r = S.Values.getUnitType(e)), [a, r];\n                    }\n\n                    function h() {\n                        var e = {\n                            myParent: o.parentNode || r.body,\n                            position: S.getPropertyValue(o, \"position\"),\n                            fontSize: S.getPropertyValue(o, \"fontSize\")\n                        },\n                            a = e.position === L.lastPosition && e.myParent === L.lastParent,\n                            n = e.fontSize === L.lastFontSize;\n                        L.lastParent = e.myParent, L.lastPosition = e.position, L.lastFontSize = e.fontSize;\n                        var s = 100,\n                            l = {};\n                        if (n && a) l.emToPx = L.lastEmToPx, l.percentToPxWidth = L.lastPercentToPxWidth, l.percentToPxHeight = L.lastPercentToPxHeight;else {\n                            var u = i(o).isSVG ? r.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\") : r.createElement(\"div\");\n                            b.init(u), e.myParent.appendChild(u), f.each([\"overflow\", \"overflowX\", \"overflowY\"], function (e, t) {\n                                b.CSS.setPropertyValue(u, t, \"hidden\");\n                            }), b.CSS.setPropertyValue(u, \"position\", e.position), b.CSS.setPropertyValue(u, \"fontSize\", e.fontSize), b.CSS.setPropertyValue(u, \"boxSizing\", \"content-box\"), f.each([\"minWidth\", \"maxWidth\", \"width\", \"minHeight\", \"maxHeight\", \"height\"], function (e, t) {\n                                b.CSS.setPropertyValue(u, t, s + \"%\");\n                            }), b.CSS.setPropertyValue(u, \"paddingLeft\", s + \"em\"), l.percentToPxWidth = L.lastPercentToPxWidth = (parseFloat(S.getPropertyValue(u, \"width\", null, !0)) || 1) / s, l.percentToPxHeight = L.lastPercentToPxHeight = (parseFloat(S.getPropertyValue(u, \"height\", null, !0)) || 1) / s, l.emToPx = L.lastEmToPx = (parseFloat(S.getPropertyValue(u, \"paddingLeft\")) || 1) / s, e.myParent.removeChild(u);\n                        }\n                        return null === L.remToPx && (L.remToPx = parseFloat(S.getPropertyValue(r.body, \"fontSize\")) || 16), null === L.vwToPx && (L.vwToPx = parseFloat(t.innerWidth) / 100, L.vhToPx = parseFloat(t.innerHeight) / 100), l.remToPx = L.remToPx, l.vwToPx = L.vwToPx, l.vhToPx = L.vhToPx, b.debug >= 1 && console.log(\"Unit ratios: \" + JSON.stringify(l), o), l;\n                    }\n                    if (s.begin && 0 === V) try {\n                        s.begin.call(g, g);\n                    } catch (x) {\n                        setTimeout(function () {\n                            throw x;\n                        }, 1);\n                    }\n                    if (\"scroll\" === A) {\n                        var P,\n                            C,\n                            T,\n                            F = /^x$/i.test(s.axis) ? \"Left\" : \"Top\",\n                            j = parseFloat(s.offset) || 0;\n                        s.container ? m.isWrapped(s.container) || m.isNode(s.container) ? (s.container = s.container[0] || s.container, P = s.container[\"scroll\" + F], T = P + f(o).position()[F.toLowerCase()] + j) : s.container = null : (P = b.State.scrollAnchor[b.State[\"scrollProperty\" + F]], C = b.State.scrollAnchor[b.State[\"scrollProperty\" + (\"Left\" === F ? \"Top\" : \"Left\")]], T = f(o).offset()[F.toLowerCase()] + j), l = {\n                            scroll: {\n                                rootPropertyValue: !1,\n                                startValue: P,\n                                currentValue: P,\n                                endValue: T,\n                                unitType: \"\",\n                                easing: s.easing,\n                                scrollData: {\n                                    container: s.container,\n                                    direction: F,\n                                    alternateValue: C\n                                }\n                            },\n                            element: o\n                        }, b.debug && console.log(\"tweensContainer (scroll): \", l.scroll, o);\n                    } else if (\"reverse\" === A) {\n                        if (!i(o).tweensContainer) return void f.dequeue(o, s.queue);\n                        \"none\" === i(o).opts.display && (i(o).opts.display = \"auto\"), \"hidden\" === i(o).opts.visibility && (i(o).opts.visibility = \"visible\"), i(o).opts.loop = !1, i(o).opts.begin = null, i(o).opts.complete = null, v.easing || delete s.easing, v.duration || delete s.duration, s = f.extend({}, i(o).opts, s);\n                        var E = f.extend(!0, {}, i(o).tweensContainer);\n                        for (var H in E) {\n                            if (\"element\" !== H) {\n                                var N = E[H].startValue;\n                                E[H].startValue = E[H].currentValue = E[H].endValue, E[H].endValue = N, m.isEmptyObject(v) || (E[H].easing = s.easing), b.debug && console.log(\"reverse tweensContainer (\" + H + \"): \" + JSON.stringify(E[H]), o);\n                            }\n                        }l = E;\n                    } else if (\"start\" === A) {\n                        var E;\n                        i(o).tweensContainer && i(o).isAnimating === !0 && (E = i(o).tweensContainer), f.each(y, function (e, t) {\n                            if (RegExp(\"^\" + S.Lists.colors.join(\"$|^\") + \"$\").test(e)) {\n                                var r = p(t, !0),\n                                    n = r[0],\n                                    o = r[1],\n                                    i = r[2];\n                                if (S.RegEx.isHex.test(n)) {\n                                    for (var s = [\"Red\", \"Green\", \"Blue\"], l = S.Values.hexToRgb(n), u = i ? S.Values.hexToRgb(i) : a, c = 0; c < s.length; c++) {\n                                        var f = [l[c]];\n                                        o && f.push(o), u !== a && f.push(u[c]), y[e + s[c]] = f;\n                                    }\n                                    delete y[e];\n                                }\n                            }\n                        });\n                        for (var z in y) {\n                            var O = p(y[z]),\n                                q = O[0],\n                                $ = O[1],\n                                M = O[2];\n                            z = S.Names.camelCase(z);\n                            var I = S.Hooks.getRoot(z),\n                                B = !1;\n                            if (i(o).isSVG || \"tween\" === I || S.Names.prefixCheck(I)[1] !== !1 || S.Normalizations.registered[I] !== a) {\n                                (s.display !== a && null !== s.display && \"none\" !== s.display || s.visibility !== a && \"hidden\" !== s.visibility) && /opacity|filter/.test(z) && !M && 0 !== q && (M = 0), s._cacheValues && E && E[z] ? (M === a && (M = E[z].endValue + E[z].unitType), B = i(o).rootPropertyValueCache[I]) : S.Hooks.registered[z] ? M === a ? (B = S.getPropertyValue(o, I), M = S.getPropertyValue(o, z, B)) : B = S.Hooks.templates[I][1] : M === a && (M = S.getPropertyValue(o, z));\n                                var W,\n                                    G,\n                                    Y,\n                                    D = !1;\n                                if (W = d(z, M), M = W[0], Y = W[1], W = d(z, q), q = W[0].replace(/^([+-\\/*])=/, function (e, t) {\n                                    return D = t, \"\";\n                                }), G = W[1], M = parseFloat(M) || 0, q = parseFloat(q) || 0, \"%\" === G && (/^(fontSize|lineHeight)$/.test(z) ? (q /= 100, G = \"em\") : /^scale/.test(z) ? (q /= 100, G = \"\") : /(Red|Green|Blue)$/i.test(z) && (q = q / 100 * 255, G = \"\")), /[\\/*]/.test(D)) G = Y;else if (Y !== G && 0 !== M) if (0 === q) G = Y;else {\n                                    n = n || h();\n                                    var Q = /margin|padding|left|right|width|text|word|letter/i.test(z) || /X$/.test(z) || \"x\" === z ? \"x\" : \"y\";\n                                    switch (Y) {\n                                        case \"%\":\n                                            M *= \"x\" === Q ? n.percentToPxWidth : n.percentToPxHeight;\n                                            break;\n                                        case \"px\":\n                                            break;\n                                        default:\n                                            M *= n[Y + \"ToPx\"];\n                                    }\n                                    switch (G) {\n                                        case \"%\":\n                                            M *= 1 / (\"x\" === Q ? n.percentToPxWidth : n.percentToPxHeight);\n                                            break;\n                                        case \"px\":\n                                            break;\n                                        default:\n                                            M *= 1 / n[G + \"ToPx\"];\n                                    }\n                                }\n                                switch (D) {\n                                    case \"+\":\n                                        q = M + q;\n                                        break;\n                                    case \"-\":\n                                        q = M - q;\n                                        break;\n                                    case \"*\":\n                                        q = M * q;\n                                        break;\n                                    case \"/\":\n                                        q = M / q;\n                                }\n                                l[z] = {\n                                    rootPropertyValue: B,\n                                    startValue: M,\n                                    currentValue: M,\n                                    endValue: q,\n                                    unitType: G,\n                                    easing: $\n                                }, b.debug && console.log(\"tweensContainer (\" + z + \"): \" + JSON.stringify(l[z]), o);\n                            } else b.debug && console.log(\"Skipping [\" + I + \"] due to a lack of browser support.\");\n                        }\n                        l.element = o;\n                    }\n                    l.element && (S.Values.addClass(o, \"velocity-animating\"), R.push(l), \"\" === s.queue && (i(o).tweensContainer = l, i(o).opts = s), i(o).isAnimating = !0, V === w - 1 ? (b.State.calls.push([R, g, s, null, k.resolver]), b.State.isTicking === !1 && (b.State.isTicking = !0, c())) : V++);\n                }\n                var n,\n                    o = this,\n                    s = f.extend({}, b.defaults, v),\n                    l = {};\n                switch (i(o) === a && b.init(o), parseFloat(s.delay) && s.queue !== !1 && f.queue(o, s.queue, function (e) {\n                    b.velocityQueueEntryFlag = !0, i(o).delayTimer = {\n                        setTimeout: setTimeout(e, parseFloat(s.delay)),\n                        next: e\n                    };\n                }), s.duration.toString().toLowerCase()) {\n                    case \"fast\":\n                        s.duration = 200;\n                        break;\n                    case \"normal\":\n                        s.duration = h;\n                        break;\n                    case \"slow\":\n                        s.duration = 600;\n                        break;\n                    default:\n                        s.duration = parseFloat(s.duration) || 1;\n                }\n                b.mock !== !1 && (b.mock === !0 ? s.duration = s.delay = 1 : (s.duration *= parseFloat(b.mock) || 1, s.delay *= parseFloat(b.mock) || 1)), s.easing = u(s.easing, s.duration), s.begin && !m.isFunction(s.begin) && (s.begin = null), s.progress && !m.isFunction(s.progress) && (s.progress = null), s.complete && !m.isFunction(s.complete) && (s.complete = null), s.display !== a && null !== s.display && (s.display = s.display.toString().toLowerCase(), \"auto\" === s.display && (s.display = b.CSS.Values.getDisplayType(o))), s.visibility !== a && null !== s.visibility && (s.visibility = s.visibility.toString().toLowerCase()), s.mobileHA = s.mobileHA && b.State.isMobile && !b.State.isGingerbread, s.queue === !1 ? s.delay ? setTimeout(e, s.delay) : e() : f.queue(o, s.queue, function (t, r) {\n                    return r === !0 ? (k.promise && k.resolver(g), !0) : (b.velocityQueueEntryFlag = !0, void e(t));\n                }), \"\" !== s.queue && \"fx\" !== s.queue || \"inprogress\" === f.queue(o)[0] || f.dequeue(o);\n            }\n            var s,\n                l,\n                d,\n                g,\n                y,\n                v,\n                x = arguments[0] && (arguments[0].p || f.isPlainObject(arguments[0].properties) && !arguments[0].properties.names || m.isString(arguments[0].properties));\n            if (m.isWrapped(this) ? (s = !1, d = 0, g = this, l = this) : (s = !0, d = 1, g = x ? arguments[0].elements || arguments[0].e : arguments[0]), g = o(g)) {\n                x ? (y = arguments[0].properties || arguments[0].p, v = arguments[0].options || arguments[0].o) : (y = arguments[d], v = arguments[d + 1]);\n                var w = g.length,\n                    V = 0;\n                if (!/^(stop|finish)$/i.test(y) && !f.isPlainObject(v)) {\n                    var C = d + 1;\n                    v = {};\n                    for (var T = C; T < arguments.length; T++) {\n                        m.isArray(arguments[T]) || !/^(fast|normal|slow)$/i.test(arguments[T]) && !/^\\d/.test(arguments[T]) ? m.isString(arguments[T]) || m.isArray(arguments[T]) ? v.easing = arguments[T] : m.isFunction(arguments[T]) && (v.complete = arguments[T]) : v.duration = arguments[T];\n                    }\n                }\n                var k = {\n                    promise: null,\n                    resolver: null,\n                    rejecter: null\n                };\n                s && b.Promise && (k.promise = new b.Promise(function (e, t) {\n                    k.resolver = e, k.rejecter = t;\n                }));\n                var A;\n                switch (y) {\n                    case \"scroll\":\n                        A = \"scroll\";\n                        break;\n                    case \"reverse\":\n                        A = \"reverse\";\n                        break;\n                    case \"finish\":\n                    case \"stop\":\n                        f.each(g, function (e, t) {\n                            i(t) && i(t).delayTimer && (clearTimeout(i(t).delayTimer.setTimeout), i(t).delayTimer.next && i(t).delayTimer.next(), delete i(t).delayTimer);\n                        });\n                        var F = [];\n                        return f.each(b.State.calls, function (e, t) {\n                            t && f.each(t[1], function (r, n) {\n                                var o = v === a ? \"\" : v;\n                                return o === !0 || t[2].queue === o || v === a && t[2].queue === !1 ? void f.each(g, function (r, a) {\n                                    a === n && ((v === !0 || m.isString(v)) && (f.each(f.queue(a, m.isString(v) ? v : \"\"), function (e, t) {\n                                        m.isFunction(t) && t(null, !0);\n                                    }), f.queue(a, m.isString(v) ? v : \"\", [])), \"stop\" === y ? (i(a) && i(a).tweensContainer && o !== !1 && f.each(i(a).tweensContainer, function (e, t) {\n                                        t.endValue = t.currentValue;\n                                    }), F.push(e)) : \"finish\" === y && (t[2].duration = 1));\n                                }) : !0;\n                            });\n                        }), \"stop\" === y && (f.each(F, function (e, t) {\n                            p(t, !0);\n                        }), k.promise && k.resolver(g)), e();\n                    default:\n                        if (!f.isPlainObject(y) || m.isEmptyObject(y)) {\n                            if (m.isString(y) && b.Redirects[y]) {\n                                var j = f.extend({}, v),\n                                    E = j.duration,\n                                    H = j.delay || 0;\n                                return j.backwards === !0 && (g = f.extend(!0, [], g).reverse()), f.each(g, function (e, t) {\n                                    parseFloat(j.stagger) ? j.delay = H + parseFloat(j.stagger) * e : m.isFunction(j.stagger) && (j.delay = H + j.stagger.call(t, e, w)), j.drag && (j.duration = parseFloat(E) || (/^(callout|transition)/.test(y) ? 1e3 : h), j.duration = Math.max(j.duration * (j.backwards ? 1 - e / w : (e + 1) / w), .75 * j.duration, 200)), b.Redirects[y].call(t, t, j || {}, e, w, g, k.promise ? k : a);\n                                }), e();\n                            }\n                            var N = \"Velocity: First argument (\" + y + \") was not a property map, a known action, or a registered redirect. Aborting.\";\n                            return k.promise ? k.rejecter(new Error(N)) : console.log(N), e();\n                        }\n                        A = \"start\";\n                }\n                var L = {\n                    lastParent: null,\n                    lastPosition: null,\n                    lastFontSize: null,\n                    lastPercentToPxWidth: null,\n                    lastPercentToPxHeight: null,\n                    lastEmToPx: null,\n                    remToPx: null,\n                    vwToPx: null,\n                    vhToPx: null\n                },\n                    R = [];\n                f.each(g, function (e, t) {\n                    m.isNode(t) && n.call(t);\n                });\n                var z,\n                    j = f.extend({}, b.defaults, v);\n                if (j.loop = parseInt(j.loop), z = 2 * j.loop - 1, j.loop) for (var O = 0; z > O; O++) {\n                    var q = {\n                        delay: j.delay,\n                        progress: j.progress\n                    };\n                    O === z - 1 && (q.display = j.display, q.visibility = j.visibility, q.complete = j.complete), P(g, \"reverse\", q);\n                }\n                return e();\n            }\n        };\n        b = f.extend(P, b), b.animate = P;\n        var w = t.requestAnimationFrame || g;\n        return b.State.isMobile || r.hidden === a || r.addEventListener(\"visibilitychange\", function () {\n            r.hidden ? (w = function w(e) {\n                return setTimeout(function () {\n                    e(!0);\n                }, 16);\n            }, c()) : w = t.requestAnimationFrame || g;\n        }), e.Velocity = b, e !== t && (e.fn.velocity = P, e.fn.velocity.defaults = b.defaults), f.each([\"Down\", \"Up\"], function (e, t) {\n            b.Redirects[\"slide\" + t] = function (e, r, n, o, i, s) {\n                var l = f.extend({}, r),\n                    u = l.begin,\n                    c = l.complete,\n                    p = {\n                    height: \"\",\n                    marginTop: \"\",\n                    marginBottom: \"\",\n                    paddingTop: \"\",\n                    paddingBottom: \"\"\n                },\n                    d = {};\n                l.display === a && (l.display = \"Down\" === t ? \"inline\" === b.CSS.Values.getDisplayType(e) ? \"inline-block\" : \"block\" : \"none\"), l.begin = function () {\n                    u && u.call(i, i);\n                    for (var r in p) {\n                        d[r] = e.style[r];\n                        var a = b.CSS.getPropertyValue(e, r);\n                        p[r] = \"Down\" === t ? [a, 0] : [0, a];\n                    }\n                    d.overflow = e.style.overflow, e.style.overflow = \"hidden\";\n                }, l.complete = function () {\n                    for (var t in d) {\n                        e.style[t] = d[t];\n                    }c && c.call(i, i), s && s.resolver(i);\n                }, b(e, p, l);\n            };\n        }), f.each([\"In\", \"Out\"], function (e, t) {\n            b.Redirects[\"fade\" + t] = function (e, r, n, o, i, s) {\n                var l = f.extend({}, r),\n                    u = {\n                    opacity: \"In\" === t ? 1 : 0\n                },\n                    c = l.complete;\n                l.complete = n !== o - 1 ? l.begin = null : function () {\n                    c && c.call(i, i), s && s.resolver(i);\n                }, l.display === a && (l.display = \"In\" === t ? \"auto\" : \"none\"), b(this, u, l);\n            };\n        }), b;\n    }(__webpack_provided_window_dot_jQuery || window.Zepto || window, window, document);\n}));;\n!function (a, b, c, d) {\n    \"use strict\";\n\n    function k(a, b, c) {\n        return setTimeout(q(a, c), b);\n    }\n\n    function l(a, b, c) {\n        return Array.isArray(a) ? (m(a, c[b], c), !0) : !1;\n    }\n\n    function m(a, b, c) {\n        var e;\n        if (a) if (a.forEach) a.forEach(b, c);else if (a.length !== d) for (e = 0; e < a.length;) {\n            b.call(c, a[e], e, a), e++;\n        } else for (e in a) {\n            a.hasOwnProperty(e) && b.call(c, a[e], e, a);\n        }\n    }\n\n    function n(a, b, c) {\n        for (var e = Object.keys(b), f = 0; f < e.length;) {\n            (!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++;\n        }return a;\n    }\n\n    function o(a, b) {\n        return n(a, b, !0);\n    }\n\n    function p(a, b, c) {\n        var e,\n            d = b.prototype;\n        e = a.prototype = Object.create(d), e.constructor = a, e._super = d, c && n(e, c);\n    }\n\n    function q(a, b) {\n        return function () {\n            return a.apply(b, arguments);\n        };\n    }\n\n    function r(a, b) {\n        return (typeof a === 'undefined' ? 'undefined' : _typeof(a)) == g ? a.apply(b ? b[0] || d : d, b) : a;\n    }\n\n    function s(a, b) {\n        return a === d ? b : a;\n    }\n\n    function t(a, b, c) {\n        m(x(b), function (b) {\n            a.addEventListener(b, c, !1);\n        });\n    }\n\n    function u(a, b, c) {\n        m(x(b), function (b) {\n            a.removeEventListener(b, c, !1);\n        });\n    }\n\n    function v(a, b) {\n        for (; a;) {\n            if (a == b) return !0;\n            a = a.parentNode;\n        }\n        return !1;\n    }\n\n    function w(a, b) {\n        return a.indexOf(b) > -1;\n    }\n\n    function x(a) {\n        return a.trim().split(/\\s+/g);\n    }\n\n    function y(a, b, c) {\n        if (a.indexOf && !c) return a.indexOf(b);\n        for (var d = 0; d < a.length;) {\n            if (c && a[d][c] == b || !c && a[d] === b) return d;\n            d++;\n        }\n        return -1;\n    }\n\n    function z(a) {\n        return Array.prototype.slice.call(a, 0);\n    }\n\n    function A(a, b, c) {\n        for (var d = [], e = [], f = 0; f < a.length;) {\n            var g = b ? a[f][b] : a[f];\n            y(e, g) < 0 && d.push(a[f]), e[f] = g, f++;\n        }\n        return c && (d = b ? d.sort(function (a, c) {\n            return a[b] > c[b];\n        }) : d.sort()), d;\n    }\n\n    function B(a, b) {\n        for (var c, f, g = b[0].toUpperCase() + b.slice(1), h = 0; h < e.length;) {\n            if (c = e[h], f = c ? c + g : b, f in a) return f;\n            h++;\n        }\n        return d;\n    }\n\n    function D() {\n        return C++;\n    }\n\n    function E(a) {\n        var b = a.ownerDocument;\n        return b.defaultView || b.parentWindow;\n    }\n\n    function ab(a, b) {\n        var c = this;\n        this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) {\n            r(a.options.enable, [a]) && c.handler(b);\n        }, this.init();\n    }\n\n    function bb(a) {\n        var b,\n            c = a.options.inputClass;\n        return b = c ? c : H ? wb : I ? Eb : G ? Gb : rb, new b(a, cb);\n    }\n\n    function cb(a, b, c) {\n        var d = c.pointers.length,\n            e = c.changedPointers.length,\n            f = b & O && 0 === d - e,\n            g = b & (Q | R) && 0 === d - e;\n        c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, db(a, c), a.emit(\"hammer.input\", c), a.recognize(c), a.session.prevInput = c;\n    }\n\n    function db(a, b) {\n        var c = a.session,\n            d = b.pointers,\n            e = d.length;\n        c.firstInput || (c.firstInput = gb(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = gb(b) : 1 === e && (c.firstMultiple = !1);\n        var f = c.firstInput,\n            g = c.firstMultiple,\n            h = g ? g.center : f.center,\n            i = b.center = hb(d);\n        b.timeStamp = j(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = lb(h, i), b.distance = kb(h, i), eb(c, b), b.offsetDirection = jb(b.deltaX, b.deltaY), b.scale = g ? nb(g.pointers, d) : 1, b.rotation = g ? mb(g.pointers, d) : 0, fb(c, b);\n        var k = a.element;\n        v(b.srcEvent.target, k) && (k = b.srcEvent.target), b.target = k;\n    }\n\n    function eb(a, b) {\n        var c = b.center,\n            d = a.offsetDelta || {},\n            e = a.prevDelta || {},\n            f = a.prevInput || {};\n        (b.eventType === O || f.eventType === Q) && (e = a.prevDelta = {\n            x: f.deltaX || 0,\n            y: f.deltaY || 0\n        }, d = a.offsetDelta = {\n            x: c.x,\n            y: c.y\n        }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y);\n    }\n\n    function fb(a, b) {\n        var f,\n            g,\n            h,\n            j,\n            c = a.lastInterval || b,\n            e = b.timeStamp - c.timeStamp;\n        if (b.eventType != R && (e > N || c.velocity === d)) {\n            var k = c.deltaX - b.deltaX,\n                l = c.deltaY - b.deltaY,\n                m = ib(e, k, l);\n            g = m.x, h = m.y, f = i(m.x) > i(m.y) ? m.x : m.y, j = jb(k, l), a.lastInterval = b;\n        } else f = c.velocity, g = c.velocityX, h = c.velocityY, j = c.direction;\n        b.velocity = f, b.velocityX = g, b.velocityY = h, b.direction = j;\n    }\n\n    function gb(a) {\n        for (var b = [], c = 0; c < a.pointers.length;) {\n            b[c] = {\n                clientX: h(a.pointers[c].clientX),\n                clientY: h(a.pointers[c].clientY)\n            }, c++;\n        }return {\n            timeStamp: j(),\n            pointers: b,\n            center: hb(b),\n            deltaX: a.deltaX,\n            deltaY: a.deltaY\n        };\n    }\n\n    function hb(a) {\n        var b = a.length;\n        if (1 === b) return {\n            x: h(a[0].clientX),\n            y: h(a[0].clientY)\n        };\n        for (var c = 0, d = 0, e = 0; b > e;) {\n            c += a[e].clientX, d += a[e].clientY, e++;\n        }return {\n            x: h(c / b),\n            y: h(d / b)\n        };\n    }\n\n    function ib(a, b, c) {\n        return {\n            x: b / a || 0,\n            y: c / a || 0\n        };\n    }\n\n    function jb(a, b) {\n        return a === b ? S : i(a) >= i(b) ? a > 0 ? T : U : b > 0 ? V : W;\n    }\n\n    function kb(a, b, c) {\n        c || (c = $);\n        var d = b[c[0]] - a[c[0]],\n            e = b[c[1]] - a[c[1]];\n        return Math.sqrt(d * d + e * e);\n    }\n\n    function lb(a, b, c) {\n        c || (c = $);\n        var d = b[c[0]] - a[c[0]],\n            e = b[c[1]] - a[c[1]];\n        return 180 * Math.atan2(e, d) / Math.PI;\n    }\n\n    function mb(a, b) {\n        return lb(b[1], b[0], _) - lb(a[1], a[0], _);\n    }\n\n    function nb(a, b) {\n        return kb(b[0], b[1], _) / kb(a[0], a[1], _);\n    }\n\n    function rb() {\n        this.evEl = pb, this.evWin = qb, this.allow = !0, this.pressed = !1, ab.apply(this, arguments);\n    }\n\n    function wb() {\n        this.evEl = ub, this.evWin = vb, ab.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];\n    }\n\n    function Ab() {\n        this.evTarget = yb, this.evWin = zb, this.started = !1, ab.apply(this, arguments);\n    }\n\n    function Bb(a, b) {\n        var c = z(a.touches),\n            d = z(a.changedTouches);\n        return b & (Q | R) && (c = A(c.concat(d), \"identifier\", !0)), [c, d];\n    }\n\n    function Eb() {\n        this.evTarget = Db, this.targetIds = {}, ab.apply(this, arguments);\n    }\n\n    function Fb(a, b) {\n        var c = z(a.touches),\n            d = this.targetIds;\n        if (b & (O | P) && 1 === c.length) return d[c[0].identifier] = !0, [c, c];\n        var e,\n            f,\n            g = z(a.changedTouches),\n            h = [],\n            i = this.target;\n        if (f = c.filter(function (a) {\n            return v(a.target, i);\n        }), b === O) for (e = 0; e < f.length;) {\n            d[f[e].identifier] = !0, e++;\n        }for (e = 0; e < g.length;) {\n            d[g[e].identifier] && h.push(g[e]), b & (Q | R) && delete d[g[e].identifier], e++;\n        }return h.length ? [A(f.concat(h), \"identifier\", !0), h] : void 0;\n    }\n\n    function Gb() {\n        ab.apply(this, arguments);\n        var a = q(this.handler, this);\n        this.touch = new Eb(this.manager, a), this.mouse = new rb(this.manager, a);\n    }\n\n    function Pb(a, b) {\n        this.manager = a, this.set(b);\n    }\n\n    function Qb(a) {\n        if (w(a, Mb)) return Mb;\n        var b = w(a, Nb),\n            c = w(a, Ob);\n        return b && c ? Nb + \" \" + Ob : b || c ? b ? Nb : Ob : w(a, Lb) ? Lb : Kb;\n    }\n\n    function Yb(a) {\n        this.id = D(), this.manager = null, this.options = o(a || {}, this.defaults), this.options.enable = s(this.options.enable, !0), this.state = Rb, this.simultaneous = {}, this.requireFail = [];\n    }\n\n    function Zb(a) {\n        return a & Wb ? \"cancel\" : a & Ub ? \"end\" : a & Tb ? \"move\" : a & Sb ? \"start\" : \"\";\n    }\n\n    function $b(a) {\n        return a == W ? \"down\" : a == V ? \"up\" : a == T ? \"left\" : a == U ? \"right\" : \"\";\n    }\n\n    function _b(a, b) {\n        var c = b.manager;\n        return c ? c.get(a) : a;\n    }\n\n    function ac() {\n        Yb.apply(this, arguments);\n    }\n\n    function bc() {\n        ac.apply(this, arguments), this.pX = null, this.pY = null;\n    }\n\n    function cc() {\n        ac.apply(this, arguments);\n    }\n\n    function dc() {\n        Yb.apply(this, arguments), this._timer = null, this._input = null;\n    }\n\n    function ec() {\n        ac.apply(this, arguments);\n    }\n\n    function fc() {\n        ac.apply(this, arguments);\n    }\n\n    function gc() {\n        Yb.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;\n    }\n\n    function hc(a, b) {\n        return b = b || {}, b.recognizers = s(b.recognizers, hc.defaults.preset), new kc(a, b);\n    }\n\n    function kc(a, b) {\n        b = b || {}, this.options = o(b, hc.defaults), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.element = a, this.input = bb(this), this.touchAction = new Pb(this, this.options.touchAction), lc(this, !0), m(b.recognizers, function (a) {\n            var b = this.add(new a[0](a[1]));\n            a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3]);\n        }, this);\n    }\n\n    function lc(a, b) {\n        var c = a.element;\n        m(a.options.cssProps, function (a, d) {\n            c.style[B(c.style, d)] = b ? a : \"\";\n        });\n    }\n\n    function mc(a, c) {\n        var d = b.createEvent(\"Event\");\n        d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d);\n    }\n    var e = [\"\", \"webkit\", \"moz\", \"MS\", \"ms\", \"o\"],\n        f = b.createElement(\"div\"),\n        g = \"function\",\n        h = Math.round,\n        i = Math.abs,\n        j = Date.now,\n        C = 1,\n        F = /mobile|tablet|ip(ad|hone|od)|android/i,\n        G = \"ontouchstart\" in a,\n        H = B(a, \"PointerEvent\") !== d,\n        I = G && F.test(navigator.userAgent),\n        J = \"touch\",\n        K = \"pen\",\n        L = \"mouse\",\n        M = \"kinect\",\n        N = 25,\n        O = 1,\n        P = 2,\n        Q = 4,\n        R = 8,\n        S = 1,\n        T = 2,\n        U = 4,\n        V = 8,\n        W = 16,\n        X = T | U,\n        Y = V | W,\n        Z = X | Y,\n        $ = [\"x\", \"y\"],\n        _ = [\"clientX\", \"clientY\"];\n    ab.prototype = {\n        handler: function handler() {},\n        init: function init() {\n            this.evEl && t(this.element, this.evEl, this.domHandler), this.evTarget && t(this.target, this.evTarget, this.domHandler), this.evWin && t(E(this.element), this.evWin, this.domHandler);\n        },\n        destroy: function destroy() {\n            this.evEl && u(this.element, this.evEl, this.domHandler), this.evTarget && u(this.target, this.evTarget, this.domHandler), this.evWin && u(E(this.element), this.evWin, this.domHandler);\n        }\n    };\n    var ob = {\n        mousedown: O,\n        mousemove: P,\n        mouseup: Q\n    },\n        pb = \"mousedown\",\n        qb = \"mousemove mouseup\";\n    p(rb, ab, {\n        handler: function handler(a) {\n            var b = ob[a.type];\n            b & O && 0 === a.button && (this.pressed = !0), b & P && 1 !== a.which && (b = Q), this.pressed && this.allow && (b & Q && (this.pressed = !1), this.callback(this.manager, b, {\n                pointers: [a],\n                changedPointers: [a],\n                pointerType: L,\n                srcEvent: a\n            }));\n        }\n    });\n    var sb = {\n        pointerdown: O,\n        pointermove: P,\n        pointerup: Q,\n        pointercancel: R,\n        pointerout: R\n    },\n        tb = {\n        2: J,\n        3: K,\n        4: L,\n        5: M\n    },\n        ub = \"pointerdown\",\n        vb = \"pointermove pointerup pointercancel\";\n    a.MSPointerEvent && (ub = \"MSPointerDown\", vb = \"MSPointerMove MSPointerUp MSPointerCancel\"), p(wb, ab, {\n        handler: function handler(a) {\n            var b = this.store,\n                c = !1,\n                d = a.type.toLowerCase().replace(\"ms\", \"\"),\n                e = sb[d],\n                f = tb[a.pointerType] || a.pointerType,\n                g = f == J,\n                h = y(b, a.pointerId, \"pointerId\");\n            e & O && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Q | R) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, {\n                pointers: b,\n                changedPointers: [a],\n                pointerType: f,\n                srcEvent: a\n            }), c && b.splice(h, 1));\n        }\n    });\n    var xb = {\n        touchstart: O,\n        touchmove: P,\n        touchend: Q,\n        touchcancel: R\n    },\n        yb = \"touchstart\",\n        zb = \"touchstart touchmove touchend touchcancel\";\n    p(Ab, ab, {\n        handler: function handler(a) {\n            var b = xb[a.type];\n            if (b === O && (this.started = !0), this.started) {\n                var c = Bb.call(this, a, b);\n                b & (Q | R) && 0 === c[0].length - c[1].length && (this.started = !1), this.callback(this.manager, b, {\n                    pointers: c[0],\n                    changedPointers: c[1],\n                    pointerType: J,\n                    srcEvent: a\n                });\n            }\n        }\n    });\n    var Cb = {\n        touchstart: O,\n        touchmove: P,\n        touchend: Q,\n        touchcancel: R\n    },\n        Db = \"touchstart touchmove touchend touchcancel\";\n    p(Eb, ab, {\n        handler: function handler(a) {\n            var b = Cb[a.type],\n                c = Fb.call(this, a, b);\n            c && this.callback(this.manager, b, {\n                pointers: c[0],\n                changedPointers: c[1],\n                pointerType: J,\n                srcEvent: a\n            });\n        }\n    }), p(Gb, ab, {\n        handler: function handler(a, b, c) {\n            var d = c.pointerType == J,\n                e = c.pointerType == L;\n            if (d) this.mouse.allow = !1;else if (e && !this.mouse.allow) return;\n            b & (Q | R) && (this.mouse.allow = !0), this.callback(a, b, c);\n        },\n        destroy: function destroy() {\n            this.touch.destroy(), this.mouse.destroy();\n        }\n    });\n    var Hb = B(f.style, \"touchAction\"),\n        Ib = Hb !== d,\n        Jb = \"compute\",\n        Kb = \"auto\",\n        Lb = \"manipulation\",\n        Mb = \"none\",\n        Nb = \"pan-x\",\n        Ob = \"pan-y\";\n    Pb.prototype = {\n        set: function set(a) {\n            a == Jb && (a = this.compute()), Ib && (this.manager.element.style[Hb] = a), this.actions = a.toLowerCase().trim();\n        },\n        update: function update() {\n            this.set(this.manager.options.touchAction);\n        },\n        compute: function compute() {\n            var a = [];\n            return m(this.manager.recognizers, function (b) {\n                r(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()));\n            }), Qb(a.join(\" \"));\n        },\n        preventDefaults: function preventDefaults(a) {\n            if (!Ib) {\n                var b = a.srcEvent,\n                    c = a.offsetDirection;\n                if (this.manager.session.prevented) return b.preventDefault(), void 0;\n                var d = this.actions,\n                    e = w(d, Mb),\n                    f = w(d, Ob),\n                    g = w(d, Nb);\n                return e || f && c & X || g && c & Y ? this.preventSrc(b) : void 0;\n            }\n        },\n        preventSrc: function preventSrc(a) {\n            this.manager.session.prevented = !0, a.preventDefault();\n        }\n    };\n    var Rb = 1,\n        Sb = 2,\n        Tb = 4,\n        Ub = 8,\n        Vb = Ub,\n        Wb = 16,\n        Xb = 32;\n    Yb.prototype = {\n        defaults: {},\n        set: function set(a) {\n            return n(this.options, a), this.manager && this.manager.touchAction.update(), this;\n        },\n        recognizeWith: function recognizeWith(a) {\n            if (l(a, \"recognizeWith\", this)) return this;\n            var b = this.simultaneous;\n            return a = _b(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this;\n        },\n        dropRecognizeWith: function dropRecognizeWith(a) {\n            return l(a, \"dropRecognizeWith\", this) ? this : (a = _b(a, this), delete this.simultaneous[a.id], this);\n        },\n        requireFailure: function requireFailure(a) {\n            if (l(a, \"requireFailure\", this)) return this;\n            var b = this.requireFail;\n            return a = _b(a, this), -1 === y(b, a) && (b.push(a), a.requireFailure(this)), this;\n        },\n        dropRequireFailure: function dropRequireFailure(a) {\n            if (l(a, \"dropRequireFailure\", this)) return this;\n            a = _b(a, this);\n            var b = y(this.requireFail, a);\n            return b > -1 && this.requireFail.splice(b, 1), this;\n        },\n        hasRequireFailures: function hasRequireFailures() {\n            return this.requireFail.length > 0;\n        },\n        canRecognizeWith: function canRecognizeWith(a) {\n            return !!this.simultaneous[a.id];\n        },\n        emit: function emit(a) {\n            function d(d) {\n                b.manager.emit(b.options.event + (d ? Zb(c) : \"\"), a);\n            }\n            var b = this,\n                c = this.state;\n            Ub > c && d(!0), d(), c >= Ub && d(!0);\n        },\n        tryEmit: function tryEmit(a) {\n            return this.canEmit() ? this.emit(a) : (this.state = Xb, void 0);\n        },\n        canEmit: function canEmit() {\n            for (var a = 0; a < this.requireFail.length;) {\n                if (!(this.requireFail[a].state & (Xb | Rb))) return !1;\n                a++;\n            }\n            return !0;\n        },\n        recognize: function recognize(a) {\n            var b = n({}, a);\n            return r(this.options.enable, [this, b]) ? (this.state & (Vb | Wb | Xb) && (this.state = Rb), this.state = this.process(b), this.state & (Sb | Tb | Ub | Wb) && this.tryEmit(b), void 0) : (this.reset(), this.state = Xb, void 0);\n        },\n        process: function process() {},\n        getTouchAction: function getTouchAction() {},\n        reset: function reset() {}\n    }, p(ac, Yb, {\n        defaults: {\n            pointers: 1\n        },\n        attrTest: function attrTest(a) {\n            var b = this.options.pointers;\n            return 0 === b || a.pointers.length === b;\n        },\n        process: function process(a) {\n            var b = this.state,\n                c = a.eventType,\n                d = b & (Sb | Tb),\n                e = this.attrTest(a);\n            return d && (c & R || !e) ? b | Wb : d || e ? c & Q ? b | Ub : b & Sb ? b | Tb : Sb : Xb;\n        }\n    }), p(bc, ac, {\n        defaults: {\n            event: \"pan\",\n            threshold: 10,\n            pointers: 1,\n            direction: Z\n        },\n        getTouchAction: function getTouchAction() {\n            var a = this.options.direction,\n                b = [];\n            return a & X && b.push(Ob), a & Y && b.push(Nb), b;\n        },\n        directionTest: function directionTest(a) {\n            var b = this.options,\n                c = !0,\n                d = a.distance,\n                e = a.direction,\n                f = a.deltaX,\n                g = a.deltaY;\n            return e & b.direction || (b.direction & X ? (e = 0 === f ? S : 0 > f ? T : U, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? S : 0 > g ? V : W, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction;\n        },\n        attrTest: function attrTest(a) {\n            return ac.prototype.attrTest.call(this, a) && (this.state & Sb || !(this.state & Sb) && this.directionTest(a));\n        },\n        emit: function emit(a) {\n            this.pX = a.deltaX, this.pY = a.deltaY;\n            var b = $b(a.direction);\n            b && this.manager.emit(this.options.event + b, a), this._super.emit.call(this, a);\n        }\n    }), p(cc, ac, {\n        defaults: {\n            event: \"pinch\",\n            threshold: 0,\n            pointers: 2\n        },\n        getTouchAction: function getTouchAction() {\n            return [Mb];\n        },\n        attrTest: function attrTest(a) {\n            return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & Sb);\n        },\n        emit: function emit(a) {\n            if (this._super.emit.call(this, a), 1 !== a.scale) {\n                var b = a.scale < 1 ? \"in\" : \"out\";\n                this.manager.emit(this.options.event + b, a);\n            }\n        }\n    }), p(dc, Yb, {\n        defaults: {\n            event: \"press\",\n            pointers: 1,\n            time: 500,\n            threshold: 5\n        },\n        getTouchAction: function getTouchAction() {\n            return [Kb];\n        },\n        process: function process(a) {\n            var b = this.options,\n                c = a.pointers.length === b.pointers,\n                d = a.distance < b.threshold,\n                e = a.deltaTime > b.time;\n            if (this._input = a, !d || !c || a.eventType & (Q | R) && !e) this.reset();else if (a.eventType & O) this.reset(), this._timer = k(function () {\n                this.state = Vb, this.tryEmit();\n            }, b.time, this);else if (a.eventType & Q) return Vb;\n            return Xb;\n        },\n        reset: function reset() {\n            clearTimeout(this._timer);\n        },\n        emit: function emit(a) {\n            this.state === Vb && (a && a.eventType & Q ? this.manager.emit(this.options.event + \"up\", a) : (this._input.timeStamp = j(), this.manager.emit(this.options.event, this._input)));\n        }\n    }), p(ec, ac, {\n        defaults: {\n            event: \"rotate\",\n            threshold: 0,\n            pointers: 2\n        },\n        getTouchAction: function getTouchAction() {\n            return [Mb];\n        },\n        attrTest: function attrTest(a) {\n            return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & Sb);\n        }\n    }), p(fc, ac, {\n        defaults: {\n            event: \"swipe\",\n            threshold: 10,\n            velocity: .65,\n            direction: X | Y,\n            pointers: 1\n        },\n        getTouchAction: function getTouchAction() {\n            return bc.prototype.getTouchAction.call(this);\n        },\n        attrTest: function attrTest(a) {\n            var c,\n                b = this.options.direction;\n            return b & (X | Y) ? c = a.velocity : b & X ? c = a.velocityX : b & Y && (c = a.velocityY), this._super.attrTest.call(this, a) && b & a.direction && a.distance > this.options.threshold && i(c) > this.options.velocity && a.eventType & Q;\n        },\n        emit: function emit(a) {\n            var b = $b(a.direction);\n            b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a);\n        }\n    }), p(gc, Yb, {\n        defaults: {\n            event: \"tap\",\n            pointers: 1,\n            taps: 1,\n            interval: 300,\n            time: 250,\n            threshold: 2,\n            posThreshold: 10\n        },\n        getTouchAction: function getTouchAction() {\n            return [Lb];\n        },\n        process: function process(a) {\n            var b = this.options,\n                c = a.pointers.length === b.pointers,\n                d = a.distance < b.threshold,\n                e = a.deltaTime < b.time;\n            if (this.reset(), a.eventType & O && 0 === this.count) return this.failTimeout();\n            if (d && e && c) {\n                if (a.eventType != Q) return this.failTimeout();\n                var f = this.pTime ? a.timeStamp - this.pTime < b.interval : !0,\n                    g = !this.pCenter || kb(this.pCenter, a.center) < b.posThreshold;\n                this.pTime = a.timeStamp, this.pCenter = a.center, g && f ? this.count += 1 : this.count = 1, this._input = a;\n                var h = this.count % b.taps;\n                if (0 === h) return this.hasRequireFailures() ? (this._timer = k(function () {\n                    this.state = Vb, this.tryEmit();\n                }, b.interval, this), Sb) : Vb;\n            }\n            return Xb;\n        },\n        failTimeout: function failTimeout() {\n            return this._timer = k(function () {\n                this.state = Xb;\n            }, this.options.interval, this), Xb;\n        },\n        reset: function reset() {\n            clearTimeout(this._timer);\n        },\n        emit: function emit() {\n            this.state == Vb && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));\n        }\n    }), hc.VERSION = \"2.0.4\", hc.defaults = {\n        domEvents: !1,\n        touchAction: Jb,\n        enable: !0,\n        inputTarget: null,\n        inputClass: null,\n        preset: [[ec, {\n            enable: !1\n        }], [cc, {\n            enable: !1\n        }, [\"rotate\"]], [fc, {\n            direction: X\n        }], [bc, {\n            direction: X\n        }, [\"swipe\"]], [gc], [gc, {\n            event: \"doubletap\",\n            taps: 2\n        }, [\"tap\"]], [dc]],\n        cssProps: {\n            userSelect: \"default\",\n            touchSelect: \"none\",\n            touchCallout: \"none\",\n            contentZooming: \"none\",\n            userDrag: \"none\",\n            tapHighlightColor: \"rgba(0,0,0,0)\"\n        }\n    };\n    var ic = 1,\n        jc = 2;\n    kc.prototype = {\n        set: function set(a) {\n            return n(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this;\n        },\n        stop: function stop(a) {\n            this.session.stopped = a ? jc : ic;\n        },\n        recognize: function recognize(a) {\n            var b = this.session;\n            if (!b.stopped) {\n                this.touchAction.preventDefaults(a);\n                var c,\n                    d = this.recognizers,\n                    e = b.curRecognizer;\n                (!e || e && e.state & Vb) && (e = b.curRecognizer = null);\n                for (var f = 0; f < d.length;) {\n                    c = d[f], b.stopped === jc || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (Sb | Tb | Ub) && (e = b.curRecognizer = c), f++;\n                }\n            }\n        },\n        get: function get(a) {\n            if (a instanceof Yb) return a;\n            for (var b = this.recognizers, c = 0; c < b.length; c++) {\n                if (b[c].options.event == a) return b[c];\n            }return null;\n        },\n        add: function add(a) {\n            if (l(a, \"add\", this)) return this;\n            var b = this.get(a.options.event);\n            return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a;\n        },\n        remove: function remove(a) {\n            if (l(a, \"remove\", this)) return this;\n            var b = this.recognizers;\n            return a = this.get(a), b.splice(y(b, a), 1), this.touchAction.update(), this;\n        },\n        on: function on(a, b) {\n            var c = this.handlers;\n            return m(x(a), function (a) {\n                c[a] = c[a] || [], c[a].push(b);\n            }), this;\n        },\n        off: function off(a, b) {\n            var c = this.handlers;\n            return m(x(a), function (a) {\n                b ? c[a].splice(y(c[a], b), 1) : delete c[a];\n            }), this;\n        },\n        emit: function emit(a, b) {\n            this.options.domEvents && mc(a, b);\n            var c = this.handlers[a] && this.handlers[a].slice();\n            if (c && c.length) {\n                b.type = a, b.preventDefault = function () {\n                    b.srcEvent.preventDefault();\n                };\n                for (var d = 0; d < c.length;) {\n                    c[d](b), d++;\n                }\n            }\n        },\n        destroy: function destroy() {\n            this.element && lc(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;\n        }\n    }, n(hc, {\n        INPUT_START: O,\n        INPUT_MOVE: P,\n        INPUT_END: Q,\n        INPUT_CANCEL: R,\n        STATE_POSSIBLE: Rb,\n        STATE_BEGAN: Sb,\n        STATE_CHANGED: Tb,\n        STATE_ENDED: Ub,\n        STATE_RECOGNIZED: Vb,\n        STATE_CANCELLED: Wb,\n        STATE_FAILED: Xb,\n        DIRECTION_NONE: S,\n        DIRECTION_LEFT: T,\n        DIRECTION_RIGHT: U,\n        DIRECTION_UP: V,\n        DIRECTION_DOWN: W,\n        DIRECTION_HORIZONTAL: X,\n        DIRECTION_VERTICAL: Y,\n        DIRECTION_ALL: Z,\n        Manager: kc,\n        Input: ab,\n        TouchAction: Pb,\n        TouchInput: Eb,\n        MouseInput: rb,\n        PointerEventInput: wb,\n        TouchMouseInput: Gb,\n        SingleTouchInput: Ab,\n        Recognizer: Yb,\n        AttrRecognizer: ac,\n        Tap: gc,\n        Pan: bc,\n        Swipe: fc,\n        Pinch: cc,\n        Rotate: ec,\n        Press: dc,\n        on: t,\n        off: u,\n        each: m,\n        merge: o,\n        extend: n,\n        inherit: p,\n        bindFn: q,\n        prefixed: B\n    }), ( false ? undefined : _typeof(__webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\"))) == g && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\") ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return hc;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : \"undefined\" != typeof module && module.exports ? module.exports = hc : a[c] = hc;\n}(window, document, \"Hammer\");;\n(function (factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! hammerjs */ \"./node_modules/hammerjs/hammer.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(function ($, Hammer) {\n    function hammerify(el, options) {\n        var $el = $(el);\n        if (!$el.data(\"hammer\")) {\n            $el.data(\"hammer\", new Hammer($el[0], options));\n        }\n    }\n\n    $.fn.hammer = function (options) {\n        return this.each(function () {\n            hammerify(this, options);\n        });\n    };\n\n    // extend the emit method to also trigger jQuery events\n    Hammer.Manager.prototype.emit = function (originalEmit) {\n        return function (type, data) {\n            originalEmit.call(this, type, data);\n            $(this.element).trigger({\n                type: type,\n                gesture: data\n            });\n        };\n    }(Hammer.Manager.prototype.emit);\n});; // Required for Meteor package, the use of window prevents export by Meteor\n(function (window) {\n    if (window.Package) {\n        Materialize = {};\n    } else {\n        window.Materialize = {};\n    }\n})(window);\n\n// Unique ID\nMaterialize.guid = function () {\n    function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n    return function () {\n        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n    };\n}();\n\nMaterialize.elementOrParentIsFixed = function (element) {\n    var $element = $(element);\n    var $checkElements = $element.add($element.parents());\n    var isFixed = false;\n    $checkElements.each(function () {\n        if ($(this).css(\"position\") === \"fixed\") {\n            isFixed = true;\n            return false;\n        }\n    });\n    return isFixed;\n};\n\n// Velocity has conflicts when loaded with jQuery, this will check for it\nvar Vel;\nif ($) {\n    Vel = $.Velocity;\n} else if (jQuery) {\n    Vel = jQuery.Velocity;\n} else {\n    Vel = Velocity;\n}\n\n(function ($) {\n    $.fn.collapsible = function (options) {\n        var defaults = {\n            accordion: undefined\n        };\n\n        options = $.extend(defaults, options);\n\n        return this.each(function () {\n\n            var $this = $(this);\n\n            var $panel_headers = $(this).find('> li > .collapsible-header');\n\n            var collapsible_type = $this.data(\"collapsible\");\n\n            // Turn off any existing event handlers\n            $this.off('click.collapse', '> li > .collapsible-header');\n            $panel_headers.off('click.collapse');\n\n            /****************\r\n             Helper Functions\r\n             ****************/\n\n            // Accordion Open\n            function accordionOpen(object) {\n                $panel_headers = $this.find('> li > .collapsible-header');\n                if (object.hasClass('active')) {\n                    object.parent().addClass('active');\n                } else {\n                    object.parent().removeClass('active');\n                }\n                if (object.parent().hasClass('active')) {\n                    object.siblings('.collapsible-body').stop(true, false).slideDown({\n                        duration: 350,\n                        easing: \"easeOutQuart\",\n                        queue: false,\n                        complete: function complete() {\n                            $(this).css('height', '');\n                        }\n                    });\n                } else {\n                    object.siblings('.collapsible-body').stop(true, false).slideUp({\n                        duration: 350,\n                        easing: \"easeOutQuart\",\n                        queue: false,\n                        complete: function complete() {\n                            $(this).css('height', '');\n                        }\n                    });\n                }\n\n                $panel_headers.not(object).removeClass('active').parent().removeClass('active');\n                $panel_headers.not(object).parent().children('.collapsible-body').stop(true, false).slideUp({\n                    duration: 350,\n                    easing: \"easeOutQuart\",\n                    queue: false,\n                    complete: function complete() {\n                        $(this).css('height', '');\n                    }\n                });\n            }\n\n            // Expandable Open\n            function expandableOpen(object) {\n                if (object.hasClass('active')) {\n                    object.parent().addClass('active');\n                } else {\n                    object.parent().removeClass('active');\n                }\n                if (object.parent().hasClass('active')) {\n                    object.siblings('.collapsible-body').stop(true, false).slideDown({\n                        duration: 350,\n                        easing: \"easeOutQuart\",\n                        queue: false,\n                        complete: function complete() {\n                            $(this).css('height', '');\n                        }\n                    });\n                } else {\n                    object.siblings('.collapsible-body').stop(true, false).slideUp({\n                        duration: 350,\n                        easing: \"easeOutQuart\",\n                        queue: false,\n                        complete: function complete() {\n                            $(this).css('height', '');\n                        }\n                    });\n                }\n            }\n\n            /**\r\n             * Check if object is children of panel header\r\n             * @param  {Object}  object Jquery object\r\n             * @return {Boolean} true if it is children\r\n             */\n            function isChildrenOfPanelHeader(object) {\n\n                var panelHeader = getPanelHeader(object);\n\n                return panelHeader.length > 0;\n            }\n\n            /**\r\n             * Get panel header from a children element\r\n             * @param  {Object} object Jquery object\r\n             * @return {Object} panel header object\r\n             */\n            function getPanelHeader(object) {\n\n                return object.closest('li > .collapsible-header');\n            }\n\n            /*****  End Helper Functions  *****/\n\n            // Add click handler to only direct collapsible header children\n            $this.on('click.collapse', '> li > .collapsible-header', function (e) {\n                var $header = $(this),\n                    element = $(e.target);\n\n                if (isChildrenOfPanelHeader(element)) {\n                    element = getPanelHeader(element);\n                }\n\n                element.toggleClass('active');\n\n                if (options.accordion || collapsible_type === \"accordion\" || collapsible_type === undefined) {\n                    // Handle Accordion\n                    accordionOpen(element);\n                } else {\n                    // Handle Expandables\n                    expandableOpen(element);\n\n                    if ($header.hasClass('active')) {\n                        expandableOpen($header);\n                    }\n                }\n            });\n\n            // Open first active\n            var $panel_headers = $this.find('> li > .collapsible-header');\n            if (options.accordion || collapsible_type === \"accordion\" || collapsible_type === undefined) {\n                // Handle Accordion\n                accordionOpen($panel_headers.filter('.active').first());\n            } else {\n                // Handle Expandables\n                $panel_headers.filter('.active').each(function () {\n                    expandableOpen($(this));\n                });\n            }\n        });\n    };\n\n    $(document).ready(function () {\n        $('.collapsible').collapsible();\n    });\n})(jQuery);\n(function ($) {\n\n    // Add posibility to scroll to selected option\n    // usefull for select for header\n    $.fn.scrollTo = function (elem) {\n        $(this).scrollTop($(this).scrollTop() - $(this).offset().top + $(elem).offset().top);\n        return this;\n    };\n\n    $.fn.dropdown = function (option) {\n        var defaults = {\n            inDuration: 300,\n            outDuration: 225,\n            constrain_width: true, // Constrains width of dropdown to the activator\n            hover: false,\n            gutter: 0, // Spacing from edge\n            belowOrigin: false,\n            alignment: 'left'\n        };\n\n        this.each(function () {\n            var origin = $(this);\n            var options = $.extend({}, defaults, option);\n            var isFocused = false;\n\n            // Dropdown menu\n            var activates = $(\"#\" + origin.attr('data-activates'));\n\n            function updateOptions() {\n                if (origin.data('induration') !== undefined) options.inDuration = origin.data('inDuration');\n                if (origin.data('outduration') !== undefined) options.outDuration = origin.data('outDuration');\n                if (origin.data('constrainwidth') !== undefined) options.constrain_width = origin.data('constrainwidth');\n                if (origin.data('hover') !== undefined) options.hover = origin.data('hover');\n                if (origin.data('gutter') !== undefined) options.gutter = origin.data('gutter');\n                if (origin.data('beloworigin') !== undefined) options.belowOrigin = origin.data('beloworigin');\n                if (origin.data('alignment') !== undefined) options.alignment = origin.data('alignment');\n            }\n\n            updateOptions();\n\n            // Attach dropdown to its activator\n            origin.after(activates);\n\n            /*\r\n             Helper function to position and resize dropdown.\r\n             Used in hover and click handler.\r\n             */\n            function placeDropdown(eventType) {\n                // Check for simultaneous focus and click events.\n                if (eventType === 'focus') {\n                    isFocused = true;\n                }\n\n                // Check html data attributes\n                updateOptions();\n\n                // Set Dropdown state\n                activates.addClass('active');\n                origin.addClass('active');\n\n                // Constrain width\n                if (options.constrain_width === true) {\n                    activates.css('width', origin.outerWidth());\n                } else {\n                    activates.css('white-space', 'nowrap');\n                }\n\n                // Offscreen detection\n                var windowHeight = window.innerHeight;\n                var originHeight = origin.innerHeight();\n                var offsetLeft = origin.offset().left;\n                var offsetTop = origin.offset().top - $(window).scrollTop();\n                var currAlignment = options.alignment;\n                var gutterSpacing = 0;\n                var leftPosition = 0;\n\n                // Below Origin\n                var verticalOffset = 0;\n                if (options.belowOrigin === true) {\n                    verticalOffset = originHeight;\n                }\n\n                // Check for scrolling positioned container.\n                var scrollOffset = 0;\n                var wrapper = origin.parent();\n                if (!wrapper.is('body') && wrapper[0].scrollHeight > wrapper[0].clientHeight) {\n                    scrollOffset = wrapper[0].scrollTop;\n                }\n\n                if (offsetLeft + activates.innerWidth() > $(window).width()) {\n                    // Dropdown goes past screen on right, force right alignment\n                    currAlignment = 'right';\n                } else if (offsetLeft - activates.innerWidth() + origin.innerWidth() < 0) {\n                    // Dropdown goes past screen on left, force left alignment\n                    currAlignment = 'left';\n                }\n                // Vertical bottom offscreen detection\n                if (offsetTop + activates.innerHeight() > windowHeight) {\n                    // If going upwards still goes offscreen, just crop height of dropdown.\n                    if (offsetTop + originHeight - activates.innerHeight() < 0) {\n                        var adjustedHeight = windowHeight - offsetTop - verticalOffset;\n                        activates.css('max-height', adjustedHeight);\n                    } else {\n                        // Flow upwards.\n                        if (!verticalOffset) {\n                            verticalOffset += originHeight;\n                        }\n                        verticalOffset -= activates.innerHeight();\n                    }\n                }\n\n                // Handle edge alignment\n                if (currAlignment === 'left') {\n                    gutterSpacing = options.gutter;\n                    leftPosition = origin.position().left + gutterSpacing;\n                } else if (currAlignment === 'right') {\n                    var offsetRight = origin.position().left + origin.outerWidth() - activates.outerWidth();\n                    gutterSpacing = -options.gutter;\n                    leftPosition = offsetRight + gutterSpacing;\n                }\n\n                // Position dropdown\n                activates.css({\n                    position: 'absolute',\n                    top: origin.position().top + verticalOffset + scrollOffset,\n                    left: leftPosition\n                });\n\n                // Show dropdown\n                activates.stop(true, true).css('opacity', 0).slideDown({\n                    queue: false,\n                    duration: options.inDuration,\n                    easing: 'easeOutCubic',\n                    complete: function complete() {\n                        $(this).css('height', '');\n                    }\n                }).animate({\n                    opacity: 1\n                }, {\n                    queue: false,\n                    duration: options.inDuration,\n                    easing: 'easeOutSine'\n                });\n            }\n\n            function hideDropdown() {\n                // Check for simultaneous focus and click events.\n                isFocused = false;\n                activates.fadeOut(options.outDuration);\n                activates.removeClass('active');\n                origin.removeClass('active');\n                setTimeout(function () {\n                    activates.css('max-height', '');\n                }, options.outDuration);\n            }\n\n            // Hover\n            if (options.hover) {\n                var open = false;\n                origin.unbind('click.' + origin.attr('id'));\n                // Hover handler to show dropdown\n                origin.on('mouseenter', function (e) {\n                    // Mouse over\n                    if (open === false) {\n                        placeDropdown();\n                        open = true;\n                    }\n                });\n                origin.on('mouseleave', function (e) {\n                    // If hover on origin then to something other than dropdown content, then close\n                    var toEl = e.toElement || e.relatedTarget; // added browser compatibility for target element\n                    if (!$(toEl).closest('.dropdown-content').is(activates)) {\n                        activates.stop(true, true);\n                        hideDropdown();\n                        open = false;\n                    }\n                });\n\n                activates.on('mouseleave', function (e) {\n                    // Mouse out\n                    var toEl = e.toElement || e.relatedTarget;\n                    if (!$(toEl).closest('.dropdown-button').is(origin)) {\n                        activates.stop(true, true);\n                        hideDropdown();\n                        open = false;\n                    }\n                });\n\n                // Click\n            } else {\n                // Click handler to show dropdown\n                origin.unbind('click.' + origin.attr('id'));\n                origin.bind('click.' + origin.attr('id'), function (e) {\n                    if (!isFocused) {\n                        if (origin[0] == e.currentTarget && !origin.hasClass('active') && $(e.target).closest('.dropdown-content').length === 0) {\n                            e.preventDefault(); // Prevents button click from moving window\n                            placeDropdown('click');\n                        }\n                        // If origin is clicked and menu is open, close menu\n                        else if (origin.hasClass('active')) {\n                                hideDropdown();\n                                $(document).unbind('click.' + activates.attr('id') + ' touchstart.' + activates.attr('id'));\n                            }\n                        // If menu open, add click close handler to document\n                        if (activates.hasClass('active')) {\n                            $(document).bind('click.' + activates.attr('id') + ' touchstart.' + activates.attr('id'), function (e) {\n                                if (!activates.is(e.target) && !origin.is(e.target) && !origin.find(e.target).length) {\n                                    hideDropdown();\n                                    $(document).unbind('click.' + activates.attr('id') + ' touchstart.' + activates.attr('id'));\n                                }\n                            });\n                        }\n                    }\n                });\n            } // End else\n\n            // Listen to open and close event - useful for select component\n            origin.on('open', function (e, eventType) {\n                placeDropdown(eventType);\n            });\n            origin.on('close', hideDropdown);\n        });\n    }; // End dropdown plugin\n\n    $(document).ready(function () {\n        $('.dropdown-button').dropdown();\n    });\n})(jQuery);\n\n(function ($) {\n    var _stack = 0,\n        _lastID = 0,\n        _generateID = function _generateID() {\n        _lastID++;\n        return 'materialize-lean-overlay-' + _lastID;\n    };\n\n    $.fn.extend({\n        openModal: function openModal(options) {\n            var $body = $('body');\n            var oldWidth = $body.innerWidth();\n            $body.css('overflow', 'hidden');\n            $body.width(oldWidth);\n\n            var defaults = {\n                opacity: 0.5,\n                in_duration: 350,\n                out_duration: 250,\n                ready: undefined,\n                complete: undefined,\n                dismissible: true,\n                starting_top: '4%'\n            };\n            var $modal = $(this);\n\n            if ($modal.hasClass('open')) {\n                return;\n            }\n\n            var overlayID = _generateID();\n            var overlay = $('<div class=\"lean-overlay\"></div>');\n            var lStack = ++_stack;\n\n            // Store a reference of the overlay\n            overlay.attr('id', overlayID).css('z-index', 1000 + lStack * 2);\n            $modal.data('overlay-id', overlayID).css('z-index', 1000 + lStack * 2 + 1);\n            $modal.addClass('open');\n\n            $body.append(overlay);\n\n            // Override defaults\n            options = $.extend(defaults, options);\n            if (options.dismissible) {\n                overlay.click(function () {\n                    $modal.closeModal(options);\n                });\n                // Return on ESC\n                $(document).on('keyup.leanModal' + overlayID, function (e) {\n                    if (e.keyCode === 27) {\n                        // ESC key\n                        $modal.closeModal(options);\n                    }\n                });\n            }\n\n            $modal.find(\".modal-close\").on('click.close', function (e) {\n                $modal.closeModal(options);\n            });\n\n            overlay.css({\n                display: \"block\",\n                opacity: 0\n            });\n\n            $modal.css({\n                display: \"block\",\n                opacity: 0\n            });\n\n            overlay.velocity({\n                opacity: options.opacity\n            }, {\n                duration: options.in_duration,\n                queue: false,\n                ease: \"easeOutCubic\"\n            });\n\n            $modal.data('associated-overlay', overlay[0]);\n\n            // Define Bottom Sheet animation\n            if ($modal.hasClass('bottom-sheet')) {\n                $modal.velocity({\n                    bottom: \"0\",\n                    opacity: 1\n                }, {\n                    duration: options.in_duration,\n                    queue: false,\n                    ease: \"easeOutCubic\",\n                    // Handle modal ready callback\n                    complete: function complete() {\n                        if (typeof options.ready === \"function\") {\n                            options.ready();\n                        }\n                    }\n                });\n            } else {\n                $.Velocity.hook($modal, \"scaleX\", 0.7);\n                $modal.css({\n                    top: options.starting_top\n                });\n                $modal.velocity({\n                    top: \"10%\",\n                    opacity: 1,\n                    scaleX: '1'\n                }, {\n                    duration: options.in_duration,\n                    queue: false,\n                    ease: \"easeOutCubic\",\n                    // Handle modal ready callback\n                    complete: function complete() {\n                        if (typeof options.ready === \"function\") {\n                            options.ready();\n                        }\n                    }\n                });\n            }\n        }\n    });\n\n    $.fn.extend({\n        closeModal: function closeModal(options) {\n            var defaults = {\n                out_duration: 250,\n                complete: undefined\n            },\n                $body = $('body'),\n                $modal = $(this),\n                overlayID = $modal.data('overlay-id'),\n                $overlay = $('#' + overlayID);\n            $modal.removeClass('open');\n\n            options = $.extend(defaults, options);\n\n            // Enable scrolling\n            $body.css({\n                overflow: '',\n                width: ''\n            });\n\n            $body.removeClass('stop-flow');\n\n            $modal.find('.modal-close').off('click.close');\n            $(document).off('keyup.leanModal' + overlayID);\n\n            $overlay.velocity({\n                opacity: 0\n            }, {\n                duration: options.out_duration,\n                queue: false,\n                ease: \"easeOutQuart\"\n            });\n\n            // Define Bottom Sheet animation\n            if ($modal.hasClass('bottom-sheet')) {\n                $modal.velocity({\n                    bottom: \"-100%\",\n                    opacity: 0\n                }, {\n                    duration: options.out_duration,\n                    queue: false,\n                    ease: \"easeOutCubic\",\n                    // Handle modal ready callback\n                    complete: function complete() {\n                        $overlay.css({\n                            display: \"none\"\n                        });\n\n                        // Call complete callback\n                        if (typeof options.complete === \"function\") {\n                            options.complete();\n                        }\n                        $overlay.remove();\n                        _stack--;\n                    }\n                });\n            } else {\n                $modal.velocity({\n                    top: options.starting_top,\n                    opacity: 0,\n                    scaleX: 0.7\n                }, {\n                    duration: options.out_duration,\n                    complete: function complete() {\n\n                        $(this).css('display', 'none');\n                        // Call complete callback\n                        if (typeof options.complete === \"function\") {\n                            options.complete();\n                        }\n                        $overlay.remove();\n                        _stack--;\n                    }\n                });\n            }\n        }\n    });\n\n    $.fn.extend({\n        leanModal: function leanModal(option) {\n            return this.each(function () {\n\n                var defaults = {\n                    starting_top: '4%'\n                },\n\n                // Override defaults\n                options = $.extend(defaults, option);\n\n                // Close Handlers\n                $(this).click(function (e) {\n                    options.starting_top = ($(this).offset().top - $(window).scrollTop()) / 1.15;\n                    var modal_id = $(this).attr(\"href\") || '#' + $(this).data('target');\n                    $(modal_id).openModal(options);\n                    e.preventDefault();\n                }); // done set on click\n            }); // done return\n        }\n    });\n})(jQuery);\n\n(function ($) {\n\n    $.fn.materialbox = function () {\n\n        return this.each(function () {\n\n            if ($(this).hasClass('initialized')) {\n                return;\n            }\n\n            $(this).addClass('initialized');\n\n            var overlayActive = false;\n            var doneAnimating = true;\n            var inDuration = 275;\n            var outDuration = 200;\n            var origin = $(this);\n            var placeholder = $('<div></div>').addClass('material-placeholder');\n            var originalWidth = 0;\n            var originalHeight = 0;\n            var ancestorsChanged;\n            var ancestor;\n            origin.wrap(placeholder);\n\n            origin.on('click', function () {\n                var placeholder = origin.parent('.material-placeholder');\n                var windowWidth = window.innerWidth;\n                var windowHeight = window.innerHeight;\n                var originalWidth = origin.width();\n                var originalHeight = origin.height();\n\n                // If already modal, return to original\n                if (doneAnimating === false) {\n                    returnToOriginal();\n                    return false;\n                } else if (overlayActive && doneAnimating === true) {\n                    returnToOriginal();\n                    return false;\n                }\n\n                // Set states\n                doneAnimating = false;\n                origin.addClass('active');\n                overlayActive = true;\n\n                // Set positioning for placeholder\n                placeholder.css({\n                    width: placeholder[0].getBoundingClientRect().width,\n                    height: placeholder[0].getBoundingClientRect().height,\n                    position: 'relative',\n                    top: 0,\n                    left: 0\n                });\n\n                // Find ancestor with overflow: hidden; and remove it\n                ancestorsChanged = undefined;\n                ancestor = placeholder[0].parentNode;\n                var count = 0;\n                while (ancestor !== null && !$(ancestor).is(document)) {\n                    var curr = $(ancestor);\n                    if (curr.css('overflow') !== 'visible') {\n                        curr.css('overflow', 'visible');\n                        if (ancestorsChanged === undefined) {\n                            ancestorsChanged = curr;\n                        } else {\n                            ancestorsChanged = ancestorsChanged.add(curr);\n                        }\n                    }\n                    ancestor = ancestor.parentNode;\n                }\n\n                // Set css on origin\n                origin.css({\n                    position: 'absolute',\n                    'z-index': 1000\n                }).data('width', originalWidth).data('height', originalHeight);\n\n                // Add overlay\n                var overlay = $('<div id=\"materialbox-overlay\"></div>').css({\n                    opacity: 0\n                }).click(function () {\n                    if (doneAnimating === true) returnToOriginal();\n                });\n                // Animate Overlay\n                // Put before in origin image to preserve z-index layering.\n                origin.before(overlay);\n                overlay.velocity({\n                    opacity: 1\n                }, {\n                    duration: inDuration,\n                    queue: false,\n                    easing: 'easeOutQuad'\n                });\n\n                // Add and animate caption if it exists\n                if (origin.data('caption') !== \"\") {\n                    var $photo_caption = $('<div class=\"materialbox-caption\"></div>');\n                    $photo_caption.text(origin.data('caption'));\n                    $('body').append($photo_caption);\n                    $photo_caption.css({\n                        \"display\": \"inline\"\n                    });\n                    $photo_caption.velocity({\n                        opacity: 1\n                    }, {\n                        duration: inDuration,\n                        queue: false,\n                        easing: 'easeOutQuad'\n                    });\n                }\n\n                // Resize Image\n                var ratio = 0;\n                var widthPercent = originalWidth / windowWidth;\n                var heightPercent = originalHeight / windowHeight;\n                var newWidth = 0;\n                var newHeight = 0;\n\n                if (widthPercent > heightPercent) {\n                    ratio = originalHeight / originalWidth;\n                    newWidth = windowWidth * 0.9;\n                    newHeight = windowWidth * 0.9 * ratio;\n                } else {\n                    ratio = originalWidth / originalHeight;\n                    newWidth = windowHeight * 0.9 * ratio;\n                    newHeight = windowHeight * 0.9;\n                }\n\n                // Animate image + set z-index\n                if (origin.hasClass('responsive-img')) {\n                    origin.velocity({\n                        'max-width': newWidth,\n                        'width': originalWidth\n                    }, {\n                        duration: 0,\n                        queue: false,\n                        complete: function complete() {\n                            origin.css({\n                                left: 0,\n                                top: 0\n                            }).velocity({\n                                height: newHeight,\n                                width: newWidth,\n                                left: $(document).scrollLeft() + windowWidth / 2 - origin.parent('.material-placeholder').offset().left - newWidth / 2,\n                                top: $(document).scrollTop() + windowHeight / 2 - origin.parent('.material-placeholder').offset().top - newHeight / 2\n                            }, {\n                                duration: inDuration,\n                                queue: false,\n                                easing: 'easeOutQuad',\n                                complete: function complete() {\n                                    doneAnimating = true;\n                                }\n                            });\n                        } // End Complete\n                    }); // End Velocity\n                } else {\n                    origin.css('left', 0).css('top', 0).velocity({\n                        height: newHeight,\n                        width: newWidth,\n                        left: $(document).scrollLeft() + windowWidth / 2 - origin.parent('.material-placeholder').offset().left - newWidth / 2,\n                        top: $(document).scrollTop() + windowHeight / 2 - origin.parent('.material-placeholder').offset().top - newHeight / 2\n                    }, {\n                        duration: inDuration,\n                        queue: false,\n                        easing: 'easeOutQuad',\n                        complete: function complete() {\n                            doneAnimating = true;\n                        }\n                    }); // End Velocity\n                }\n            }); // End origin on click\n\n\n            // Return on scroll\n            $(window).scroll(function () {\n                if (overlayActive) {\n                    returnToOriginal();\n                }\n            });\n\n            // Return on ESC\n            $(document).keyup(function (e) {\n\n                if (e.keyCode === 27 && doneAnimating === true) {\n                    // ESC key\n                    if (overlayActive) {\n                        returnToOriginal();\n                    }\n                }\n            });\n\n            // This function returns the modaled image to the original spot\n            function returnToOriginal() {\n\n                doneAnimating = false;\n\n                var placeholder = origin.parent('.material-placeholder');\n                var windowWidth = window.innerWidth;\n                var windowHeight = window.innerHeight;\n                var originalWidth = origin.data('width');\n                var originalHeight = origin.data('height');\n\n                origin.velocity(\"stop\", true);\n                $('#materialbox-overlay').velocity(\"stop\", true);\n                $('.materialbox-caption').velocity(\"stop\", true);\n\n                $('#materialbox-overlay').velocity({\n                    opacity: 0\n                }, {\n                    duration: outDuration, // Delay prevents animation overlapping\n                    queue: false,\n                    easing: 'easeOutQuad',\n                    complete: function complete() {\n                        // Remove Overlay\n                        overlayActive = false;\n                        $(this).remove();\n                    }\n                });\n\n                // Resize Image\n                origin.velocity({\n                    width: originalWidth,\n                    height: originalHeight,\n                    left: 0,\n                    top: 0\n                }, {\n                    duration: outDuration,\n                    queue: false,\n                    easing: 'easeOutQuad'\n                });\n\n                // Remove Caption + reset css settings on image\n                $('.materialbox-caption').velocity({\n                    opacity: 0\n                }, {\n                    duration: outDuration, // Delay prevents animation overlapping\n                    queue: false,\n                    easing: 'easeOutQuad',\n                    complete: function complete() {\n                        placeholder.css({\n                            height: '',\n                            width: '',\n                            position: '',\n                            top: '',\n                            left: ''\n                        });\n\n                        origin.css({\n                            height: '',\n                            top: '',\n                            left: '',\n                            width: '',\n                            'max-width': '',\n                            position: '',\n                            'z-index': ''\n                        });\n\n                        // Remove class\n                        origin.removeClass('active');\n                        doneAnimating = true;\n                        $(this).remove();\n\n                        // Remove overflow overrides on ancestors\n                        if (ancestorsChanged) {\n                            ancestorsChanged.css('overflow', '');\n                        }\n                    }\n                });\n            }\n        });\n    };\n\n    $(document).ready(function () {\n        $('.materialboxed').materialbox();\n    });\n})(jQuery);;\n(function ($) {\n\n    $.fn.parallax = function () {\n        var window_width = $(window).width();\n        // Parallax Scripts\n        return this.each(function (i) {\n            var $this = $(this);\n            $this.addClass('parallax');\n\n            function updateParallax(initial) {\n                var container_height;\n                if (window_width < 601) {\n                    container_height = $this.height() > 0 ? $this.height() : $this.children(\"img\").height();\n                } else {\n                    container_height = $this.height() > 0 ? $this.height() : 500;\n                }\n                var $img = $this.children(\"img\").first();\n                var img_height = $img.height();\n                var parallax_dist = img_height - container_height;\n                var bottom = $this.offset().top + container_height;\n                var top = $this.offset().top;\n                var scrollTop = $(window).scrollTop();\n                var windowHeight = window.innerHeight;\n                var windowBottom = scrollTop + windowHeight;\n                var percentScrolled = (windowBottom - top) / (container_height + windowHeight);\n                var parallax = Math.round(parallax_dist * percentScrolled);\n\n                if (initial) {\n                    $img.css('display', 'block');\n                }\n                if (bottom > scrollTop && top < scrollTop + windowHeight) {\n                    $img.css('transform', \"translate3D(-50%,\" + parallax + \"px, 0)\");\n                }\n            }\n\n            // Wait for image load\n            $this.children(\"img\").one(\"load\", function () {\n                updateParallax(true);\n            }).each(function () {\n                if (this.complete) $(this).load();\n            });\n\n            $(window).scroll(function () {\n                window_width = $(window).width();\n                updateParallax(false);\n            });\n\n            $(window).resize(function () {\n                window_width = $(window).width();\n                updateParallax(false);\n            });\n        });\n    };\n})(jQuery);\n(function ($) {\n    var methods = {\n        init: function init() {\n            return this.each(function () {\n\n                // For each set of tabs, we want to keep track of\n                // which tab is active and its associated content\n                var $this = $(this),\n                    window_width = $(window).width();\n\n                $this.width('100%');\n                var $active,\n                    $content,\n                    $links = $this.find('li.tab a'),\n                    $tabs_width = $this.width(),\n                    $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length,\n                    $index = 0;\n\n                // If the location.hash matches one of the links, use that as the active tab.\n                $active = $($links.filter('[href=\"' + location.hash + '\"]'));\n\n                // If no match is found, use the first link or any with class 'active' as the initial active tab.\n                if ($active.length === 0) {\n                    $active = $(this).find('li.tab a.active').first();\n                }\n                if ($active.length === 0) {\n                    $active = $(this).find('li.tab a').first();\n                }\n\n                $active.addClass('active');\n                $index = $links.index($active);\n                if ($index < 0) {\n                    $index = 0;\n                }\n\n                if ($active[0] !== undefined) {\n                    $content = $($active[0].hash);\n                }\n\n                // append indicator then set indicator width to tab width\n                $this.append('<div class=\"indicator\"></div>');\n                var $indicator = $this.find('.indicator');\n                if ($this.is(\":visible\")) {\n                    $indicator.css({\n                        \"right\": $tabs_width - ($index + 1) * $tab_width\n                    });\n                    $indicator.css({\n                        \"left\": $index * $tab_width\n                    });\n                }\n                $(window).resize(function () {\n                    $tabs_width = $this.width();\n                    $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;\n                    if ($index < 0) {\n                        $index = 0;\n                    }\n                    if ($tab_width !== 0 && $tabs_width !== 0) {\n                        $indicator.css({\n                            \"right\": $tabs_width - ($index + 1) * $tab_width\n                        });\n                        $indicator.css({\n                            \"left\": $index * $tab_width\n                        });\n                    }\n                });\n\n                // Hide the remaining content\n                $links.not($active).each(function () {\n                    $(this.hash).hide();\n                });\n\n                // Bind the click event handler\n                $this.on('click', 'a', function (e) {\n                    if ($(this).parent().hasClass('disabled')) {\n                        e.preventDefault();\n                        return;\n                    }\n\n                    $tabs_width = $this.width();\n                    $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;\n\n                    // Make the old tab inactive.\n                    $active.removeClass('active');\n                    if ($content !== undefined) {\n                        $content.hide();\n                    }\n\n                    // Update the variables with the new link and content\n                    $active = $(this);\n                    $content = $(this.hash);\n                    $links = $this.find('li.tab a');\n\n                    // Make the tab active.\n                    $active.addClass('active');\n                    var $prev_index = $index;\n                    $index = $links.index($(this));\n                    if ($index < 0) {\n                        $index = 0;\n                    }\n                    // Change url to current tab\n                    // window.location.hash = $active.attr('href');\n\n                    if ($content !== undefined) {\n                        $content.show();\n                    }\n\n                    // Update indicator\n                    if ($index - $prev_index >= 0) {\n                        $indicator.velocity({\n                            \"right\": $tabs_width - ($index + 1) * $tab_width\n                        }, {\n                            duration: 300,\n                            queue: false,\n                            easing: 'easeOutQuad'\n                        });\n                        $indicator.velocity({\n                            \"left\": $index * $tab_width\n                        }, {\n                            duration: 300,\n                            queue: false,\n                            easing: 'easeOutQuad',\n                            delay: 90\n                        });\n                    } else {\n                        $indicator.velocity({\n                            \"left\": $index * $tab_width\n                        }, {\n                            duration: 300,\n                            queue: false,\n                            easing: 'easeOutQuad'\n                        });\n                        $indicator.velocity({\n                            \"right\": $tabs_width - ($index + 1) * $tab_width\n                        }, {\n                            duration: 300,\n                            queue: false,\n                            easing: 'easeOutQuad',\n                            delay: 90\n                        });\n                    }\n\n                    // Prevent the anchor's default click action\n                    e.preventDefault();\n                });\n            });\n        },\n        select_tab: function select_tab(id) {\n            this.find('a[href=\"#' + id + '\"]').trigger('click');\n        }\n    };\n\n    $.fn.tabs = function (methodOrOptions) {\n        if (methods[methodOrOptions]) {\n            return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));\n        } else if ((typeof methodOrOptions === 'undefined' ? 'undefined' : _typeof(methodOrOptions)) === 'object' || !methodOrOptions) {\n            // Default to \"init\"\n            return methods.init.apply(this, arguments);\n        } else {\n            $.error('Method ' + methodOrOptions + ' does not exist on jQuery.tooltip');\n        }\n    };\n\n    $(document).ready(function () {\n        $('ul.tabs').tabs();\n    });\n})(jQuery);;\n(function ($) {\n    $.fn.tooltip = function (options) {\n        var timeout = null,\n            margin = 5;\n\n        // Defaults\n        var defaults = {\n            delay: 350\n        };\n\n        // Remove tooltip from the activator\n        if (options === \"remove\") {\n            this.each(function () {\n                $('#' + $(this).attr('data-tooltip-id')).remove();\n                $(this).off('mouseenter.tooltip mouseleave.tooltip');\n            });\n            return false;\n        }\n\n        options = $.extend(defaults, options);\n\n        return this.each(function () {\n            var tooltipId = Materialize.guid();\n            var origin = $(this);\n            origin.attr('data-tooltip-id', tooltipId);\n\n            // Create Text span\n            var tooltip_text = $('<span></span>').text(origin.attr('data-tooltip'));\n\n            // Create tooltip\n            var newTooltip = $('<div></div>');\n            newTooltip.addClass('material-tooltip').append(tooltip_text).appendTo($('body')).attr('id', tooltipId);\n\n            var backdrop = $('<div></div>').addClass('backdrop');\n            backdrop.appendTo(newTooltip);\n            backdrop.css({\n                top: 0,\n                left: 0\n            });\n\n            //Destroy previously binded events\n            origin.off('mouseenter.tooltip mouseleave.tooltip');\n            // Mouse In\n            var started = false,\n                timeoutRef;\n            origin.on({\n                'mouseenter.tooltip': function mouseenterTooltip(e) {\n                    var tooltip_delay = origin.attr('data-delay');\n                    tooltip_delay = tooltip_delay === undefined || tooltip_delay === '' ? options.delay : tooltip_delay;\n                    timeoutRef = setTimeout(function () {\n                        started = true;\n                        newTooltip.velocity('stop');\n                        backdrop.velocity('stop');\n                        newTooltip.css({\n                            display: 'block',\n                            left: '0px',\n                            top: '0px'\n                        });\n\n                        // Set Tooltip text\n                        newTooltip.children('span').text(origin.attr('data-tooltip'));\n\n                        // Tooltip positioning\n                        var originWidth = origin.outerWidth();\n                        var originHeight = origin.outerHeight();\n                        var tooltipPosition = origin.attr('data-position');\n                        var tooltipHeight = newTooltip.outerHeight();\n                        var tooltipWidth = newTooltip.outerWidth();\n                        var tooltipVerticalMovement = '0px';\n                        var tooltipHorizontalMovement = '0px';\n                        var scale_factor = 8;\n                        var targetTop, targetLeft, newCoordinates;\n\n                        if (tooltipPosition === \"top\") {\n                            // Top Position\n                            targetTop = origin.offset().top - tooltipHeight - margin;\n                            targetLeft = origin.offset().left + originWidth / 2 - tooltipWidth / 2;\n                            newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);\n\n                            tooltipVerticalMovement = '-10px';\n                            backdrop.css({\n                                borderRadius: '14px 14px 0 0',\n                                transformOrigin: '50% 90%',\n                                marginTop: tooltipHeight,\n                                marginLeft: tooltipWidth / 2 - backdrop.width() / 2\n                            });\n                        }\n                        // Left Position\n                        else if (tooltipPosition === \"left\") {\n                                targetTop = origin.offset().top + originHeight / 2 - tooltipHeight / 2;\n                                targetLeft = origin.offset().left - tooltipWidth - margin;\n                                newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);\n\n                                tooltipHorizontalMovement = '-10px';\n                                backdrop.css({\n                                    width: '14px',\n                                    height: '14px',\n                                    borderRadius: '14px 0 0 14px',\n                                    transformOrigin: '95% 50%',\n                                    marginTop: tooltipHeight / 2,\n                                    marginLeft: tooltipWidth\n                                });\n                            }\n                            // Right Position\n                            else if (tooltipPosition === \"right\") {\n                                    targetTop = origin.offset().top + originHeight / 2 - tooltipHeight / 2;\n                                    targetLeft = origin.offset().left + originWidth + margin;\n                                    newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);\n\n                                    tooltipHorizontalMovement = '+10px';\n                                    backdrop.css({\n                                        width: '14px',\n                                        height: '14px',\n                                        borderRadius: '0 14px 14px 0',\n                                        transformOrigin: '5% 50%',\n                                        marginTop: tooltipHeight / 2,\n                                        marginLeft: '0px'\n                                    });\n                                } else {\n                                    // Bottom Position\n                                    targetTop = origin.offset().top + origin.outerHeight() + margin;\n                                    targetLeft = origin.offset().left + originWidth / 2 - tooltipWidth / 2;\n                                    newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);\n                                    tooltipVerticalMovement = '+10px';\n                                    backdrop.css({\n                                        marginLeft: tooltipWidth / 2 - backdrop.width() / 2\n                                    });\n                                }\n\n                        // Set tooptip css placement\n                        newTooltip.css({\n                            top: newCoordinates.y,\n                            left: newCoordinates.x\n                        });\n\n                        // Calculate Scale to fill\n                        scale_factor = tooltipWidth / 8;\n                        if (scale_factor < 8) {\n                            scale_factor = 8;\n                        }\n                        if (tooltipPosition === \"right\" || tooltipPosition === \"left\") {\n                            scale_factor = tooltipWidth / 10;\n                            if (scale_factor < 6) scale_factor = 6;\n                        }\n\n                        newTooltip.velocity({\n                            marginTop: tooltipVerticalMovement,\n                            marginLeft: tooltipHorizontalMovement\n                        }, {\n                            duration: 350,\n                            queue: false\n                        }).velocity({\n                            opacity: 1\n                        }, {\n                            duration: 300,\n                            delay: 50,\n                            queue: false\n                        });\n                        backdrop.css({\n                            display: 'block'\n                        }).velocity({\n                            opacity: 1\n                        }, {\n                            duration: 55,\n                            delay: 0,\n                            queue: false\n                        }).velocity({\n                            scale: scale_factor\n                        }, {\n                            duration: 300,\n                            delay: 0,\n                            queue: false,\n                            easing: 'easeInOutQuad'\n                        });\n                    }, tooltip_delay); // End Interval\n\n                    // Mouse Out\n                },\n                'mouseleave.tooltip': function mouseleaveTooltip() {\n                    // Reset State\n                    started = false;\n                    clearTimeout(timeoutRef);\n\n                    // Animate back\n                    setTimeout(function () {\n                        if (started != true) {\n                            newTooltip.velocity({\n                                opacity: 0,\n                                marginTop: 0,\n                                marginLeft: 0\n                            }, {\n                                duration: 225,\n                                queue: false\n                            });\n                            backdrop.velocity({\n                                opacity: 0,\n                                scale: 1\n                            }, {\n                                duration: 225,\n                                queue: false,\n                                complete: function complete() {\n                                    backdrop.css('display', 'none');\n                                    newTooltip.css('display', 'none');\n                                    started = false;\n                                }\n                            });\n                        }\n                    }, 225);\n                }\n            });\n        });\n    };\n\n    var repositionWithinScreen = function repositionWithinScreen(x, y, width, height) {\n        var newX = x;\n        var newY = y;\n\n        if (newX < 0) {\n            newX = 4;\n        } else if (newX + width > window.innerWidth) {\n            newX -= newX + width - window.innerWidth;\n        }\n\n        if (newY < 0) {\n            newY = 4;\n        } else if (newY + height > window.innerHeight + $(window).scrollTop) {\n            newY -= newY + height - window.innerHeight;\n        }\n\n        return {\n            x: newX,\n            y: newY\n        };\n    };\n\n    $(document).ready(function () {\n        $('.tooltipped').tooltip();\n    });\n})(jQuery);;\n/*!\r\n * Waves v0.6.4\r\n * http://fian.my.id/Waves\r\n *\r\n * Copyright 2014 Alfiana E. Sibuea and other contributors\r\n * Released under the MIT license\r\n * https://github.com/fians/Waves/blob/master/LICENSE\r\n */\n\n;\n(function (window) {\n    'use strict';\n\n    var Waves = Waves || {};\n    var $$ = document.querySelectorAll.bind(document);\n\n    // Find exact position of element\n    function isWindow(obj) {\n        return obj !== null && obj === obj.window;\n    }\n\n    function getWindow(elem) {\n        return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;\n    }\n\n    function offset(elem) {\n        var docElem,\n            win,\n            box = {\n            top: 0,\n            left: 0\n        },\n            doc = elem && elem.ownerDocument;\n\n        docElem = doc.documentElement;\n\n        if (_typeof(elem.getBoundingClientRect) !== ( true ? 'undefined' : undefined)) {\n            box = elem.getBoundingClientRect();\n        }\n        win = getWindow(doc);\n        return {\n            top: box.top + win.pageYOffset - docElem.clientTop,\n            left: box.left + win.pageXOffset - docElem.clientLeft\n        };\n    }\n\n    function convertStyle(obj) {\n        var style = '';\n\n        for (var a in obj) {\n            if (obj.hasOwnProperty(a)) {\n                style += a + ':' + obj[a] + ';';\n            }\n        }\n\n        return style;\n    }\n\n    var Effect = {\n\n        // Effect delay\n        duration: 750,\n\n        show: function show(e, element) {\n\n            // Disable right click\n            if (e.button === 2) {\n                return false;\n            }\n\n            var el = element || this;\n\n            // Create ripple\n            var ripple = document.createElement('div');\n            ripple.className = 'waves-ripple';\n            el.appendChild(ripple);\n\n            // Get click coordinate and element witdh\n            var pos = offset(el);\n            var relativeY = e.pageY - pos.top;\n            var relativeX = e.pageX - pos.left;\n            var scale = 'scale(' + el.clientWidth / 100 * 10 + ')';\n\n            // Support for touch devices\n            if ('touches' in e) {\n                relativeY = e.touches[0].pageY - pos.top;\n                relativeX = e.touches[0].pageX - pos.left;\n            }\n\n            // Attach data to element\n            ripple.setAttribute('data-hold', Date.now());\n            ripple.setAttribute('data-scale', scale);\n            ripple.setAttribute('data-x', relativeX);\n            ripple.setAttribute('data-y', relativeY);\n\n            // Set ripple position\n            var rippleStyle = {\n                'top': relativeY + 'px',\n                'left': relativeX + 'px'\n            };\n\n            ripple.className = ripple.className + ' waves-notransition';\n            ripple.setAttribute('style', convertStyle(rippleStyle));\n            ripple.className = ripple.className.replace('waves-notransition', '');\n\n            // Scale the ripple\n            rippleStyle['-webkit-transform'] = scale;\n            rippleStyle['-moz-transform'] = scale;\n            rippleStyle['-ms-transform'] = scale;\n            rippleStyle['-o-transform'] = scale;\n            rippleStyle.transform = scale;\n            rippleStyle.opacity = '1';\n\n            rippleStyle['-webkit-transition-duration'] = Effect.duration + 'ms';\n            rippleStyle['-moz-transition-duration'] = Effect.duration + 'ms';\n            rippleStyle['-o-transition-duration'] = Effect.duration + 'ms';\n            rippleStyle['transition-duration'] = Effect.duration + 'ms';\n\n            rippleStyle['-webkit-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n            rippleStyle['-moz-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n            rippleStyle['-o-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n            rippleStyle['transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n\n            ripple.setAttribute('style', convertStyle(rippleStyle));\n        },\n\n        hide: function hide(e) {\n            TouchHandler.touchup(e);\n\n            var el = this;\n            var width = el.clientWidth * 1.4;\n\n            // Get first ripple\n            var ripple = null;\n            var ripples = el.getElementsByClassName('waves-ripple');\n            if (ripples.length > 0) {\n                ripple = ripples[ripples.length - 1];\n            } else {\n                return false;\n            }\n\n            var relativeX = ripple.getAttribute('data-x');\n            var relativeY = ripple.getAttribute('data-y');\n            var scale = ripple.getAttribute('data-scale');\n\n            // Get delay beetween mousedown and mouse leave\n            var diff = Date.now() - Number(ripple.getAttribute('data-hold'));\n            var delay = 350 - diff;\n\n            if (delay < 0) {\n                delay = 0;\n            }\n\n            // Fade out ripple after delay\n            setTimeout(function () {\n                var style = {\n                    'top': relativeY + 'px',\n                    'left': relativeX + 'px',\n                    'opacity': '0',\n\n                    // Duration\n                    '-webkit-transition-duration': Effect.duration + 'ms',\n                    '-moz-transition-duration': Effect.duration + 'ms',\n                    '-o-transition-duration': Effect.duration + 'ms',\n                    'transition-duration': Effect.duration + 'ms',\n                    '-webkit-transform': scale,\n                    '-moz-transform': scale,\n                    '-ms-transform': scale,\n                    '-o-transform': scale,\n                    'transform': scale\n                };\n\n                ripple.setAttribute('style', convertStyle(style));\n\n                setTimeout(function () {\n                    try {\n                        el.removeChild(ripple);\n                    } catch (e) {\n                        return false;\n                    }\n                }, Effect.duration);\n            }, delay);\n        },\n\n        // Little hack to make <input> can perform waves effect\n        wrapInput: function wrapInput(elements) {\n            for (var a = 0; a < elements.length; a++) {\n                var el = elements[a];\n\n                if (el.tagName.toLowerCase() === 'input') {\n                    var parent = el.parentNode;\n\n                    // If input already have parent just pass through\n                    if (parent.tagName.toLowerCase() === 'i' && parent.className.indexOf('waves-effect') !== -1) {\n                        continue;\n                    }\n\n                    // Put element class and style to the specified parent\n                    var wrapper = document.createElement('i');\n                    wrapper.className = el.className + ' waves-input-wrapper';\n\n                    var elementStyle = el.getAttribute('style');\n\n                    if (!elementStyle) {\n                        elementStyle = '';\n                    }\n\n                    wrapper.setAttribute('style', elementStyle);\n\n                    el.className = 'waves-button-input';\n                    el.removeAttribute('style');\n\n                    // Put element as child\n                    parent.replaceChild(wrapper, el);\n                    wrapper.appendChild(el);\n                }\n            }\n        }\n    };\n\n    /**\r\n     * Disable mousedown event for 500ms during and after touch\r\n     */\n    var TouchHandler = {\n        /* uses an integer rather than bool so there's no issues with\r\n         * needing to clear timeouts if another touch event occurred\r\n         * within the 500ms. Cannot mouseup between touchstart and\r\n         * touchend, nor in the 500ms after touchend. */\n        touches: 0,\n        allowEvent: function allowEvent(e) {\n            var allow = true;\n\n            if (e.type === 'touchstart') {\n                TouchHandler.touches += 1; //push\n            } else if (e.type === 'touchend' || e.type === 'touchcancel') {\n                setTimeout(function () {\n                    if (TouchHandler.touches > 0) {\n                        TouchHandler.touches -= 1; //pop after 500ms\n                    }\n                }, 500);\n            } else if (e.type === 'mousedown' && TouchHandler.touches > 0) {\n                allow = false;\n            }\n\n            return allow;\n        },\n        touchup: function touchup(e) {\n            TouchHandler.allowEvent(e);\n        }\n    };\n\n    /**\r\n     * Delegated click handler for .waves-effect element.\r\n     * returns null when .waves-effect element not in \"click tree\"\r\n     */\n    function getWavesEffectElement(e) {\n        if (TouchHandler.allowEvent(e) === false) {\n            return null;\n        }\n\n        var element = null;\n        var target = e.target || e.srcElement;\n\n        while (target.parentElement !== null) {\n            if (!(target instanceof SVGElement) && target.className.indexOf('waves-effect') !== -1) {\n                element = target;\n                break;\n            } else if (target.classList.contains('waves-effect')) {\n                element = target;\n                break;\n            }\n            target = target.parentElement;\n        }\n\n        return element;\n    }\n\n    /**\r\n     * Bubble the click and show effect if .waves-effect elem was found\r\n     */\n    function showEffect(e) {\n        var element = getWavesEffectElement(e);\n\n        if (element !== null) {\n            Effect.show(e, element);\n\n            if ('ontouchstart' in window) {\n                element.addEventListener('touchend', Effect.hide, false);\n                element.addEventListener('touchcancel', Effect.hide, false);\n            }\n\n            element.addEventListener('mouseup', Effect.hide, false);\n            element.addEventListener('mouseleave', Effect.hide, false);\n        }\n    }\n\n    Waves.displayEffect = function (options) {\n        options = options || {};\n\n        if ('duration' in options) {\n            Effect.duration = options.duration;\n        }\n\n        //Wrap input inside <i> tag\n        Effect.wrapInput($$('.waves-effect'));\n\n        if ('ontouchstart' in window) {\n            document.body.addEventListener('touchstart', showEffect, false);\n        }\n\n        document.body.addEventListener('mousedown', showEffect, false);\n    };\n\n    /**\r\n     * Attach Waves to an input element (or any element which doesn't\r\n     * bubble mouseup/mousedown events).\r\n     *   Intended to be used with dynamically loaded forms/inputs, or\r\n     * where the user doesn't want a delegated click handler.\r\n     */\n    Waves.attach = function (element) {\n        //FUTURE: automatically add waves classes and allow users\n        // to specify them with an options param? Eg. light/classic/button\n        if (element.tagName.toLowerCase() === 'input') {\n            Effect.wrapInput([element]);\n            element = element.parentElement;\n        }\n\n        if ('ontouchstart' in window) {\n            element.addEventListener('touchstart', showEffect, false);\n        }\n\n        element.addEventListener('mousedown', showEffect, false);\n    };\n\n    window.Waves = Waves;\n\n    document.addEventListener('DOMContentLoaded', function () {\n        Waves.displayEffect();\n    }, false);\n})(window);;\nMaterialize.toast = function (message, displayLength, className, completeCallback) {\n    className = className || \"\";\n\n    var container = document.getElementById('toast-container');\n\n    // Create toast container if it does not exist\n    if (container === null) {\n        // create notification container\n        container = document.createElement('div');\n        container.id = 'toast-container';\n        document.body.appendChild(container);\n    }\n\n    // Select and append toast\n    var newToast = createToast(message);\n\n    // only append toast if message is not undefined\n    if (message) {\n        container.appendChild(newToast);\n    }\n\n    newToast.style.top = '35px';\n    newToast.style.opacity = 0;\n\n    // Animate toast in\n    Vel(newToast, {\n        \"top\": \"0px\",\n        opacity: 1\n    }, {\n        duration: 300,\n        easing: 'easeOutCubic',\n        queue: false\n    });\n\n    // Allows timer to be pause while being panned\n    var timeLeft = displayLength;\n    var counterInterval = setInterval(function () {\n\n        if (newToast.parentNode === null) window.clearInterval(counterInterval);\n\n        // If toast is not being dragged, decrease its time remaining\n        if (!newToast.classList.contains('panning')) {\n            timeLeft -= 20;\n        }\n\n        if (timeLeft <= 0) {\n            // Animate toast out\n            Vel(newToast, {\n                \"opacity\": 0,\n                marginTop: '-40px'\n            }, {\n                duration: 375,\n                easing: 'easeOutExpo',\n                queue: false,\n                complete: function complete() {\n                    // Call the optional callback\n                    if (typeof completeCallback === \"function\") completeCallback();\n                    // Remove toast after it times out\n                    this[0].parentNode.removeChild(this[0]);\n                }\n            });\n            window.clearInterval(counterInterval);\n        }\n    }, 20);\n\n    function createToast(html) {\n\n        // Create toast\n        var toast = document.createElement('div');\n        toast.classList.add('toast');\n        if (className) {\n            var classes = className.split(' ');\n\n            for (var i = 0, count = classes.length; i < count; i++) {\n                toast.classList.add(classes[i]);\n            }\n        }\n        // If type of parameter is HTML Element\n        if ((typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === \"object\" ? html instanceof HTMLElement : html && (typeof html === 'undefined' ? 'undefined' : _typeof(html)) === \"object\" && html !== null && html.nodeType === 1 && typeof html.nodeName === \"string\") {\n            toast.appendChild(html);\n        } else if (html instanceof jQuery) {\n            // Check if it is jQuery object\n            toast.appendChild(html[0]);\n        } else {\n            // Insert as text;\n            toast.innerHTML = html;\n        }\n        // Bind hammer\n        var hammerHandler = new Hammer(toast, {\n            prevent_default: false\n        });\n        hammerHandler.on('pan', function (e) {\n            var deltaX = e.deltaX;\n            var activationDistance = 80;\n\n            // Change toast state\n            if (!toast.classList.contains('panning')) {\n                toast.classList.add('panning');\n            }\n\n            var opacityPercent = 1 - Math.abs(deltaX / activationDistance);\n            if (opacityPercent < 0) opacityPercent = 0;\n\n            Vel(toast, {\n                left: deltaX,\n                opacity: opacityPercent\n            }, {\n                duration: 50,\n                queue: false,\n                easing: 'easeOutQuad'\n            });\n        });\n\n        hammerHandler.on('panend', function (e) {\n            var deltaX = e.deltaX;\n            var activationDistance = 80;\n\n            // If toast dragged past activation point\n            if (Math.abs(deltaX) > activationDistance) {\n                Vel(toast, {\n                    marginTop: '-40px'\n                }, {\n                    duration: 375,\n                    easing: 'easeOutExpo',\n                    queue: false,\n                    complete: function complete() {\n                        if (typeof completeCallback === \"function\") {\n                            completeCallback();\n                        }\n                        toast.parentNode.removeChild(toast);\n                    }\n                });\n            } else {\n                toast.classList.remove('panning');\n                // Put toast back into original position\n                Vel(toast, {\n                    left: 0,\n                    opacity: 1\n                }, {\n                    duration: 300,\n                    easing: 'easeOutExpo',\n                    queue: false\n                });\n            }\n        });\n\n        return toast;\n    }\n};;\n(function ($) {\n\n    var methods = {\n        init: function init(options) {\n            var defaults = {\n                menuWidth: 240,\n                edge: 'left',\n                closeOnClick: false\n            };\n            options = $.extend(defaults, options);\n\n            $(this).each(function () {\n                var $this = $(this);\n                var menu_id = $(\"#\" + $this.attr('data-activates'));\n\n                // Set to width\n                if (options.menuWidth != 240) {\n                    menu_id.css('width', options.menuWidth);\n                }\n\n                // Add Touch Area\n                var dragTarget = $('<div class=\"drag-target\"></div>');\n                $('body').append(dragTarget);\n\n                if (options.edge == 'left') {\n                    menu_id.css('transform', 'translateX(-100%)');\n                    dragTarget.css({\n                        'left': 0\n                    }); // Add Touch Area\n                } else {\n                    menu_id.addClass('right-aligned') // Change text-alignment to right\n                    .css('transform', 'translateX(100%)');\n                    dragTarget.css({\n                        'right': 0\n                    }); // Add Touch Area\n                }\n\n                // If fixed sidenav, bring menu out\n                if (menu_id.hasClass('fixed')) {\n                    if (window.innerWidth > 992) {\n                        menu_id.css('transform', 'translateX(0)');\n                    }\n                }\n\n                // Window resize to reset on large screens fixed\n                if (menu_id.hasClass('fixed')) {\n                    $(window).resize(function () {\n                        if (window.innerWidth > 992) {\n                            // Close menu if window is resized bigger than 992 and user has fixed sidenav\n                            if ($('#sidenav-overlay').length != 0 && menuOut) {\n                                removeMenu(true);\n                            } else {\n                                // menu_id.removeAttr('style');\n                                menu_id.css('transform', 'translateX(0%)');\n                                // menu_id.css('width', options.menuWidth);\n                            }\n                        } else if (menuOut === false) {\n                            if (options.edge === 'left') {\n                                menu_id.css('transform', 'translateX(-100%)');\n                            } else {\n                                menu_id.css('transform', 'translateX(100%)');\n                            }\n                        }\n                    });\n                }\n\n                // if closeOnClick, then add close event for all a tags in side sideNav\n                if (options.closeOnClick === true) {\n                    menu_id.on(\"click.itemclick\", \"a:not(.collapsible-header)\", function () {\n                        removeMenu();\n                    });\n                }\n\n                function removeMenu(restoreNav) {\n                    panning = false;\n                    menuOut = false;\n                    // Reenable scrolling\n                    $('body').css({\n                        overflow: '',\n                        width: ''\n                    });\n\n                    $('body').removeClass('stop-flow');\n\n                    $('#sidenav-overlay').velocity({\n                        opacity: 0\n                    }, {\n                        duration: 200,\n                        queue: false,\n                        easing: 'easeOutQuad',\n                        complete: function complete() {\n                            $(this).remove();\n                        }\n                    });\n                    if (options.edge === 'left') {\n                        // Reset phantom div\n                        dragTarget.css({\n                            width: '',\n                            right: '',\n                            left: '0'\n                        });\n                        menu_id.velocity({\n                            'translateX': '-100%'\n                        }, {\n                            duration: 200,\n                            queue: false,\n                            easing: 'easeOutCubic',\n                            complete: function complete() {\n                                if (restoreNav === true) {\n                                    // Restore Fixed sidenav\n                                    menu_id.removeAttr('style');\n                                    menu_id.css('width', options.menuWidth);\n                                }\n                            }\n\n                        });\n                    } else {\n                        // Reset phantom div\n                        dragTarget.css({\n                            width: '',\n                            right: '0',\n                            left: ''\n                        });\n                        menu_id.velocity({\n                            'translateX': '100%'\n                        }, {\n                            duration: 200,\n                            queue: false,\n                            easing: 'easeOutCubic',\n                            complete: function complete() {\n                                if (restoreNav === true) {\n                                    // Restore Fixed sidenav\n                                    menu_id.removeAttr('style');\n                                    menu_id.css('width', options.menuWidth);\n                                }\n                            }\n                        });\n                    }\n                }\n\n                // Touch Event\n                var panning = false;\n                var menuOut = false;\n\n                dragTarget.on('click', function () {\n                    removeMenu();\n                });\n\n                dragTarget.hammer({\n                    prevent_default: false\n                }).bind('pan', function (e) {\n\n                    if (e.gesture.pointerType == \"touch\") {\n\n                        var direction = e.gesture.direction;\n                        var x = e.gesture.center.x;\n                        var y = e.gesture.center.y;\n                        var velocityX = e.gesture.velocityX;\n\n                        // Disable Scrolling\n                        var $body = $('body');\n                        var oldWidth = $body.innerWidth();\n                        $body.css('overflow', 'hidden');\n                        $body.addClass('stop-flow');\n                        $body.width(oldWidth);\n\n                        // If overlay does not exist, create one and if it is clicked, close menu\n                        if ($('#sidenav-overlay').length === 0) {\n                            var overlay = $('<div id=\"sidenav-overlay\"></div>');\n                            overlay.css('opacity', 0).click(function () {\n                                removeMenu();\n                            });\n                            $('body').append(overlay);\n                        }\n\n                        // Keep within boundaries\n                        if (options.edge === 'left') {\n                            if (x > options.menuWidth) {\n                                x = options.menuWidth;\n                            } else if (x < 0) {\n                                x = 0;\n                            }\n                        }\n\n                        if (options.edge === 'left') {\n                            // Left Direction\n                            if (x < options.menuWidth / 2) {\n                                menuOut = false;\n                            }\n                            // Right Direction\n                            else if (x >= options.menuWidth / 2) {\n                                    menuOut = true;\n                                }\n                            menu_id.css('transform', 'translateX(' + (x - options.menuWidth) + 'px)');\n                        } else {\n                            // Left Direction\n                            if (x < window.innerWidth - options.menuWidth / 2) {\n                                menuOut = true;\n                            }\n                            // Right Direction\n                            else if (x >= window.innerWidth - options.menuWidth / 2) {\n                                    menuOut = false;\n                                }\n                            var rightPos = x - options.menuWidth / 2;\n                            if (rightPos < 0) {\n                                rightPos = 0;\n                            }\n\n                            menu_id.css('transform', 'translateX(' + rightPos + 'px)');\n                        }\n\n                        // Percentage overlay\n                        var overlayPerc;\n                        if (options.edge === 'left') {\n                            overlayPerc = x / options.menuWidth;\n                            $('#sidenav-overlay').velocity({\n                                opacity: overlayPerc\n                            }, {\n                                duration: 10,\n                                queue: false,\n                                easing: 'easeOutQuad'\n                            });\n                        } else {\n                            overlayPerc = Math.abs((x - window.innerWidth) / options.menuWidth);\n                            $('#sidenav-overlay').velocity({\n                                opacity: overlayPerc\n                            }, {\n                                duration: 10,\n                                queue: false,\n                                easing: 'easeOutQuad'\n                            });\n                        }\n                    }\n                }).bind('panend', function (e) {\n\n                    if (e.gesture.pointerType == \"touch\") {\n                        var velocityX = e.gesture.velocityX;\n                        var x = e.gesture.center.x;\n                        var leftPos = x - options.menuWidth;\n                        var rightPos = x - options.menuWidth / 2;\n                        if (leftPos > 0) {\n                            leftPos = 0;\n                        }\n                        if (rightPos < 0) {\n                            rightPos = 0;\n                        }\n                        panning = false;\n\n                        if (options.edge === 'left') {\n                            // If velocityX <= 0.3 then the user is flinging the menu closed so ignore menuOut\n                            if (menuOut && velocityX <= 0.3 || velocityX < -0.5) {\n                                if (leftPos != 0) {\n                                    menu_id.velocity({\n                                        'translateX': [0, leftPos]\n                                    }, {\n                                        duration: 300,\n                                        queue: false,\n                                        easing: 'easeOutQuad'\n                                    });\n                                }\n\n                                // menu_id.css({'translateX': 0});\n                                $('#sidenav-overlay').velocity({\n                                    opacity: 1\n                                }, {\n                                    duration: 50,\n                                    queue: false,\n                                    easing: 'easeOutQuad'\n                                });\n                                dragTarget.css({\n                                    width: '50%',\n                                    right: 0,\n                                    left: ''\n                                });\n                            } else if (!menuOut || velocityX > 0.3) {\n                                // Enable Scrolling\n                                $('body').css({\n                                    overflow: '',\n                                    width: ''\n                                });\n                                $('body').removeClass('stop-flow');\n                                // Slide menu closed\n                                menu_id.velocity({\n                                    'translateX': [-1 * options.menuWidth - 10, leftPos]\n                                }, {\n                                    duration: 200,\n                                    queue: false,\n                                    easing: 'easeOutQuad'\n                                });\n                                $('#sidenav-overlay').velocity({\n                                    opacity: 0\n                                }, {\n                                    duration: 200,\n                                    queue: false,\n                                    easing: 'easeOutQuad',\n                                    complete: function complete() {\n                                        $(this).remove();\n                                    }\n                                });\n                                dragTarget.css({\n                                    width: '10px',\n                                    right: '',\n                                    left: 0\n                                });\n                            }\n                        } else {\n                            if (menuOut && velocityX >= -0.3 || velocityX > 0.5) {\n                                menu_id.velocity({\n                                    'translateX': [0, rightPos]\n                                }, {\n                                    duration: 300,\n                                    queue: false,\n                                    easing: 'easeOutQuad'\n                                });\n                                $('#sidenav-overlay').velocity({\n                                    opacity: 1\n                                }, {\n                                    duration: 50,\n                                    queue: false,\n                                    easing: 'easeOutQuad'\n                                });\n                                dragTarget.css({\n                                    width: '50%',\n                                    right: '',\n                                    left: 0\n                                });\n                            } else if (!menuOut || velocityX < -0.3) {\n                                // Enable Scrolling\n                                $('body').css({\n                                    overflow: '',\n                                    width: ''\n                                });\n                                $('body').removeClass('stop-flow');\n                                // Slide menu closed\n                                menu_id.velocity({\n                                    'translateX': [options.menuWidth + 10, rightPos]\n                                }, {\n                                    duration: 200,\n                                    queue: false,\n                                    easing: 'easeOutQuad'\n                                });\n                                $('#sidenav-overlay').velocity({\n                                    opacity: 0\n                                }, {\n                                    duration: 200,\n                                    queue: false,\n                                    easing: 'easeOutQuad',\n                                    complete: function complete() {\n                                        $(this).remove();\n                                    }\n                                });\n                                dragTarget.css({\n                                    width: '10px',\n                                    right: 0,\n                                    left: ''\n                                });\n                            }\n                        }\n                    }\n                });\n\n                $this.click(function () {\n                    if (menuOut === true) {\n                        menuOut = false;\n                        panning = false;\n                        removeMenu();\n                    } else {\n\n                        // Disable Scrolling\n                        var $body = $('body');\n                        var oldWidth = $body.innerWidth();\n                        $body.css('overflow', 'hidden');\n                        $body.addClass('stop-flow');\n                        $body.width(oldWidth);\n\n                        // Push current drag target on top of DOM tree\n                        $('body').append(dragTarget);\n\n                        if (options.edge === 'left') {\n                            dragTarget.css({\n                                width: '50%',\n                                right: 0,\n                                left: ''\n                            });\n                            menu_id.velocity({\n                                'translateX': [0, -1 * options.menuWidth]\n                            }, {\n                                duration: 300,\n                                queue: false,\n                                easing: 'easeOutQuad'\n                            });\n                        } else {\n                            dragTarget.css({\n                                width: '50%',\n                                right: '',\n                                left: 0\n                            });\n                            menu_id.velocity({\n                                'translateX': [0, options.menuWidth]\n                            }, {\n                                duration: 300,\n                                queue: false,\n                                easing: 'easeOutQuad'\n                            });\n                        }\n\n                        var overlay = $('<div id=\"sidenav-overlay\"></div>');\n                        overlay.css('opacity', 0).click(function () {\n                            menuOut = false;\n                            panning = false;\n                            removeMenu();\n                            overlay.velocity({\n                                opacity: 0\n                            }, {\n                                duration: 300,\n                                queue: false,\n                                easing: 'easeOutQuad',\n                                complete: function complete() {\n                                    $(this).remove();\n                                }\n                            });\n                        });\n                        $('body').append(overlay);\n                        overlay.velocity({\n                            opacity: 1\n                        }, {\n                            duration: 300,\n                            queue: false,\n                            easing: 'easeOutQuad',\n                            complete: function complete() {\n                                menuOut = true;\n                                panning = false;\n                            }\n                        });\n                    }\n\n                    return false;\n                });\n            });\n        },\n        show: function show() {\n            this.trigger('click');\n        },\n        hide: function hide() {\n            $('#sidenav-overlay').trigger('click');\n        }\n    };\n\n    $.fn.sideNav = function (methodOrOptions) {\n        if (methods[methodOrOptions]) {\n            return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));\n        } else if ((typeof methodOrOptions === 'undefined' ? 'undefined' : _typeof(methodOrOptions)) === 'object' || !methodOrOptions) {\n            // Default to \"init\"\n            return methods.init.apply(this, arguments);\n        } else {\n            $.error('Method ' + methodOrOptions + ' does not exist on jQuery.sideNav');\n        }\n    };\n})(jQuery);;\n/**\r\n * Extend jquery with a scrollspy plugin.\r\n * This watches the window scroll and fires events when elements are scrolled into viewport.\r\n *\r\n * throttle() and getTime() taken from Underscore.js\r\n * https://github.com/jashkenas/underscore\r\n *\r\n * @author Copyright 2013 John Smart\r\n * @license https://raw.github.com/thesmart/jquery-scrollspy/master/LICENSE\r\n * @see https://github.com/thesmart\r\n * @version 0.1.2\r\n */\n(function ($) {\n\n    var jWindow = $(window);\n    var elements = [];\n    var elementsInView = [];\n    var isSpying = false;\n    var ticks = 0;\n    var unique_id = 1;\n    var offset = {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n\n        /**\r\n         * Find elements that are within the boundary\r\n         * @param {number} top\r\n         * @param {number} right\r\n         * @param {number} bottom\r\n         * @param {number} left\r\n         * @return {jQuery}\t\tA collection of elements\r\n         */\n    };function findElements(top, right, bottom, left) {\n        var hits = $();\n        $.each(elements, function (i, element) {\n            if (element.height() > 0) {\n                var elTop = element.offset().top,\n                    elLeft = element.offset().left,\n                    elRight = elLeft + element.width(),\n                    elBottom = elTop + element.height();\n\n                var isIntersect = !(elLeft > right || elRight < left || elTop > bottom || elBottom < top);\n\n                if (isIntersect) {\n                    hits.push(element);\n                }\n            }\n        });\n\n        return hits;\n    }\n\n    /**\r\n     * Called when the user scrolls the window\r\n     */\n    function onScroll() {\n        // unique tick id\n        ++ticks;\n\n        // viewport rectangle\n        var top = jWindow.scrollTop(),\n            left = jWindow.scrollLeft(),\n            right = left + jWindow.width(),\n            bottom = top + jWindow.height();\n\n        // determine which elements are in view\n        //        + 60 accounts for fixed nav\n        var intersections = findElements(top + offset.top + 200, right + offset.right, bottom + offset.bottom, left + offset.left);\n        $.each(intersections, function (i, element) {\n\n            var lastTick = element.data('scrollSpy:ticks');\n            if (typeof lastTick != 'number') {\n                // entered into view\n                element.triggerHandler('scrollSpy:enter');\n            }\n\n            // update tick id\n            element.data('scrollSpy:ticks', ticks);\n        });\n\n        // determine which elements are no longer in view\n        $.each(elementsInView, function (i, element) {\n            var lastTick = element.data('scrollSpy:ticks');\n            if (typeof lastTick == 'number' && lastTick !== ticks) {\n                // exited from view\n                element.triggerHandler('scrollSpy:exit');\n                element.data('scrollSpy:ticks', null);\n            }\n        });\n\n        // remember elements in view for next tick\n        elementsInView = intersections;\n    }\n\n    /**\r\n     * Called when window is resized\r\n     */\n    function onWinSize() {\n        jWindow.trigger('scrollSpy:winSize');\n    }\n\n    /**\r\n     * Get time in ms\r\n     * @license https://raw.github.com/jashkenas/underscore/master/LICENSE\r\n     * @type {function}\r\n     * @return {number}\r\n     */\n    var getTime = Date.now || function () {\n        return new Date().getTime();\n    };\n\n    /**\r\n     * Returns a function, that, when invoked, will only be triggered at most once\r\n     * during a given window of time. Normally, the throttled function will run\r\n     * as much as it can, without ever going more than once per `wait` duration;\r\n     * but if you'd like to disable the execution on the leading edge, pass\r\n     * `{leading: false}`. To disable execution on the trailing edge, ditto.\r\n     * @license https://raw.github.com/jashkenas/underscore/master/LICENSE\r\n     * @param {function} func\r\n     * @param {number} wait\r\n     * @param {Object=} options\r\n     * @returns {Function}\r\n     */\n    function throttle(func, wait, options) {\n        var context, args, result;\n        var timeout = null;\n        var previous = 0;\n        options || (options = {});\n        var later = function later() {\n            previous = options.leading === false ? 0 : getTime();\n            timeout = null;\n            result = func.apply(context, args);\n            context = args = null;\n        };\n        return function () {\n            var now = getTime();\n            if (!previous && options.leading === false) previous = now;\n            var remaining = wait - (now - previous);\n            context = this;\n            args = arguments;\n            if (remaining <= 0) {\n                clearTimeout(timeout);\n                timeout = null;\n                previous = now;\n                result = func.apply(context, args);\n                context = args = null;\n            } else if (!timeout && options.trailing !== false) {\n                timeout = setTimeout(later, remaining);\n            }\n            return result;\n        };\n    };\n\n    /**\r\n     * Enables ScrollSpy using a selector\r\n     * @param {jQuery|string} selector  The elements collection, or a selector\r\n     * @param {Object=} options\tOptional.\r\n     throttle : number -> scrollspy throttling. Default: 100 ms\r\n     offsetTop : number -> offset from top. Default: 0\r\n     offsetRight : number -> offset from right. Default: 0\r\n     offsetBottom : number -> offset from bottom. Default: 0\r\n     offsetLeft : number -> offset from left. Default: 0\r\n     * @returns {jQuery}\r\n     */\n    $.scrollSpy = function (selector, options) {\n        var visible = [];\n        selector = $(selector);\n        selector.each(function (i, element) {\n            elements.push($(element));\n            $(element).data(\"scrollSpy:id\", i);\n            // Smooth scroll to section\n            $('a[href=\"#' + $(element).attr('id') + '\"]').click(function (e) {\n                e.preventDefault();\n                var offset = $(this.hash).offset().top + 1;\n\n                //          offset - 200 allows elements near bottom of page to scroll\n\n                $('html, body').animate({\n                    scrollTop: offset - 200\n                }, {\n                    duration: 400,\n                    queue: false,\n                    easing: 'easeOutCubic'\n                });\n            });\n        });\n        options = options || {\n            throttle: 100\n        };\n\n        offset.top = options.offsetTop || 0;\n        offset.right = options.offsetRight || 0;\n        offset.bottom = options.offsetBottom || 0;\n        offset.left = options.offsetLeft || 0;\n\n        var throttledScroll = throttle(onScroll, options.throttle || 100);\n        var readyScroll = function readyScroll() {\n            $(document).ready(throttledScroll);\n        };\n\n        if (!isSpying) {\n            jWindow.on('scroll', readyScroll);\n            jWindow.on('resize', readyScroll);\n            isSpying = true;\n        }\n\n        // perform a scan once, after current execution context, and after dom is ready\n        setTimeout(readyScroll, 0);\n\n        selector.on('scrollSpy:enter', function () {\n            visible = $.grep(visible, function (value) {\n                return value.height() != 0;\n            });\n\n            var $this = $(this);\n\n            if (visible[0]) {\n                $('a[href=\"#' + visible[0].attr('id') + '\"]').removeClass('active');\n                if ($this.data('scrollSpy:id') < visible[0].data('scrollSpy:id')) {\n                    visible.unshift($(this));\n                } else {\n                    visible.push($(this));\n                }\n            } else {\n                visible.push($(this));\n            }\n\n            $('a[href=\"#' + visible[0].attr('id') + '\"]').addClass('active');\n        });\n        selector.on('scrollSpy:exit', function () {\n            visible = $.grep(visible, function (value) {\n                return value.height() != 0;\n            });\n\n            if (visible[0]) {\n                $('a[href=\"#' + visible[0].attr('id') + '\"]').removeClass('active');\n                var $this = $(this);\n                visible = $.grep(visible, function (value) {\n                    return value.attr('id') != $this.attr('id');\n                });\n                if (visible[0]) {\n                    // Check if empty\n                    $('a[href=\"#' + visible[0].attr('id') + '\"]').addClass('active');\n                }\n            }\n        });\n\n        return selector;\n    };\n\n    /**\r\n     * Listen for window resize events\r\n     * @param {Object=} options\t\t\t\t\t\tOptional. Set { throttle: number } to change throttling. Default: 100 ms\r\n     * @returns {jQuery}\t\t$(window)\r\n     */\n    $.winSizeSpy = function (options) {\n        $.winSizeSpy = function () {\n            return jWindow;\n        }; // lock from multiple calls\n        options = options || {\n            throttle: 100\n        };\n        return jWindow.on('resize', throttle(onWinSize, options.throttle || 100));\n    };\n\n    /**\r\n     * Enables ScrollSpy on a collection of elements\r\n     * e.g. $('.scrollSpy').scrollSpy()\r\n     * @param {Object=} options\tOptional.\r\n     throttle : number -> scrollspy throttling. Default: 100 ms\r\n     offsetTop : number -> offset from top. Default: 0\r\n     offsetRight : number -> offset from right. Default: 0\r\n     offsetBottom : number -> offset from bottom. Default: 0\r\n     offsetLeft : number -> offset from left. Default: 0\r\n     * @returns {jQuery}\r\n     */\n    $.fn.scrollSpy = function (options) {\n        return $.scrollSpy($(this), options);\n    };\n})(jQuery);;\n(function ($) {\n    $(document).ready(function () {\n\n        // Function to update labels of text fields\n        Materialize.updateTextFields = function () {\n            var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea';\n            $(input_selector).each(function (index, element) {\n                if ($(element).val().length > 0 || element.autofocus || $(this).attr('placeholder') !== undefined || $(element)[0].validity.badInput === true) {\n                    $(this).siblings('label, i').addClass('active');\n                } else {\n                    $(this).siblings('label, i').removeClass('active');\n                }\n            });\n        };\n\n        // Text based inputs\n        var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea';\n\n        // Add active if form auto complete\n        $(document).on('change', input_selector, function () {\n            if ($(this).val().length !== 0 || $(this).attr('placeholder') !== undefined) {\n                $(this).siblings('label').addClass('active');\n            }\n            validate_field($(this));\n        });\n\n        // Add active if input element has been pre-populated on document ready\n        $(document).ready(function () {\n            Materialize.updateTextFields();\n        });\n\n        // HTML DOM FORM RESET handling\n        $(document).on('reset', function (e) {\n            var formReset = $(e.target);\n            if (formReset.is('form')) {\n                formReset.find(input_selector).removeClass('valid').removeClass('invalid');\n                formReset.find(input_selector).each(function () {\n                    if ($(this).attr('value') === '') {\n                        $(this).siblings('label, i').removeClass('active');\n                    }\n                });\n\n                // Reset select\n                formReset.find('select.initialized').each(function () {\n                    var reset_text = formReset.find('option[selected]').text();\n                    formReset.siblings('input.select-dropdown').val(reset_text);\n                });\n            }\n        });\n\n        // Add active when element has focus\n        $(document).on('focus', input_selector, function () {\n            $(this).siblings('label, i').addClass('active');\n        });\n\n        $(document).on('blur', input_selector, function () {\n            var $inputElement = $(this);\n            if ($inputElement.val().length === 0 && $inputElement[0].validity.badInput !== true && $inputElement.attr('placeholder') === undefined) {\n                $inputElement.siblings('label, i').removeClass('active');\n            }\n\n            if ($inputElement.val().length === 0 && $inputElement[0].validity.badInput !== true && $inputElement.attr('placeholder') !== undefined) {\n                $inputElement.siblings('i').removeClass('active');\n            }\n            validate_field($inputElement);\n        });\n\n        window.validate_field = function (object) {\n            var hasLength = object.attr('length') !== undefined;\n            var lenAttr = parseInt(object.attr('length'));\n            var len = object.val().length;\n\n            if (object.val().length === 0 && object[0].validity.badInput === false) {\n                if (object.hasClass('validate')) {\n                    object.removeClass('valid');\n                    object.removeClass('invalid');\n                }\n            } else {\n                if (object.hasClass('validate')) {\n                    // Check for character counter attributes\n                    if (object.is(':valid') && hasLength && len <= lenAttr || object.is(':valid') && !hasLength) {\n                        object.removeClass('invalid');\n                        object.addClass('valid');\n                    } else {\n                        object.removeClass('valid');\n                        object.addClass('invalid');\n                    }\n                }\n            }\n        };\n\n        // Radio and Checkbox focus class\n        var radio_checkbox = 'input[type=radio], input[type=checkbox]';\n        $(document).on('keyup.radio', radio_checkbox, function (e) {\n            // TAB, check if tabbing to radio or checkbox.\n            if (e.which === 9) {\n                $(this).addClass('tabbed');\n                var $this = $(this);\n                $this.one('blur', function (e) {\n\n                    $(this).removeClass('tabbed');\n                });\n                return;\n            }\n        });\n\n        // Textarea Auto Resize\n        var hiddenDiv = $('.hiddendiv').first();\n        if (!hiddenDiv.length) {\n            hiddenDiv = $('<div class=\"hiddendiv common\"></div>');\n            $('body').append(hiddenDiv);\n        }\n        var text_area_selector = '.materialize-textarea';\n\n        function textareaAutoResize($textarea) {\n            // Set font properties of hiddenDiv\n\n            var fontFamily = $textarea.css('font-family');\n            var fontSize = $textarea.css('font-size');\n\n            if (fontSize) {\n                hiddenDiv.css('font-size', fontSize);\n            }\n            if (fontFamily) {\n                hiddenDiv.css('font-family', fontFamily);\n            }\n\n            if ($textarea.attr('wrap') === \"off\") {\n                hiddenDiv.css('overflow-wrap', \"normal\").css('white-space', \"pre\");\n            }\n\n            hiddenDiv.text($textarea.val() + '\\n');\n            var content = hiddenDiv.html().replace(/\\n/g, '<br>');\n            hiddenDiv.html(content);\n\n            // When textarea is hidden, width goes crazy.\n            // Approximate with half of window size\n\n            if ($textarea.is(':visible')) {\n                hiddenDiv.css('width', $textarea.width());\n            } else {\n                hiddenDiv.css('width', $(window).width() / 2);\n            }\n\n            $textarea.css('height', hiddenDiv.height());\n        }\n\n        $(text_area_selector).each(function () {\n            var $textarea = $(this);\n            if ($textarea.val().length) {\n                textareaAutoResize($textarea);\n            }\n        });\n\n        $('body').on('keyup keydown autoresize', text_area_selector, function () {\n            textareaAutoResize($(this));\n        });\n\n        // File Input Path\n        $(document).on('change', '.file-field input[type=\"file\"]', function () {\n            var file_field = $(this).closest('.file-field');\n            var path_input = file_field.find('input.file-path');\n            var files = $(this)[0].files;\n            var file_names = [];\n            for (var i = 0; i < files.length; i++) {\n                file_names.push(files[i].name);\n            }\n            path_input.val(file_names.join(\", \"));\n            path_input.trigger('change');\n        });\n\n        /****************\r\n         *  Range Input  *\r\n         ****************/\n\n        var range_type = 'input[type=range]';\n        var range_mousedown = false;\n        var left;\n\n        $(range_type).each(function () {\n            var thumb = $('<span class=\"thumb\"><span class=\"value\"></span></span>');\n            $(this).after(thumb);\n        });\n\n        var range_wrapper = '.range-field';\n        $(document).on('change', range_type, function (e) {\n            var thumb = $(this).siblings('.thumb');\n            thumb.find('.value').html($(this).val());\n        });\n\n        $(document).on('input mousedown touchstart', range_type, function (e) {\n            var thumb = $(this).siblings('.thumb');\n            var width = $(this).outerWidth();\n\n            // If thumb indicator does not exist yet, create it\n            if (thumb.length <= 0) {\n                thumb = $('<span class=\"thumb\"><span class=\"value\"></span></span>');\n                $(this).after(thumb);\n            }\n\n            // Set indicator value\n            thumb.find('.value').html($(this).val());\n\n            range_mousedown = true;\n            $(this).addClass('active');\n\n            if (!thumb.hasClass('active')) {\n                thumb.velocity({\n                    height: \"30px\",\n                    width: \"30px\",\n                    top: \"-20px\",\n                    marginLeft: \"-15px\"\n                }, {\n                    duration: 300,\n                    easing: 'easeOutExpo'\n                });\n            }\n\n            if (e.type !== 'input') {\n                if (e.pageX === undefined || e.pageX === null) {\n                    //mobile\n                    left = e.originalEvent.touches[0].pageX - $(this).offset().left;\n                } else {\n                    // desktop\n                    left = e.pageX - $(this).offset().left;\n                }\n                if (left < 0) {\n                    left = 0;\n                } else if (left > width) {\n                    left = width;\n                }\n                thumb.addClass('active').css('left', left);\n            }\n\n            thumb.find('.value').html($(this).val());\n        });\n\n        $(document).on('mouseup touchend', range_wrapper, function () {\n            range_mousedown = false;\n            $(this).removeClass('active');\n        });\n\n        $(document).on('mousemove touchmove', range_wrapper, function (e) {\n            var thumb = $(this).children('.thumb');\n            var left;\n            if (range_mousedown) {\n                if (!thumb.hasClass('active')) {\n                    thumb.velocity({\n                        height: '30px',\n                        width: '30px',\n                        top: '-20px',\n                        marginLeft: '-15px'\n                    }, {\n                        duration: 300,\n                        easing: 'easeOutExpo'\n                    });\n                }\n                if (e.pageX === undefined || e.pageX === null) {\n                    //mobile\n                    left = e.originalEvent.touches[0].pageX - $(this).offset().left;\n                } else {\n                    // desktop\n                    left = e.pageX - $(this).offset().left;\n                }\n                var width = $(this).outerWidth();\n\n                if (left < 0) {\n                    left = 0;\n                } else if (left > width) {\n                    left = width;\n                }\n                thumb.addClass('active').css('left', left);\n                thumb.find('.value').html(thumb.siblings(range_type).val());\n            }\n        });\n\n        $(document).on('mouseout touchleave', range_wrapper, function () {\n            if (!range_mousedown) {\n\n                var thumb = $(this).children('.thumb');\n\n                if (thumb.hasClass('active')) {\n                    thumb.velocity({\n                        height: '0',\n                        width: '0',\n                        top: '10px',\n                        marginLeft: '-6px'\n                    }, {\n                        duration: 100\n                    });\n                }\n                thumb.removeClass('active');\n            }\n        });\n    }); // End of $(document).ready\n\n    /*******************\r\n     *  Select Plugin  *\r\n     ******************/\n    $.fn.material_select = function (callback) {\n        $(this).each(function () {\n            var $select = $(this);\n\n            if ($select.hasClass('browser-default')) {\n                return; // Continue to next (return false breaks out of entire loop)\n            }\n\n            var multiple = $select.attr('multiple') ? true : false,\n                lastID = $select.data('select-id'); // Tear down structure if Select needs to be rebuilt\n\n            if (lastID) {\n                $select.parent().find('span.caret').remove();\n                $select.parent().find('input').remove();\n\n                $select.unwrap();\n                $('ul#select-options-' + lastID).remove();\n            }\n\n            // If destroying the select, remove the selelct-id and reset it to it's uninitialized state.\n            if (callback === 'destroy') {\n                $select.data('select-id', null).removeClass('initialized');\n                return;\n            }\n\n            var uniqueID = Materialize.guid();\n            $select.data('select-id', uniqueID);\n            var wrapper = $('<div class=\"select-wrapper\"></div>');\n            wrapper.addClass($select.attr('class'));\n            var options = $('<ul id=\"select-options-' + uniqueID + '\" class=\"dropdown-content select-dropdown ' + (multiple ? 'multiple-select-dropdown' : '') + '\"></ul>'),\n                selectChildren = $select.children('option, optgroup'),\n                valuesSelected = [],\n                optionsHover = false;\n\n            var label = $select.find('option:selected').html() || $select.find('option:first').html() || \"\";\n\n            // Function that renders and appends the option taking into\n            // account type and possible image icon.\n            var appendOptionWithIcon = function appendOptionWithIcon(select, option, type) {\n                // Add disabled attr if disabled\n                var disabledClass = option.is(':disabled') ? 'disabled ' : '';\n                var optgroupClass = type === 'optgroup-option' ? 'optgroup-option ' : '';\n\n                // add icons\n                var icon_url = option.data('icon');\n                var classes = option.attr('class');\n                if (!!icon_url) {\n                    var classString = '';\n                    if (!!classes) classString = ' class=\"' + classes + '\"';\n\n                    // Check for multiple type.\n                    if (type === 'multiple') {\n                        options.append($('<li class=\"' + disabledClass + '\"><img src=\"' + icon_url + '\"' + classString + '><span><input type=\"checkbox\"' + disabledClass + '/><label></label>' + option.html() + '</span></li>'));\n                    } else {\n                        options.append($('<li class=\"' + disabledClass + optgroupClass + '\"><img src=\"' + icon_url + '\"' + classString + '><span>' + option.html() + '</span></li>'));\n                    }\n                    return true;\n                }\n\n                // Check for multiple type.\n                if (type === 'multiple') {\n                    options.append($('<li class=\"' + disabledClass + '\"><span><input type=\"checkbox\"' + disabledClass + '/><label></label>' + option.html() + '</span></li>'));\n                } else {\n                    options.append($('<li class=\"' + disabledClass + optgroupClass + '\"><span>' + option.html() + '</span></li>'));\n                }\n            };\n\n            /* Create dropdown structure. */\n            if (selectChildren.length) {\n                selectChildren.each(function () {\n                    if ($(this).is('option')) {\n                        // Direct descendant option.\n                        if (multiple) {\n                            appendOptionWithIcon($select, $(this), 'multiple');\n                        } else {\n                            appendOptionWithIcon($select, $(this));\n                        }\n                    } else if ($(this).is('optgroup')) {\n                        // Optgroup.\n                        var selectOptions = $(this).children('option');\n                        options.append($('<li class=\"optgroup\"><span>' + $(this).attr('label') + '</span></li>'));\n\n                        selectOptions.each(function () {\n                            appendOptionWithIcon($select, $(this), 'optgroup-option');\n                        });\n                    }\n                });\n            }\n\n            options.find('li:not(.optgroup)').each(function (i) {\n                $(this).click(function (e) {\n                    // Check if option element is disabled\n                    if (!$(this).hasClass('disabled') && !$(this).hasClass('optgroup')) {\n                        var selected = true;\n\n                        if (multiple) {\n                            $('input[type=\"checkbox\"]', this).prop('checked', function (i, v) {\n                                return !v;\n                            });\n                            selected = toggleEntryFromArray(valuesSelected, $(this).index(), $select);\n                            $newSelect.trigger('focus');\n                        } else {\n                            options.find('li').removeClass('active');\n                            $(this).toggleClass('active');\n                            $newSelect.val($(this).text());\n                        }\n\n                        activateOption(options, $(this));\n                        $select.find('option').eq(i).prop('selected', selected);\n                        // Trigger onchange() event\n                        $select.trigger('change');\n                        if (typeof callback !== 'undefined') callback();\n                    }\n\n                    e.stopPropagation();\n                });\n            });\n\n            // Wrap Elements\n            $select.wrap(wrapper);\n            // Add Select Display Element\n            var dropdownIcon = $('<span class=\"caret\">&#9660;</span>');\n            if ($select.is(':disabled')) dropdownIcon.addClass('disabled');\n\n            // escape double quotes\n            var sanitizedLabelHtml = label.replace(/\"/g, '&quot;');\n\n            var $newSelect = $('<input type=\"text\" class=\"select-dropdown\" readonly=\"true\" ' + ($select.is(':disabled') ? 'disabled' : '') + ' data-activates=\"select-options-' + uniqueID + '\" value=\"' + sanitizedLabelHtml + '\"/>');\n            $select.before($newSelect);\n            $newSelect.before(dropdownIcon);\n\n            $newSelect.after(options);\n            // Check if section element is disabled\n            if (!$select.is(':disabled')) {\n                $newSelect.dropdown({\n                    'hover': false,\n                    'closeOnClick': false\n                });\n            }\n\n            // Copy tabindex\n            if ($select.attr('tabindex')) {\n                $($newSelect[0]).attr('tabindex', $select.attr('tabindex'));\n            }\n\n            $select.addClass('initialized');\n\n            $newSelect.on({\n                'focus': function focus() {\n                    if ($('ul.select-dropdown').not(options[0]).is(':visible')) {\n                        $('input.select-dropdown').trigger('close');\n                    }\n                    if (!options.is(':visible')) {\n                        $(this).trigger('open', ['focus']);\n                        var label = $(this).val();\n                        var selectedOption = options.find('li').filter(function () {\n                            return $(this).text().toLowerCase() === label.toLowerCase();\n                        })[0];\n                        activateOption(options, selectedOption);\n                    }\n                },\n                'click': function click(e) {\n                    e.stopPropagation();\n                }\n            });\n\n            $newSelect.on('blur', function () {\n                if (!multiple) {\n                    $(this).trigger('close');\n                }\n                options.find('li.selected').removeClass('selected');\n            });\n\n            options.hover(function () {\n                optionsHover = true;\n            }, function () {\n                optionsHover = false;\n            });\n\n            $(window).on({\n                'click': function click() {\n                    multiple && (optionsHover || $newSelect.trigger('close'));\n                }\n            });\n\n            // Add initial multiple selections.\n            if (multiple) {\n                $select.find(\"option:selected:not(:disabled)\").each(function () {\n                    var index = $(this).index();\n\n                    toggleEntryFromArray(valuesSelected, index, $select);\n                    options.find(\"li\").eq(index).find(\":checkbox\").prop(\"checked\", true);\n                });\n            }\n\n            // Make option as selected and scroll to selected position\n            var activateOption = function activateOption(collection, newOption) {\n                if (newOption) {\n                    collection.find('li.selected').removeClass('selected');\n                    var option = $(newOption);\n                    option.addClass('selected');\n                    options.scrollTo(option);\n                }\n            };\n\n            // Allow user to search by typing\n            // this array is cleared after 1 second\n            var filterQuery = [],\n                onKeyDown = function onKeyDown(e) {\n                // TAB - switch to another input\n                if (e.which == 9) {\n                    $newSelect.trigger('close');\n                    return;\n                }\n\n                // ARROW DOWN WHEN SELECT IS CLOSED - open select options\n                if (e.which == 40 && !options.is(':visible')) {\n                    $newSelect.trigger('open');\n                    return;\n                }\n\n                // ENTER WHEN SELECT IS CLOSED - submit form\n                if (e.which == 13 && !options.is(':visible')) {\n                    return;\n                }\n\n                e.preventDefault();\n\n                // CASE WHEN USER TYPE LETTERS\n                var letter = String.fromCharCode(e.which).toLowerCase(),\n                    nonLetters = [9, 13, 27, 38, 40];\n                if (letter && nonLetters.indexOf(e.which) === -1) {\n                    filterQuery.push(letter);\n\n                    var string = filterQuery.join(''),\n                        newOption = options.find('li').filter(function () {\n                        return $(this).text().toLowerCase().indexOf(string) === 0;\n                    })[0];\n\n                    if (newOption) {\n                        activateOption(options, newOption);\n                    }\n                }\n\n                // ENTER - select option and close when select options are opened\n                if (e.which == 13) {\n                    var activeOption = options.find('li.selected:not(.disabled)')[0];\n                    if (activeOption) {\n                        $(activeOption).trigger('click');\n                        if (!multiple) {\n                            $newSelect.trigger('close');\n                        }\n                    }\n                }\n\n                // ARROW DOWN - move to next not disabled option\n                if (e.which == 40) {\n                    if (options.find('li.selected').length) {\n                        newOption = options.find('li.selected').next('li:not(.disabled)')[0];\n                    } else {\n                        newOption = options.find('li:not(.disabled)')[0];\n                    }\n                    activateOption(options, newOption);\n                }\n\n                // ESC - close options\n                if (e.which == 27) {\n                    $newSelect.trigger('close');\n                }\n\n                // ARROW UP - move to previous not disabled option\n                if (e.which == 38) {\n                    newOption = options.find('li.selected').prev('li:not(.disabled)')[0];\n                    if (newOption) activateOption(options, newOption);\n                }\n\n                // Automaticaly clean filter query so user can search again by starting letters\n                setTimeout(function () {\n                    filterQuery = [];\n                }, 1000);\n            };\n\n            $newSelect.on('keydown', onKeyDown);\n        });\n\n        function toggleEntryFromArray(entriesArray, entryIndex, select) {\n            var index = entriesArray.indexOf(entryIndex),\n                notAdded = index === -1;\n\n            if (notAdded) {\n                entriesArray.push(entryIndex);\n            } else {\n                entriesArray.splice(index, 1);\n            }\n\n            select.siblings('ul.dropdown-content').find('li').eq(entryIndex).toggleClass('active');\n\n            // use notAdded instead of true (to detect if the option is selected or not)\n            select.find('option').eq(entryIndex).prop('selected', notAdded);\n            setValueToInput(entriesArray, select);\n\n            return notAdded;\n        }\n\n        function setValueToInput(entriesArray, select) {\n            var value = '';\n\n            for (var i = 0, count = entriesArray.length; i < count; i++) {\n                var text = select.find('option').eq(entriesArray[i]).text();\n\n                i === 0 ? value += text : value += ', ' + text;\n            }\n\n            if (value === '') {\n                value = select.find('option:disabled').eq(0).text();\n            }\n\n            select.siblings('input.select-dropdown').val(value);\n        }\n    };\n})(jQuery);;\n(function ($) {\n\n    var methods = {\n\n        init: function init(options) {\n            var defaults = {\n                indicators: true,\n                height: 400,\n                transition: 500,\n                interval: 6000\n            };\n\n            options = $.extend(defaults, options);\n\n            return this.each(function () {\n\n                // For each slider, we want to keep track of\n                // which slide is active and its associated content\n                var $this = $(this);\n                var $slider = $this.find('ul.slides').first();\n                var $slides = $slider.find('li');\n                var $active_index = $slider.find('.active').index();\n                var $active, $indicators, $interval;\n                if ($active_index != -1) {\n                    $active = $slides.eq($active_index);\n                }\n\n                // Transitions the caption depending on alignment\n                function captionTransition(caption, duration) {\n                    if (caption.hasClass(\"center-align\")) {\n                        caption.velocity({\n                            opacity: 0,\n                            translateY: -100\n                        }, {\n                            duration: duration,\n                            queue: false\n                        });\n                    } else if (caption.hasClass(\"right-align\")) {\n                        caption.velocity({\n                            opacity: 0,\n                            translateX: 100\n                        }, {\n                            duration: duration,\n                            queue: false\n                        });\n                    } else if (caption.hasClass(\"left-align\")) {\n                        caption.velocity({\n                            opacity: 0,\n                            translateX: -100\n                        }, {\n                            duration: duration,\n                            queue: false\n                        });\n                    }\n                }\n\n                // This function will transition the slide to any index of the next slide\n                function moveToSlide(index) {\n                    // Wrap around indices.\n                    if (index >= $slides.length) index = 0;else if (index < 0) index = $slides.length - 1;\n\n                    $active_index = $slider.find('.active').index();\n\n                    // Only do if index changes\n                    if ($active_index != index) {\n                        $active = $slides.eq($active_index);\n                        var $caption = $active.find('.caption');\n                        $active.removeClass('active');\n                        $active.velocity({\n                            opacity: 0\n                        }, {\n                            duration: options.transition,\n                            queue: false,\n                            easing: 'easeOutQuad',\n                            complete: function complete() {\n                                $slides.not('.active').velocity({\n                                    opacity: 0,\n                                    translateX: 0,\n                                    translateY: 0\n                                }, {\n                                    duration: 0,\n                                    queue: false\n                                });\n                            }\n                        });\n                        captionTransition($caption, options.transition);\n\n                        // Update indicators\n                        if (options.indicators) {\n                            $indicators.eq($active_index).removeClass('active');\n                        }\n\n                        $slides.eq(index).velocity({\n                            opacity: 1\n                        }, {\n                            duration: options.transition,\n                            queue: false,\n                            easing: 'easeOutQuad'\n                        });\n                        $slides.eq(index).find('.caption').velocity({\n                            opacity: 1,\n                            translateX: 0,\n                            translateY: 0\n                        }, {\n                            duration: options.transition,\n                            delay: options.transition,\n                            queue: false,\n                            easing: 'easeOutQuad'\n                        });\n                        $slides.eq(index).addClass('active');\n\n                        // Update indicators\n                        if (options.indicators) {\n                            $indicators.eq(index).addClass('active');\n                        }\n                    }\n                }\n\n                // Set height of slider\n                // If fullscreen, do nothing\n                if (!$this.hasClass('fullscreen')) {\n                    if (options.indicators) {\n                        // Add height if indicators are present\n                        $this.height(options.height + 40);\n                    } else {\n                        $this.height(options.height);\n                    }\n                    $slider.height(options.height);\n                }\n\n                // Set initial positions of captions\n                $slides.find('.caption').each(function () {\n                    captionTransition($(this), 0);\n                });\n\n                // Move img src into background-image\n                $slides.find('img').each(function () {\n                    var placeholderBase64 = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n                    if ($(this).attr('src') !== placeholderBase64) {\n                        $(this).css('background-image', 'url(' + $(this).attr('src') + ')');\n                        $(this).attr('src', placeholderBase64);\n                    }\n                });\n\n                // dynamically add indicators\n                if (options.indicators) {\n                    $indicators = $('<ul class=\"indicators\"></ul>');\n                    $slides.each(function (index) {\n                        var $indicator = $('<li class=\"indicator-item\"></li>');\n\n                        // Handle clicks on indicators\n                        $indicator.click(function () {\n                            var $parent = $slider.parent();\n                            var curr_index = $parent.find($(this)).index();\n                            moveToSlide(curr_index);\n\n                            // reset interval\n                            clearInterval($interval);\n                            $interval = setInterval(function () {\n                                $active_index = $slider.find('.active').index();\n                                if ($slides.length == $active_index + 1) $active_index = 0; // loop to start\n                                else $active_index += 1;\n\n                                moveToSlide($active_index);\n                            }, options.transition + options.interval);\n                        });\n                        $indicators.append($indicator);\n                    });\n                    $this.append($indicators);\n                    $indicators = $this.find('ul.indicators').find('li.indicator-item');\n                }\n\n                if ($active) {\n                    $active.show();\n                } else {\n                    $slides.first().addClass('active').velocity({\n                        opacity: 1\n                    }, {\n                        duration: options.transition,\n                        queue: false,\n                        easing: 'easeOutQuad'\n                    });\n\n                    $active_index = 0;\n                    $active = $slides.eq($active_index);\n\n                    // Update indicators\n                    if (options.indicators) {\n                        $indicators.eq($active_index).addClass('active');\n                    }\n                }\n\n                // Adjust height to current slide\n                $active.find('img').each(function () {\n                    $active.find('.caption').velocity({\n                        opacity: 1,\n                        translateX: 0,\n                        translateY: 0\n                    }, {\n                        duration: options.transition,\n                        queue: false,\n                        easing: 'easeOutQuad'\n                    });\n                });\n\n                // auto scroll\n                $interval = setInterval(function () {\n                    $active_index = $slider.find('.active').index();\n                    moveToSlide($active_index + 1);\n                }, options.transition + options.interval);\n\n                // HammerJS, Swipe navigation\n\n                // Touch Event\n                var panning = false;\n                var swipeLeft = false;\n                var swipeRight = false;\n\n                $this.hammer({\n                    prevent_default: false\n                }).bind('pan', function (e) {\n                    if (e.gesture.pointerType === \"touch\") {\n\n                        // reset interval\n                        clearInterval($interval);\n\n                        var direction = e.gesture.direction;\n                        var x = e.gesture.deltaX;\n                        var velocityX = e.gesture.velocityX;\n\n                        var curr_slide = $slider.find('.active');\n                        curr_slide.velocity({\n                            translateX: x\n                        }, {\n                            duration: 50,\n                            queue: false,\n                            easing: 'easeOutQuad'\n                        });\n\n                        // Swipe Left\n                        if (direction === 4 && (x > $this.innerWidth() / 2 || velocityX < -0.65)) {\n                            swipeRight = true;\n                        }\n                        // Swipe Right\n                        else if (direction === 2 && (x < -1 * $this.innerWidth() / 2 || velocityX > 0.65)) {\n                                swipeLeft = true;\n                            }\n\n                        // Make Slide Behind active slide visible\n                        var next_slide;\n                        if (swipeLeft) {\n                            next_slide = curr_slide.next();\n                            if (next_slide.length === 0) {\n                                next_slide = $slides.first();\n                            }\n                            next_slide.velocity({\n                                opacity: 1\n                            }, {\n                                duration: 300,\n                                queue: false,\n                                easing: 'easeOutQuad'\n                            });\n                        }\n                        if (swipeRight) {\n                            next_slide = curr_slide.prev();\n                            if (next_slide.length === 0) {\n                                next_slide = $slides.last();\n                            }\n                            next_slide.velocity({\n                                opacity: 1\n                            }, {\n                                duration: 300,\n                                queue: false,\n                                easing: 'easeOutQuad'\n                            });\n                        }\n                    }\n                }).bind('panend', function (e) {\n                    if (e.gesture.pointerType === \"touch\") {\n\n                        var curr_slide = $slider.find('.active');\n                        panning = false;\n                        var curr_index = $slider.find('.active').index();\n\n                        if (!swipeRight && !swipeLeft || $slides.length <= 1) {\n                            // Return to original spot\n                            curr_slide.velocity({\n                                translateX: 0\n                            }, {\n                                duration: 300,\n                                queue: false,\n                                easing: 'easeOutQuad'\n                            });\n                        } else if (swipeLeft) {\n                            moveToSlide(curr_index + 1);\n                            curr_slide.velocity({\n                                translateX: -1 * $this.innerWidth()\n                            }, {\n                                duration: 300,\n                                queue: false,\n                                easing: 'easeOutQuad',\n                                complete: function complete() {\n                                    curr_slide.velocity({\n                                        opacity: 0,\n                                        translateX: 0\n                                    }, {\n                                        duration: 0,\n                                        queue: false\n                                    });\n                                }\n                            });\n                        } else if (swipeRight) {\n                            moveToSlide(curr_index - 1);\n                            curr_slide.velocity({\n                                translateX: $this.innerWidth()\n                            }, {\n                                duration: 300,\n                                queue: false,\n                                easing: 'easeOutQuad',\n                                complete: function complete() {\n                                    curr_slide.velocity({\n                                        opacity: 0,\n                                        translateX: 0\n                                    }, {\n                                        duration: 0,\n                                        queue: false\n                                    });\n                                }\n                            });\n                        }\n                        swipeLeft = false;\n                        swipeRight = false;\n\n                        // Restart interval\n                        clearInterval($interval);\n                        $interval = setInterval(function () {\n                            $active_index = $slider.find('.active').index();\n                            if ($slides.length == $active_index + 1) $active_index = 0; // loop to start\n                            else $active_index += 1;\n\n                            moveToSlide($active_index);\n                        }, options.transition + options.interval);\n                    }\n                });\n\n                $this.on('sliderPause', function () {\n                    clearInterval($interval);\n                });\n\n                $this.on('sliderStart', function () {\n                    clearInterval($interval);\n                    $interval = setInterval(function () {\n                        $active_index = $slider.find('.active').index();\n                        if ($slides.length == $active_index + 1) $active_index = 0; // loop to start\n                        else $active_index += 1;\n\n                        moveToSlide($active_index);\n                    }, options.transition + options.interval);\n                });\n\n                $this.on('sliderNext', function () {\n                    $active_index = $slider.find('.active').index();\n                    moveToSlide($active_index + 1);\n                });\n\n                $this.on('sliderPrev', function () {\n                    $active_index = $slider.find('.active').index();\n                    moveToSlide($active_index - 1);\n                });\n            });\n        },\n        pause: function pause() {\n            $(this).trigger('sliderPause');\n        },\n        start: function start() {\n            $(this).trigger('sliderStart');\n        },\n        next: function next() {\n            $(this).trigger('sliderNext');\n        },\n        prev: function prev() {\n            $(this).trigger('sliderPrev');\n        }\n    };\n\n    $.fn.slider = function (methodOrOptions) {\n        if (methods[methodOrOptions]) {\n            return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));\n        } else if ((typeof methodOrOptions === 'undefined' ? 'undefined' : _typeof(methodOrOptions)) === 'object' || !methodOrOptions) {\n            // Default to \"init\"\n            return methods.init.apply(this, arguments);\n        } else {\n            $.error('Method ' + methodOrOptions + ' does not exist on jQuery.tooltip');\n        }\n    }; // Plugin end\n})(jQuery);;\n(function ($) {\n    $(document).ready(function () {\n\n        $(document).on('click.card', '.card', function (e) {\n            if ($(this).find('> .card-reveal').length) {\n                if ($(e.target).is($('.card-reveal .card-title')) || $(e.target).is($('.card-reveal .card-title i'))) {\n                    // Make Reveal animate down and display none\n                    $(this).find('.card-reveal').velocity({\n                        translateY: 0\n                    }, {\n                        duration: 225,\n                        queue: false,\n                        easing: 'easeInOutQuad',\n                        complete: function complete() {\n                            $(this).css({\n                                display: 'none'\n                            });\n                        }\n                    });\n                } else if ($(e.target).is($('.card .activator')) || $(e.target).is($('.card .activator i'))) {\n                    $(e.target).closest('.card').css('overflow', 'hidden');\n                    $(this).find('.card-reveal').css({\n                        display: 'block'\n                    }).velocity(\"stop\", false).velocity({\n                        translateY: '-100%'\n                    }, {\n                        duration: 300,\n                        queue: false,\n                        easing: 'easeInOutQuad'\n                    });\n                }\n            }\n\n            $('.card-reveal').closest('.card').css('overflow', 'hidden');\n        });\n    });\n})(jQuery);\n(function ($) {\n    $(document).ready(function () {\n\n        $(document).on('click.chip', '.chip .material-icons', function (e) {\n            $(this).parent().remove();\n        });\n    });\n})(jQuery);\n(function ($) {\n    $.fn.pushpin = function (options) {\n\n        var defaults = {\n            top: 0,\n            bottom: Infinity,\n            offset: 0\n        };\n        options = $.extend(defaults, options);\n\n        $index = 0;\n        return this.each(function () {\n            var $uniqueId = Materialize.guid(),\n                $this = $(this),\n                $original_offset = $(this).offset().top;\n\n            function removePinClasses(object) {\n                object.removeClass('pin-top');\n                object.removeClass('pinned');\n                object.removeClass('pin-bottom');\n            }\n\n            function updateElements(objects, scrolled) {\n                objects.each(function () {\n                    // Add position fixed (because its between top and bottom)\n                    if (options.top <= scrolled && options.bottom >= scrolled && !$(this).hasClass('pinned')) {\n                        removePinClasses($(this));\n                        $(this).css('top', options.offset);\n                        $(this).addClass('pinned');\n                    }\n\n                    // Add pin-top (when scrolled position is above top)\n                    if (scrolled < options.top && !$(this).hasClass('pin-top')) {\n                        removePinClasses($(this));\n                        $(this).css('top', 0);\n                        $(this).addClass('pin-top');\n                    }\n\n                    // Add pin-bottom (when scrolled position is below bottom)\n                    if (scrolled > options.bottom && !$(this).hasClass('pin-bottom')) {\n                        removePinClasses($(this));\n                        $(this).addClass('pin-bottom');\n                        $(this).css('top', options.bottom - $original_offset);\n                    }\n                });\n            }\n\n            updateElements($this, $(window).scrollTop());\n            $(window).on('scroll.' + $uniqueId, function () {\n                var $scrolled = $(window).scrollTop() + options.offset;\n                updateElements($this, $scrolled);\n            });\n        });\n    };\n})(jQuery);\n(function ($) {\n    $(document).ready(function () {\n\n        // jQuery reverse\n        $.fn.reverse = [].reverse;\n\n        // Hover behaviour: make sure this doesn't work on .click-to-toggle FABs!\n        $(document).on('mouseenter.fixedActionBtn', '.fixed-action-btn:not(.click-to-toggle)', function (e) {\n            var nodeElem = $(this);\n            openFABMenu(nodeElem);\n        });\n        $(document).on('mouseleave.fixedActionBtn', '.fixed-action-btn:not(.click-to-toggle)', function (e) {\n            var nodeElem = $(this);\n            closeFABMenu(nodeElem);\n        });\n\n        // Toggle-on-click behaviour.\n        $(document).on('click.fixedActionBtn', '.fixed-action-btn.click-to-toggle > a', function (e) {\n            var nodeElem = $(this);\n            var $menu = nodeElem.parent();\n            if ($menu.hasClass('active')) {\n                closeFABMenu($menu);\n            } else {\n                openFABMenu($menu);\n            }\n        });\n    });\n\n    $.fn.extend({\n        openFAB: function openFAB() {\n            openFABMenu($(this));\n        },\n        closeFAB: function closeFAB() {\n            closeFABMenu($(this));\n        }\n    });\n\n    var openFABMenu = function openFABMenu(btn) {\n        var nodeElem = btn;\n        if (nodeElem.hasClass('active') === false) {\n\n            // Get direction option\n            var horizontal = nodeElem.hasClass('horizontal');\n            var offsetY, offsetX;\n\n            if (horizontal === true) {\n                offsetX = 40;\n            } else {\n                offsetY = 40;\n            }\n\n            nodeElem.addClass('active');\n            nodeElem.find('ul .btn-floating').velocity({\n                scaleY: \".4\",\n                scaleX: \".4\",\n                translateY: offsetY + 'px',\n                translateX: offsetX + 'px'\n            }, {\n                duration: 0\n            });\n\n            var time = 0;\n            nodeElem.find('ul .btn-floating').reverse().each(function () {\n                $(this).velocity({\n                    opacity: \"1\",\n                    scaleX: \"1\",\n                    scaleY: \"1\",\n                    translateY: \"0\",\n                    translateX: '0'\n                }, {\n                    duration: 80,\n                    delay: time\n                });\n                time += 40;\n            });\n        }\n    };\n\n    var closeFABMenu = function closeFABMenu(btn) {\n        var nodeElem = btn;\n        // Get direction option\n        var horizontal = nodeElem.hasClass('horizontal');\n        var offsetY, offsetX;\n\n        if (horizontal === true) {\n            offsetX = 40;\n        } else {\n            offsetY = 40;\n        }\n\n        nodeElem.removeClass('active');\n        var time = 0;\n        nodeElem.find('ul .btn-floating').velocity(\"stop\", true);\n        nodeElem.find('ul .btn-floating').velocity({\n            opacity: \"0\",\n            scaleX: \".4\",\n            scaleY: \".4\",\n            translateY: offsetY + 'px',\n            translateX: offsetX + 'px'\n        }, {\n            duration: 80\n        });\n    };\n})(jQuery);\n(function ($) {\n    // Image transition function\n    Materialize.fadeInImage = function (selector) {\n        var element = $(selector);\n        element.css({\n            opacity: 0\n        });\n        $(element).velocity({\n            opacity: 1\n        }, {\n            duration: 650,\n            queue: false,\n            easing: 'easeOutSine'\n        });\n        $(element).velocity({\n            opacity: 1\n        }, {\n            duration: 1300,\n            queue: false,\n            easing: 'swing',\n            step: function step(now, fx) {\n                fx.start = 100;\n                var grayscale_setting = now / 100;\n                var brightness_setting = 150 - (100 - now) / 1.75;\n\n                if (brightness_setting < 100) {\n                    brightness_setting = 100;\n                }\n                if (now >= 0) {\n                    $(this).css({\n                        \"-webkit-filter\": \"grayscale(\" + grayscale_setting + \")\" + \"brightness(\" + brightness_setting + \"%)\",\n                        \"filter\": \"grayscale(\" + grayscale_setting + \")\" + \"brightness(\" + brightness_setting + \"%)\"\n                    });\n                }\n            }\n        });\n    };\n\n    // Horizontal staggered list\n    Materialize.showStaggeredList = function (selector) {\n        var time = 0;\n        $(selector).find('li').velocity({\n            translateX: \"-100px\"\n        }, {\n            duration: 0\n        });\n\n        $(selector).find('li').each(function () {\n            $(this).velocity({\n                opacity: \"1\",\n                translateX: \"0\"\n            }, {\n                duration: 800,\n                delay: time,\n                easing: [60, 10]\n            });\n            time += 120;\n        });\n    };\n\n    $(document).ready(function () {\n        // Hardcoded .staggered-list scrollFire\n        // var staggeredListOptions = [];\n        // $('ul.staggered-list').each(function (i) {\n\n        //   var label = 'scrollFire-' + i;\n        //   $(this).addClass(label);\n        //   staggeredListOptions.push(\n        //     {selector: 'ul.staggered-list.' + label,\n        //      offset: 200,\n        //      callback: 'showStaggeredList(\"ul.staggered-list.' + label + '\")'});\n        // });\n        // scrollFire(staggeredListOptions);\n\n        // HammerJS, Swipe navigation\n\n        // Touch Event\n        var swipeLeft = false;\n        var swipeRight = false;\n\n        // Dismissible Collections\n        $('.dismissable').each(function () {\n            $(this).hammer({\n                prevent_default: false\n            }).bind('pan', function (e) {\n                if (e.gesture.pointerType === \"touch\") {\n                    var $this = $(this);\n                    var direction = e.gesture.direction;\n                    var x = e.gesture.deltaX;\n                    var velocityX = e.gesture.velocityX;\n\n                    $this.velocity({\n                        translateX: x\n                    }, {\n                        duration: 50,\n                        queue: false,\n                        easing: 'easeOutQuad'\n                    });\n\n                    // Swipe Left\n                    if (direction === 4 && (x > $this.innerWidth() / 2 || velocityX < -0.75)) {\n                        swipeLeft = true;\n                    }\n\n                    // Swipe Right\n                    if (direction === 2 && (x < -1 * $this.innerWidth() / 2 || velocityX > 0.75)) {\n                        swipeRight = true;\n                    }\n                }\n            }).bind('panend', function (e) {\n                // Reset if collection is moved back into original position\n                if (Math.abs(e.gesture.deltaX) < $(this).innerWidth() / 2) {\n                    swipeRight = false;\n                    swipeLeft = false;\n                }\n\n                if (e.gesture.pointerType === \"touch\") {\n                    var $this = $(this);\n                    if (swipeLeft || swipeRight) {\n                        var fullWidth;\n                        if (swipeLeft) {\n                            fullWidth = $this.innerWidth();\n                        } else {\n                            fullWidth = -1 * $this.innerWidth();\n                        }\n\n                        $this.velocity({\n                            translateX: fullWidth\n                        }, {\n                            duration: 100,\n                            queue: false,\n                            easing: 'easeOutQuad',\n                            complete: function complete() {\n                                $this.css('border', 'none');\n                                $this.velocity({\n                                    height: 0,\n                                    padding: 0\n                                }, {\n                                    duration: 200,\n                                    queue: false,\n                                    easing: 'easeOutQuad',\n                                    complete: function complete() {\n                                        $this.remove();\n                                    }\n                                });\n                            }\n                        });\n                    } else {\n                        $this.velocity({\n                            translateX: 0\n                        }, {\n                            duration: 100,\n                            queue: false,\n                            easing: 'easeOutQuad'\n                        });\n                    }\n                    swipeLeft = false;\n                    swipeRight = false;\n                }\n            });\n        });\n\n        // time = 0\n        // // Vertical Staggered list\n        // $('ul.staggered-list.vertical li').velocity(\n        //     { translateY: \"100px\"},\n        //     { duration: 0 });\n\n        // $('ul.staggered-list.vertical li').each(function() {\n        //   $(this).velocity(\n        //     { opacity: \"1\", translateY: \"0\"},\n        //     { duration: 800, delay: time, easing: [60, 25] });\n        //   time += 120;\n        // });\n\n        // // Fade in and Scale\n        // $('.fade-in.scale').velocity(\n        //     { scaleX: .4, scaleY: .4, translateX: -600},\n        //     { duration: 0});\n        // $('.fade-in').each(function() {\n        //   $(this).velocity(\n        //     { opacity: \"1\", scaleX: 1, scaleY: 1, translateX: 0},\n        //     { duration: 800, easing: [60, 10] });\n        // });\n    });\n})(jQuery);;\n(function ($) {\n\n    // Input: Array of JSON objects {selector, offset, callback}\n\n    Materialize.scrollFire = function (options) {\n\n        var didScroll = false;\n\n        window.addEventListener(\"scroll\", function () {\n            didScroll = true;\n        });\n\n        // Rate limit to 100ms\n        setInterval(function () {\n            if (didScroll) {\n                didScroll = false;\n\n                var windowScroll = window.pageYOffset + window.innerHeight;\n\n                for (var i = 0; i < options.length; i++) {\n                    // Get options from each line\n                    var value = options[i];\n                    var selector = value.selector,\n                        offset = value.offset,\n                        callback = value.callback;\n\n                    var currentElement = document.querySelector(selector);\n                    if (currentElement !== null) {\n                        var elementOffset = currentElement.getBoundingClientRect().top + window.pageYOffset;\n\n                        if (windowScroll > elementOffset + offset) {\n                            if (value.done !== true) {\n                                if (typeof callback === 'function') {\n                                    callback.call(this);\n                                } else if (typeof callback === 'string') {\n                                    var callbackFunc = new Function(callback);\n                                    callbackFunc();\n                                }\n                                value.done = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }, 100);\n    };\n})(jQuery);;\n/*!\r\n * pickadate.js v3.5.0, 2014/04/13\r\n * By Amsul, http://amsul.ca\r\n * Hosted on http://amsul.github.io/pickadate.js\r\n * Licensed under MIT\r\n */\n\n(function (factory) {\n\n    // AMD.\n    if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_LOCAL_MODULE_0__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));\n\n    // Node.js/browserify.\n    else {}\n})(function ($) {\n\n    var $window = $(window);\n    var $document = $(document);\n    var $html = $(document.documentElement);\n\n    /**\r\n     * The picker constructor that creates a blank picker.\r\n     */\n    function PickerConstructor(ELEMENT, NAME, COMPONENT, OPTIONS) {\n\n        // If there’s no element, return the picker constructor.\n        if (!ELEMENT) return PickerConstructor;\n\n        var IS_DEFAULT_THEME = false,\n\n\n        // The state of the picker.\n        STATE = {\n            id: ELEMENT.id || 'P' + Math.abs(~~(Math.random() * new Date()))\n        },\n\n\n        // Merge the defaults and options passed.\n        SETTINGS = COMPONENT ? $.extend(true, {}, COMPONENT.defaults, OPTIONS) : OPTIONS || {},\n\n\n        // Merge the default classes with the settings classes.\n        CLASSES = $.extend({}, PickerConstructor.klasses(), SETTINGS.klass),\n\n\n        // The element node wrapper into a jQuery object.\n        $ELEMENT = $(ELEMENT),\n\n\n        // Pseudo picker constructor.\n        PickerInstance = function PickerInstance() {\n            return this.start();\n        },\n\n\n        // The picker prototype.\n        P = PickerInstance.prototype = {\n\n            constructor: PickerInstance,\n\n            $node: $ELEMENT,\n\n            /**\r\n             * Initialize everything\r\n             */\n            start: function start() {\n\n                // If it’s already started, do nothing.\n                if (STATE && STATE.start) return P;\n\n                // Update the picker states.\n                STATE.methods = {};\n                STATE.start = true;\n                STATE.open = false;\n                STATE.type = ELEMENT.type;\n\n                // Confirm focus state, convert into text input to remove UA stylings,\n                // and set as readonly to prevent keyboard popup.\n                ELEMENT.autofocus = ELEMENT == getActiveElement();\n                ELEMENT.readOnly = !SETTINGS.editable;\n                ELEMENT.id = ELEMENT.id || STATE.id;\n                if (ELEMENT.type != 'text') {\n                    ELEMENT.type = 'text';\n                }\n\n                // Create a new picker component with the settings.\n                P.component = new COMPONENT(P, SETTINGS);\n\n                // Create the picker root with a holder and then prepare it.\n                P.$root = $(PickerConstructor._.node('div', createWrappedComponent(), CLASSES.picker, 'id=\"' + ELEMENT.id + '_root\" tabindex=\"0\"'));\n                prepareElementRoot();\n\n                // If there’s a format for the hidden input element, create the element.\n                if (SETTINGS.formatSubmit) {\n                    prepareElementHidden();\n                }\n\n                // Prepare the input element.\n                prepareElement();\n\n                // Insert the root as specified in the settings.\n                if (SETTINGS.container) $(SETTINGS.container).append(P.$root);else $ELEMENT.after(P.$root);\n\n                // Bind the default component and settings events.\n                P.on({\n                    start: P.component.onStart,\n                    render: P.component.onRender,\n                    stop: P.component.onStop,\n                    open: P.component.onOpen,\n                    close: P.component.onClose,\n                    set: P.component.onSet\n                }).on({\n                    start: SETTINGS.onStart,\n                    render: SETTINGS.onRender,\n                    stop: SETTINGS.onStop,\n                    open: SETTINGS.onOpen,\n                    close: SETTINGS.onClose,\n                    set: SETTINGS.onSet\n                });\n\n                // Once we’re all set, check the theme in use.\n                IS_DEFAULT_THEME = isUsingDefaultTheme(P.$root.children()[0]);\n\n                // If the element has autofocus, open the picker.\n                if (ELEMENT.autofocus) {\n                    P.open();\n                }\n\n                // Trigger queued the “start” and “render” events.\n                return P.trigger('start').trigger('render');\n            }, //start\n\n\n            /**\r\n             * Render a new picker\r\n             */\n            render: function render(entireComponent) {\n\n                // Insert a new component holder in the root or box.\n                if (entireComponent) P.$root.html(createWrappedComponent());else P.$root.find('.' + CLASSES.box).html(P.component.nodes(STATE.open));\n\n                // Trigger the queued “render” events.\n                return P.trigger('render');\n            }, //render\n\n\n            /**\r\n             * Destroy everything\r\n             */\n            stop: function stop() {\n\n                // If it’s already stopped, do nothing.\n                if (!STATE.start) return P;\n\n                // Then close the picker.\n                P.close();\n\n                // Remove the hidden field.\n                if (P._hidden) {\n                    P._hidden.parentNode.removeChild(P._hidden);\n                }\n\n                // Remove the root.\n                P.$root.remove();\n\n                // Remove the input class, remove the stored data, and unbind\n                // the events (after a tick for IE - see `P.close`).\n                $ELEMENT.removeClass(CLASSES.input).removeData(NAME);\n                setTimeout(function () {\n                    $ELEMENT.off('.' + STATE.id);\n                }, 0);\n\n                // Restore the element state\n                ELEMENT.type = STATE.type;\n                ELEMENT.readOnly = false;\n\n                // Trigger the queued “stop” events.\n                P.trigger('stop');\n\n                // Reset the picker states.\n                STATE.methods = {};\n                STATE.start = false;\n\n                return P;\n            }, //stop\n\n\n            /**\r\n             * Open up the picker\r\n             */\n            open: function open(dontGiveFocus) {\n\n                // If it’s already open, do nothing.\n                if (STATE.open) return P;\n\n                // Add the “active” class.\n                $ELEMENT.addClass(CLASSES.active);\n                aria(ELEMENT, 'expanded', true);\n\n                // * A Firefox bug, when `html` has `overflow:hidden`, results in\n                //   killing transitions :(. So add the “opened” state on the next tick.\n                //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289\n                setTimeout(function () {\n\n                    // Add the “opened” class to the picker root.\n                    P.$root.addClass(CLASSES.opened);\n                    aria(P.$root[0], 'hidden', false);\n                }, 0);\n\n                // If we have to give focus, bind the element and doc events.\n                if (dontGiveFocus !== false) {\n\n                    // Set it as open.\n                    STATE.open = true;\n\n                    // Prevent the page from scrolling.\n                    if (IS_DEFAULT_THEME) {\n                        $html.css('overflow', 'hidden').css('padding-right', '+=' + getScrollbarWidth());\n                    }\n\n                    // Pass focus to the root element’s jQuery object.\n                    // * Workaround for iOS8 to bring the picker’s root into view.\n                    P.$root.eq(0).focus();\n\n                    // Bind the document events.\n                    $document.on('click.' + STATE.id + ' focusin.' + STATE.id, function (event) {\n\n                        var target = event.target;\n\n                        // If the target of the event is not the element, close the picker picker.\n                        // * Don’t worry about clicks or focusins on the root because those don’t bubble up.\n                        //   Also, for Firefox, a click on an `option` element bubbles up directly\n                        //   to the doc. So make sure the target wasn't the doc.\n                        // * In Firefox stopPropagation() doesn’t prevent right-click events from bubbling,\n                        //   which causes the picker to unexpectedly close when right-clicking it. So make\n                        //   sure the event wasn’t a right-click.\n                        if (target != ELEMENT && target != document && event.which != 3) {\n\n                            // If the target was the holder that covers the screen,\n                            // keep the element focused to maintain tabindex.\n                            P.close(target === P.$root.children()[0]);\n                        }\n                    }).on('keydown.' + STATE.id, function (event) {\n\n                        var\n                        // Get the keycode.\n                        keycode = event.keyCode,\n\n\n                        // Translate that to a selection change.\n                        keycodeToMove = P.component.key[keycode],\n\n\n                        // Grab the target.\n                        target = event.target;\n\n                        // On escape, close the picker and give focus.\n                        if (keycode == 27) {\n                            P.close(true);\n                        }\n\n                        // Check if there is a key movement or “enter” keypress on the element.\n                        else if (target == P.$root[0] && (keycodeToMove || keycode == 13)) {\n\n                                // Prevent the default action to stop page movement.\n                                event.preventDefault();\n\n                                // Trigger the key movement action.\n                                if (keycodeToMove) {\n                                    PickerConstructor._.trigger(P.component.key.go, P, [PickerConstructor._.trigger(keycodeToMove)]);\n                                }\n\n                                // On “enter”, if the highlighted item isn’t disabled, set the value and close.\n                                else if (!P.$root.find('.' + CLASSES.highlighted).hasClass(CLASSES.disabled)) {\n                                        P.set('select', P.component.item.highlight).close();\n                                    }\n                            }\n\n                            // If the target is within the root and “enter” is pressed,\n                            // prevent the default action and trigger a click on the target instead.\n                            else if ($.contains(P.$root[0], target) && keycode == 13) {\n                                    event.preventDefault();\n                                    target.click();\n                                }\n                    });\n                }\n\n                // Trigger the queued “open” events.\n                return P.trigger('open');\n            }, //open\n\n\n            /**\r\n             * Close the picker\r\n             */\n            close: function close(giveFocus) {\n\n                // If we need to give focus, do it before changing states.\n                if (giveFocus) {\n                    // ....ah yes! It would’ve been incomplete without a crazy workaround for IE :|\n                    // The focus is triggered *after* the close has completed - causing it\n                    // to open again. So unbind and rebind the event at the next tick.\n                    P.$root.off('focus.toOpen').eq(0).focus();\n                    setTimeout(function () {\n                        P.$root.on('focus.toOpen', handleFocusToOpenEvent);\n                    }, 0);\n                }\n\n                // Remove the “active” class.\n                $ELEMENT.removeClass(CLASSES.active);\n                aria(ELEMENT, 'expanded', false);\n\n                // * A Firefox bug, when `html` has `overflow:hidden`, results in\n                //   killing transitions :(. So remove the “opened” state on the next tick.\n                //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289\n                setTimeout(function () {\n\n                    // Remove the “opened” and “focused” class from the picker root.\n                    P.$root.removeClass(CLASSES.opened + ' ' + CLASSES.focused);\n                    aria(P.$root[0], 'hidden', true);\n                }, 0);\n\n                // If it’s already closed, do nothing more.\n                if (!STATE.open) return P;\n\n                // Set it as closed.\n                STATE.open = false;\n\n                // Allow the page to scroll.\n                if (IS_DEFAULT_THEME) {\n                    $html.css('overflow', '').css('padding-right', '-=' + getScrollbarWidth());\n                }\n\n                // Unbind the document events.\n                $document.off('.' + STATE.id);\n\n                // Trigger the queued “close” events.\n                return P.trigger('close');\n            }, //close\n\n\n            /**\r\n             * Clear the values\r\n             */\n            clear: function clear(options) {\n                return P.set('clear', null, options);\n            }, //clear\n\n\n            /**\r\n             * Set something\r\n             */\n            set: function set(thing, value, options) {\n\n                var thingItem,\n                    thingValue,\n                    thingIsObject = $.isPlainObject(thing),\n                    thingObject = thingIsObject ? thing : {};\n\n                // Make sure we have usable options.\n                options = thingIsObject && $.isPlainObject(value) ? value : options || {};\n\n                if (thing) {\n\n                    // If the thing isn’t an object, make it one.\n                    if (!thingIsObject) {\n                        thingObject[thing] = value;\n                    }\n\n                    // Go through the things of items to set.\n                    for (thingItem in thingObject) {\n\n                        // Grab the value of the thing.\n                        thingValue = thingObject[thingItem];\n\n                        // First, if the item exists and there’s a value, set it.\n                        if (thingItem in P.component.item) {\n                            if (thingValue === undefined) thingValue = null;\n                            P.component.set(thingItem, thingValue, options);\n                        }\n\n                        // Then, check to update the element value and broadcast a change.\n                        if (thingItem == 'select' || thingItem == 'clear') {\n                            $ELEMENT.val(thingItem == 'clear' ? '' : P.get(thingItem, SETTINGS.format)).trigger('change');\n                        }\n                    }\n\n                    // Render a new picker.\n                    P.render();\n                }\n\n                // When the method isn’t muted, trigger queued “set” events and pass the `thingObject`.\n                return options.muted ? P : P.trigger('set', thingObject);\n            }, //set\n\n\n            /**\r\n             * Get something\r\n             */\n            get: function get(thing, format) {\n\n                // Make sure there’s something to get.\n                thing = thing || 'value';\n\n                // If a picker state exists, return that.\n                if (STATE[thing] != null) {\n                    return STATE[thing];\n                }\n\n                // Return the submission value, if that.\n                if (thing == 'valueSubmit') {\n                    if (P._hidden) {\n                        return P._hidden.value;\n                    }\n                    thing = 'value';\n                }\n\n                // Return the value, if that.\n                if (thing == 'value') {\n                    return ELEMENT.value;\n                }\n\n                // Check if a component item exists, return that.\n                if (thing in P.component.item) {\n                    if (typeof format == 'string') {\n                        var thingValue = P.component.get(thing);\n                        return thingValue ? PickerConstructor._.trigger(P.component.formats.toString, P.component, [format, thingValue]) : '';\n                    }\n                    return P.component.get(thing);\n                }\n            }, //get\n\n\n            /**\r\n             * Bind events on the things.\r\n             */\n            on: function on(thing, method, internal) {\n\n                var thingName,\n                    thingMethod,\n                    thingIsObject = $.isPlainObject(thing),\n                    thingObject = thingIsObject ? thing : {};\n\n                if (thing) {\n\n                    // If the thing isn’t an object, make it one.\n                    if (!thingIsObject) {\n                        thingObject[thing] = method;\n                    }\n\n                    // Go through the things to bind to.\n                    for (thingName in thingObject) {\n\n                        // Grab the method of the thing.\n                        thingMethod = thingObject[thingName];\n\n                        // If it was an internal binding, prefix it.\n                        if (internal) {\n                            thingName = '_' + thingName;\n                        }\n\n                        // Make sure the thing methods collection exists.\n                        STATE.methods[thingName] = STATE.methods[thingName] || [];\n\n                        // Add the method to the relative method collection.\n                        STATE.methods[thingName].push(thingMethod);\n                    }\n                }\n\n                return P;\n            }, //on\n\n\n            /**\r\n             * Unbind events on the things.\r\n             */\n            off: function off() {\n                var i,\n                    thingName,\n                    names = arguments;\n                for (i = 0, namesCount = names.length; i < namesCount; i += 1) {\n                    thingName = names[i];\n                    if (thingName in STATE.methods) {\n                        delete STATE.methods[thingName];\n                    }\n                }\n                return P;\n            },\n\n            /**\r\n             * Fire off method events.\r\n             */\n            trigger: function trigger(name, data) {\n                var _trigger = function _trigger(name) {\n                    var methodList = STATE.methods[name];\n                    if (methodList) {\n                        methodList.map(function (method) {\n                            PickerConstructor._.trigger(method, P, [data]);\n                        });\n                    }\n                };\n                _trigger('_' + name);\n                _trigger(name);\n                return P;\n            } //trigger\n            //PickerInstance.prototype\n\n\n            /**\r\n             * Wrap the picker holder components together.\r\n             */\n        };function createWrappedComponent() {\n\n            // Create a picker wrapper holder\n            return PickerConstructor._.node('div',\n\n            // Create a picker wrapper node\n            PickerConstructor._.node('div',\n\n            // Create a picker frame\n            PickerConstructor._.node('div',\n\n            // Create a picker box node\n            PickerConstructor._.node('div',\n\n            // Create the components nodes.\n            P.component.nodes(STATE.open),\n\n            // The picker box class\n            CLASSES.box),\n\n            // Picker wrap class\n            CLASSES.wrap),\n\n            // Picker frame class\n            CLASSES.frame),\n\n            // Picker holder class\n            CLASSES.holder); //endreturn\n        } //createWrappedComponent\n\n\n        /**\r\n         * Prepare the input element with all bindings.\r\n         */\n        function prepareElement() {\n\n            $ELEMENT.\n\n            // Store the picker data by component name.\n            data(NAME, P).\n\n            // Add the “input” class name.\n            addClass(CLASSES.input).\n\n            // Remove the tabindex.\n            attr('tabindex', -1).\n\n            // If there’s a `data-value`, update the value of the element.\n            val($ELEMENT.data('value') ? P.get('select', SETTINGS.format) : ELEMENT.value);\n\n            // Only bind keydown events if the element isn’t editable.\n            if (!SETTINGS.editable) {\n\n                $ELEMENT.\n\n                // On focus/click, focus onto the root to open it up.\n                on('focus.' + STATE.id + ' click.' + STATE.id, function (event) {\n                    event.preventDefault();\n                    P.$root.eq(0).focus();\n                }).\n\n                // Handle keyboard event based on the picker being opened or not.\n                on('keydown.' + STATE.id, handleKeydownEvent);\n            }\n\n            // Update the aria attributes.\n            aria(ELEMENT, {\n                haspopup: true,\n                expanded: false,\n                readonly: false,\n                owns: ELEMENT.id + '_root'\n            });\n        }\n\n        /**\r\n         * Prepare the root picker element with all bindings.\r\n         */\n        function prepareElementRoot() {\n\n            P.$root.on({\n\n                // For iOS8.\n                keydown: handleKeydownEvent,\n\n                // When something within the root is focused, stop from bubbling\n                // to the doc and remove the “focused” state from the root.\n                focusin: function focusin(event) {\n                    P.$root.removeClass(CLASSES.focused);\n                    event.stopPropagation();\n                },\n\n                // When something within the root holder is clicked, stop it\n                // from bubbling to the doc.\n                'mousedown click': function mousedownClick(event) {\n\n                    var target = event.target;\n\n                    // Make sure the target isn’t the root holder so it can bubble up.\n                    if (target != P.$root.children()[0]) {\n\n                        event.stopPropagation();\n\n                        // * For mousedown events, cancel the default action in order to\n                        //   prevent cases where focus is shifted onto external elements\n                        //   when using things like jQuery mobile or MagnificPopup (ref: #249 & #120).\n                        //   Also, for Firefox, don’t prevent action on the `option` element.\n                        if (event.type == 'mousedown' && !$(target).is('input, select, textarea, button, option')) {\n\n                            event.preventDefault();\n\n                            // Re-focus onto the root so that users can click away\n                            // from elements focused within the picker.\n                            P.$root.eq(0).focus();\n                        }\n                    }\n                }\n            }).\n\n            // Add/remove the “target” class on focus and blur.\n            on({\n                focus: function focus() {\n                    $ELEMENT.addClass(CLASSES.target);\n                },\n                blur: function blur() {\n                    $ELEMENT.removeClass(CLASSES.target);\n                }\n            }).\n\n            // Open the picker and adjust the root “focused” state\n            on('focus.toOpen', handleFocusToOpenEvent).\n\n            // If there’s a click on an actionable element, carry out the actions.\n            on('click', '[data-pick], [data-nav], [data-clear], [data-close]', function () {\n\n                var $target = $(this),\n                    targetData = $target.data(),\n                    targetDisabled = $target.hasClass(CLASSES.navDisabled) || $target.hasClass(CLASSES.disabled),\n\n\n                // * For IE, non-focusable elements can be active elements as well\n                //   (http://stackoverflow.com/a/2684561).\n                activeElement = getActiveElement();\n                activeElement = activeElement && (activeElement.type || activeElement.href);\n\n                // If it’s disabled or nothing inside is actively focused, re-focus the element.\n                if (targetDisabled || activeElement && !$.contains(P.$root[0], activeElement)) {\n                    P.$root.eq(0).focus();\n                }\n\n                // If something is superficially changed, update the `highlight` based on the `nav`.\n                if (!targetDisabled && targetData.nav) {\n                    P.set('highlight', P.component.item.highlight, {\n                        nav: targetData.nav\n                    });\n                }\n\n                // If something is picked, set `select` then close with focus.\n                else if (!targetDisabled && 'pick' in targetData) {\n                        P.set('select', targetData.pick);\n                    }\n\n                    // If a “clear” button is pressed, empty the values and close with focus.\n                    else if (targetData.clear) {\n                            P.clear().close(true);\n                        } else if (targetData.close) {\n                            P.close(true);\n                        }\n            }); //P.$root\n\n            aria(P.$root[0], 'hidden', true);\n        }\n\n        /**\r\n         * Prepare the hidden input element along with all bindings.\r\n         */\n        function prepareElementHidden() {\n\n            var name;\n\n            if (SETTINGS.hiddenName === true) {\n                name = ELEMENT.name;\n                ELEMENT.name = '';\n            } else {\n                name = [typeof SETTINGS.hiddenPrefix == 'string' ? SETTINGS.hiddenPrefix : '', typeof SETTINGS.hiddenSuffix == 'string' ? SETTINGS.hiddenSuffix : '_submit'];\n                name = name[0] + ELEMENT.name + name[1];\n            }\n\n            P._hidden = $('<input ' + 'type=hidden ' +\n\n            // Create the name using the original input’s with a prefix and suffix.\n            'name=\"' + name + '\"' + (\n\n            // If the element has a value, set the hidden value as well.\n            $ELEMENT.data('value') || ELEMENT.value ? ' value=\"' + P.get('select', SETTINGS.formatSubmit) + '\"' : '') + '>')[0];\n\n            $ELEMENT.\n\n            // If the value changes, update the hidden input with the correct format.\n            on('change.' + STATE.id, function () {\n                P._hidden.value = ELEMENT.value ? P.get('select', SETTINGS.formatSubmit) : '';\n            });\n\n            // Insert the hidden input as specified in the settings.\n            if (SETTINGS.container) $(SETTINGS.container).append(P._hidden);else $ELEMENT.after(P._hidden);\n        }\n\n        // For iOS8.\n        function handleKeydownEvent(event) {\n\n            var keycode = event.keyCode,\n\n\n            // Check if one of the delete keys was pressed.\n            isKeycodeDelete = /^(8|46)$/.test(keycode);\n\n            // For some reason IE clears the input value on “escape”.\n            if (keycode == 27) {\n                P.close();\n                return false;\n            }\n\n            // Check if `space` or `delete` was pressed or the picker is closed with a key movement.\n            if (keycode == 32 || isKeycodeDelete || !STATE.open && P.component.key[keycode]) {\n\n                // Prevent it from moving the page and bubbling to doc.\n                event.preventDefault();\n                event.stopPropagation();\n\n                // If `delete` was pressed, clear the values and close the picker.\n                // Otherwise open the picker.\n                if (isKeycodeDelete) {\n                    P.clear().close();\n                } else {\n                    P.open();\n                }\n            }\n        }\n\n        // Separated for IE\n        function handleFocusToOpenEvent(event) {\n\n            // Stop the event from propagating to the doc.\n            event.stopPropagation();\n\n            // If it’s a focus event, add the “focused” class to the root.\n            if (event.type == 'focus') {\n                P.$root.addClass(CLASSES.focused);\n            }\n\n            // And then finally open the picker.\n            P.open();\n        }\n\n        // Return a new picker instance.\n        return new PickerInstance();\n    } //PickerConstructor\n\n\n    /**\r\n     * The default classes and prefix to use for the HTML classes.\r\n     */\n    PickerConstructor.klasses = function (prefix) {\n        prefix = prefix || 'picker';\n        return {\n\n            picker: prefix,\n            opened: prefix + '--opened',\n            focused: prefix + '--focused',\n\n            input: prefix + '__input',\n            active: prefix + '__input--active',\n            target: prefix + '__input--target',\n\n            holder: prefix + '__holder',\n\n            frame: prefix + '__frame',\n            wrap: prefix + '__wrap',\n\n            box: prefix + '__box'\n        };\n    }; //PickerConstructor.klasses\n\n\n    /**\r\n     * Check if the default theme is being used.\r\n     */\n    function isUsingDefaultTheme(element) {\n\n        var theme,\n            prop = 'position';\n\n        // For IE.\n        if (element.currentStyle) {\n            theme = element.currentStyle[prop];\n        }\n\n        // For normal browsers.\n        else if (window.getComputedStyle) {\n                theme = getComputedStyle(element)[prop];\n            }\n\n        return theme == 'fixed';\n    }\n\n    /**\r\n     * Get the width of the browser’s scrollbar.\r\n     * Taken from: https://github.com/VodkaBears/Remodal/blob/master/src/jquery.remodal.js\r\n     */\n    function getScrollbarWidth() {\n\n        if ($html.height() <= $window.height()) {\n            return 0;\n        }\n\n        var $outer = $('<div style=\"visibility:hidden;width:100px\" />').appendTo('body');\n\n        // Get the width without scrollbars.\n        var widthWithoutScroll = $outer[0].offsetWidth;\n\n        // Force adding scrollbars.\n        $outer.css('overflow', 'scroll');\n\n        // Add the inner div.\n        var $inner = $('<div style=\"width:100%\" />').appendTo($outer);\n\n        // Get the width with scrollbars.\n        var widthWithScroll = $inner[0].offsetWidth;\n\n        // Remove the divs.\n        $outer.remove();\n\n        // Return the difference between the widths.\n        return widthWithoutScroll - widthWithScroll;\n    }\n\n    /**\r\n     * PickerConstructor helper methods.\r\n     */\n    PickerConstructor._ = {\n\n        /**\r\n         * Create a group of nodes. Expects:\r\n         * `\r\n         {\r\n            min:    {Integer},\r\n            max:    {Integer},\r\n            i:      {Integer},\r\n            node:   {String},\r\n            item:   {Function}\r\n        }\r\n         * `\r\n         */\n        group: function group(groupObject) {\n\n            var\n            // Scope for the looped object\n            loopObjectScope,\n\n\n            // Create the nodes list\n            nodesList = '',\n\n\n            // The counter starts from the `min`\n            counter = PickerConstructor._.trigger(groupObject.min, groupObject);\n\n            // Loop from the `min` to `max`, incrementing by `i`\n            for (; counter <= PickerConstructor._.trigger(groupObject.max, groupObject, [counter]); counter += groupObject.i) {\n\n                // Trigger the `item` function within scope of the object\n                loopObjectScope = PickerConstructor._.trigger(groupObject.item, groupObject, [counter]);\n\n                // Splice the subgroup and create nodes out of the sub nodes\n                nodesList += PickerConstructor._.node(groupObject.node, loopObjectScope[0], // the node\n                loopObjectScope[1], // the classes\n                loopObjectScope[2] // the attributes\n                );\n            }\n\n            // Return the list of nodes\n            return nodesList;\n        }, //group\n\n\n        /**\r\n         * Create a dom node string\r\n         */\n        node: function node(wrapper, item, klass, attribute) {\n\n            // If the item is false-y, just return an empty string\n            if (!item) return '';\n\n            // If the item is an array, do a join\n            item = $.isArray(item) ? item.join('') : item;\n\n            // Check for the class\n            klass = klass ? ' class=\"' + klass + '\"' : '';\n\n            // Check for any attributes\n            attribute = attribute ? ' ' + attribute : '';\n\n            // Return the wrapped item\n            return '<' + wrapper + klass + attribute + '>' + item + '</' + wrapper + '>';\n        }, //node\n\n\n        /**\r\n         * Lead numbers below 10 with a zero.\r\n         */\n        lead: function lead(number) {\n            return (number < 10 ? '0' : '') + number;\n        },\n\n        /**\r\n         * Trigger a function otherwise return the value.\r\n         */\n        trigger: function trigger(callback, scope, args) {\n            return typeof callback == 'function' ? callback.apply(scope, args || []) : callback;\n        },\n\n        /**\r\n         * If the second character is a digit, length is 2 otherwise 1.\r\n         */\n        digits: function digits(string) {\n            return (/\\d/.test(string[1]) ? 2 : 1\n            );\n        },\n\n        /**\r\n         * Tell if something is a date object.\r\n         */\n        isDate: function isDate(value) {\n            return {}.toString.call(value).indexOf('Date') > -1 && this.isInteger(value.getDate());\n        },\n\n        /**\r\n         * Tell if something is an integer.\r\n         */\n        isInteger: function isInteger(value) {\n            return {}.toString.call(value).indexOf('Number') > -1 && value % 1 === 0;\n        },\n\n        /**\r\n         * Create ARIA attribute strings.\r\n         */\n        ariaAttr: ariaAttr //PickerConstructor._\n\n\n        /**\r\n         * Extend the picker with a component and defaults.\r\n         */\n    };PickerConstructor.extend = function (name, Component) {\n\n        // Extend jQuery.\n        $.fn[name] = function (options, action) {\n\n            // Grab the component data.\n            var componentData = this.data(name);\n\n            // If the picker is requested, return the data object.\n            if (options == 'picker') {\n                return componentData;\n            }\n\n            // If the component data exists and `options` is a string, carry out the action.\n            if (componentData && typeof options == 'string') {\n                return PickerConstructor._.trigger(componentData[options], componentData, [action]);\n            }\n\n            // Otherwise go through each matched element and if the component\n            // doesn’t exist, create a new picker using `this` element\n            // and merging the defaults and options with a deep copy.\n            return this.each(function () {\n                var $this = $(this);\n                if (!$this.data(name)) {\n                    new PickerConstructor(this, name, Component, options);\n                }\n            });\n        };\n\n        // Set the defaults.\n        $.fn[name].defaults = Component.defaults;\n    }; //PickerConstructor.extend\n\n\n    function aria(element, attribute, value) {\n        if ($.isPlainObject(attribute)) {\n            for (var key in attribute) {\n                ariaSet(element, key, attribute[key]);\n            }\n        } else {\n            ariaSet(element, attribute, value);\n        }\n    }\n\n    function ariaSet(element, attribute, value) {\n        element.setAttribute((attribute == 'role' ? '' : 'aria-') + attribute, value);\n    }\n\n    function ariaAttr(attribute, data) {\n        if (!$.isPlainObject(attribute)) {\n            attribute = {\n                attribute: data\n            };\n        }\n        data = '';\n        for (var key in attribute) {\n            var attr = (key == 'role' ? '' : 'aria-') + key,\n                attrVal = attribute[key];\n            data += attrVal == null ? '' : attr + '=\"' + attribute[key] + '\"';\n        }\n        return data;\n    }\n\n    // IE8 bug throws an error for activeElements within iframes.\n    function getActiveElement() {\n        try {\n            return document.activeElement;\n        } catch (err) {}\n    }\n\n    // Expose the picker constructor.\n    return PickerConstructor;\n});\n\n;\n/*!\r\n * Date picker for pickadate.js v3.5.0\r\n * http://amsul.github.io/pickadate.js/date.htm\r\n */\n\n(function (factory) {\n\n    // AMD.\n    if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    // Node.js/browserify.\n    else {}\n})(function (Picker, $) {\n\n    /**\r\n     * Globals and constants\r\n     */\n    var DAYS_IN_WEEK = 7,\n        WEEKS_IN_CALENDAR = 6,\n        _ = Picker._;\n\n    /**\r\n     * The date picker constructor\r\n     */\n    function DatePicker(picker, settings) {\n\n        var calendar = this,\n            element = picker.$node[0],\n            elementValue = element.value,\n            elementDataValue = picker.$node.data('value'),\n            valueString = elementDataValue || elementValue,\n            formatString = elementDataValue ? settings.formatSubmit : settings.format,\n            isRTL = function isRTL() {\n\n            return element.currentStyle ?\n\n            // For IE.\n            element.currentStyle.direction == 'rtl' :\n\n            // For normal browsers.\n            getComputedStyle(picker.$root[0]).direction == 'rtl';\n        };\n\n        calendar.settings = settings;\n        calendar.$node = picker.$node;\n\n        // The queue of methods that will be used to build item objects.\n        calendar.queue = {\n            min: 'measure create',\n            max: 'measure create',\n            now: 'now create',\n            select: 'parse create validate',\n            highlight: 'parse navigate create validate',\n            view: 'parse create validate viewset',\n            disable: 'deactivate',\n            enable: 'activate'\n\n            // The component's item object.\n        };calendar.item = {};\n\n        calendar.item.clear = null;\n        calendar.item.disable = (settings.disable || []).slice(0);\n        calendar.item.enable = -function (collectionDisabled) {\n            return collectionDisabled[0] === true ? collectionDisabled.shift() : -1;\n        }(calendar.item.disable);\n\n        calendar.set('min', settings.min).set('max', settings.max).set('now');\n\n        // When there’s a value, set the `select`, which in turn\n        // also sets the `highlight` and `view`.\n        if (valueString) {\n            calendar.set('select', valueString, {\n                format: formatString\n            });\n        }\n\n        // If there’s no value, default to highlighting “today”.\n        else {\n                calendar.set('select', null).set('highlight', calendar.item.now);\n            }\n\n        // The keycode to movement mapping.\n        calendar.key = {\n            40: 7, // Down\n            38: -7, // Up\n            39: function _() {\n                return isRTL() ? -1 : 1;\n            }, // Right\n            37: function _() {\n                return isRTL() ? 1 : -1;\n            }, // Left\n            go: function go(timeChange) {\n                var highlightedObject = calendar.item.highlight,\n                    targetDate = new Date(highlightedObject.year, highlightedObject.month, highlightedObject.date + timeChange);\n                calendar.set('highlight', targetDate, {\n                    interval: timeChange\n                });\n                this.render();\n            }\n\n            // Bind some picker events.\n        };picker.on('render', function () {\n            picker.$root.find('.' + settings.klass.selectMonth).on('change', function () {\n                var value = this.value;\n                if (value) {\n                    picker.set('highlight', [picker.get('view').year, value, picker.get('highlight').date]);\n                    picker.$root.find('.' + settings.klass.selectMonth).trigger('focus');\n                }\n            });\n            picker.$root.find('.' + settings.klass.selectYear).on('change', function () {\n                var value = this.value;\n                if (value) {\n                    picker.set('highlight', [value, picker.get('view').month, picker.get('highlight').date]);\n                    picker.$root.find('.' + settings.klass.selectYear).trigger('focus');\n                }\n            });\n        }, 1).on('open', function () {\n            var includeToday = '';\n            if (calendar.disabled(calendar.get('now'))) {\n                includeToday = ':not(.' + settings.klass.buttonToday + ')';\n            }\n            picker.$root.find('button' + includeToday + ', select').attr('disabled', false);\n        }, 1).on('close', function () {\n            picker.$root.find('button, select').attr('disabled', true);\n        }, 1);\n    } //DatePicker\n\n\n    /**\r\n     * Set a datepicker item object.\r\n     */\n    DatePicker.prototype.set = function (type, value, options) {\n\n        var calendar = this,\n            calendarItem = calendar.item;\n\n        // If the value is `null` just set it immediately.\n        if (value === null) {\n            if (type == 'clear') type = 'select';\n            calendarItem[type] = value;\n            return calendar;\n        }\n\n        // Otherwise go through the queue of methods, and invoke the functions.\n        // Update this as the time unit, and set the final value as this item.\n        // * In the case of `enable`, keep the queue but set `disable` instead.\n        //   And in the case of `flip`, keep the queue but set `enable` instead.\n        calendarItem[type == 'enable' ? 'disable' : type == 'flip' ? 'enable' : type] = calendar.queue[type].split(' ').map(function (method) {\n            value = calendar[method](type, value, options);\n            return value;\n        }).pop();\n\n        // Check if we need to cascade through more updates.\n        if (type == 'select') {\n            calendar.set('highlight', calendarItem.select, options);\n        } else if (type == 'highlight') {\n            calendar.set('view', calendarItem.highlight, options);\n        } else if (type.match(/^(flip|min|max|disable|enable)$/)) {\n            if (calendarItem.select && calendar.disabled(calendarItem.select)) {\n                calendar.set('select', calendarItem.select, options);\n            }\n            if (calendarItem.highlight && calendar.disabled(calendarItem.highlight)) {\n                calendar.set('highlight', calendarItem.highlight, options);\n            }\n        }\n\n        return calendar;\n    }; //DatePicker.prototype.set\n\n\n    /**\r\n     * Get a datepicker item object.\r\n     */\n    DatePicker.prototype.get = function (type) {\n        return this.item[type];\n    }; //DatePicker.prototype.get\n\n\n    /**\r\n     * Create a picker date object.\r\n     */\n    DatePicker.prototype.create = function (type, value, options) {\n\n        var isInfiniteValue,\n            calendar = this;\n\n        // If there’s no value, use the type as the value.\n        value = value === undefined ? type : value;\n\n        // If it’s infinity, update the value.\n        if (value == -Infinity || value == Infinity) {\n            isInfiniteValue = value;\n        }\n\n        // If it’s an object, use the native date object.\n        else if ($.isPlainObject(value) && _.isInteger(value.pick)) {\n                value = value.obj;\n            }\n\n            // If it’s an array, convert it into a date and make sure\n            // that it’s a valid date – otherwise default to today.\n            else if ($.isArray(value)) {\n                    value = new Date(value[0], value[1], value[2]);\n                    value = _.isDate(value) ? value : calendar.create().obj;\n                }\n\n                // If it’s a number or date object, make a normalized date.\n                else if (_.isInteger(value) || _.isDate(value)) {\n                        value = calendar.normalize(new Date(value), options);\n                    }\n\n                    // If it’s a literal true or any other case, set it to now.\n                    else /*if ( value === true )*/{\n                            value = calendar.now(type, value, options);\n                        }\n\n        // Return the compiled object.\n        return {\n            year: isInfiniteValue || value.getFullYear(),\n            month: isInfiniteValue || value.getMonth(),\n            date: isInfiniteValue || value.getDate(),\n            day: isInfiniteValue || value.getDay(),\n            obj: isInfiniteValue || value,\n            pick: isInfiniteValue || value.getTime()\n        };\n    }; //DatePicker.prototype.create\n\n\n    /**\r\n     * Create a range limit object using an array, date object,\r\n     * literal “true”, or integer relative to another time.\r\n     */\n    DatePicker.prototype.createRange = function (from, to) {\n\n        var calendar = this,\n            createDate = function createDate(date) {\n            if (date === true || $.isArray(date) || _.isDate(date)) {\n                return calendar.create(date);\n            }\n            return date;\n        };\n\n        // Create objects if possible.\n        if (!_.isInteger(from)) {\n            from = createDate(from);\n        }\n        if (!_.isInteger(to)) {\n            to = createDate(to);\n        }\n\n        // Create relative dates.\n        if (_.isInteger(from) && $.isPlainObject(to)) {\n            from = [to.year, to.month, to.date + from];\n        } else if (_.isInteger(to) && $.isPlainObject(from)) {\n            to = [from.year, from.month, from.date + to];\n        }\n\n        return {\n            from: createDate(from),\n            to: createDate(to)\n        };\n    }; //DatePicker.prototype.createRange\n\n\n    /**\r\n     * Check if a date unit falls within a date range object.\r\n     */\n    DatePicker.prototype.withinRange = function (range, dateUnit) {\n        range = this.createRange(range.from, range.to);\n        return dateUnit.pick >= range.from.pick && dateUnit.pick <= range.to.pick;\n    };\n\n    /**\r\n     * Check if two date range objects overlap.\r\n     */\n    DatePicker.prototype.overlapRanges = function (one, two) {\n\n        var calendar = this;\n\n        // Convert the ranges into comparable dates.\n        one = calendar.createRange(one.from, one.to);\n        two = calendar.createRange(two.from, two.to);\n\n        return calendar.withinRange(one, two.from) || calendar.withinRange(one, two.to) || calendar.withinRange(two, one.from) || calendar.withinRange(two, one.to);\n    };\n\n    /**\r\n     * Get the date today.\r\n     */\n    DatePicker.prototype.now = function (type, value, options) {\n        value = new Date();\n        if (options && options.rel) {\n            value.setDate(value.getDate() + options.rel);\n        }\n        return this.normalize(value, options);\n    };\n\n    /**\r\n     * Navigate to next/prev month.\r\n     */\n    DatePicker.prototype.navigate = function (type, value, options) {\n\n        var targetDateObject,\n            targetYear,\n            targetMonth,\n            targetDate,\n            isTargetArray = $.isArray(value),\n            isTargetObject = $.isPlainObject(value),\n            viewsetObject = this.item.view;\n        /*,\r\n         safety = 100*/\n\n        if (isTargetArray || isTargetObject) {\n\n            if (isTargetObject) {\n                targetYear = value.year;\n                targetMonth = value.month;\n                targetDate = value.date;\n            } else {\n                targetYear = +value[0];\n                targetMonth = +value[1];\n                targetDate = +value[2];\n            }\n\n            // If we’re navigating months but the view is in a different\n            // month, navigate to the view’s year and month.\n            if (options && options.nav && viewsetObject && viewsetObject.month !== targetMonth) {\n                targetYear = viewsetObject.year;\n                targetMonth = viewsetObject.month;\n            }\n\n            // Figure out the expected target year and month.\n            targetDateObject = new Date(targetYear, targetMonth + (options && options.nav ? options.nav : 0), 1);\n            targetYear = targetDateObject.getFullYear();\n            targetMonth = targetDateObject.getMonth();\n\n            // If the month we’re going to doesn’t have enough days,\n            // keep decreasing the date until we reach the month’s last date.\n            while ( /*safety &&*/new Date(targetYear, targetMonth, targetDate).getMonth() !== targetMonth) {\n                targetDate -= 1;\n                /*safety -= 1\r\n                 if ( !safety ) {\r\n                 throw 'Fell into an infinite loop while navigating to ' + new Date( targetYear, targetMonth, targetDate ) + '.'\r\n                 }*/\n            }\n\n            value = [targetYear, targetMonth, targetDate];\n        }\n\n        return value;\n    }; //DatePicker.prototype.navigate\n\n\n    /**\r\n     * Normalize a date by setting the hours to midnight.\r\n     */\n    DatePicker.prototype.normalize = function (value /*, options*/) {\n        value.setHours(0, 0, 0, 0);\n        return value;\n    };\n\n    /**\r\n     * Measure the range of dates.\r\n     */\n    DatePicker.prototype.measure = function (type, value /*, options*/) {\n\n        var calendar = this;\n\n        // If it’s anything false-y, remove the limits.\n        if (!value) {\n            value = type == 'min' ? -Infinity : Infinity;\n        }\n\n        // If it’s a string, parse it.\n        else if (typeof value == 'string') {\n                value = calendar.parse(type, value);\n            }\n\n            // If it's an integer, get a date relative to today.\n            else if (_.isInteger(value)) {\n                    value = calendar.now(type, value, {\n                        rel: value\n                    });\n                }\n\n        return value;\n    }; ///DatePicker.prototype.measure\n\n\n    /**\r\n     * Create a viewset object based on navigation.\r\n     */\n    DatePicker.prototype.viewset = function (type, dateObject /*, options*/) {\n        return this.create([dateObject.year, dateObject.month, 1]);\n    };\n\n    /**\r\n     * Validate a date as enabled and shift if needed.\r\n     */\n    DatePicker.prototype.validate = function (type, dateObject, options) {\n\n        var calendar = this,\n\n\n        // Keep a reference to the original date.\n        originalDateObject = dateObject,\n\n\n        // Make sure we have an interval.\n        interval = options && options.interval ? options.interval : 1,\n\n\n        // Check if the calendar enabled dates are inverted.\n        isFlippedBase = calendar.item.enable === -1,\n\n\n        // Check if we have any enabled dates after/before now.\n        hasEnabledBeforeTarget,\n            hasEnabledAfterTarget,\n\n\n        // The min & max limits.\n        minLimitObject = calendar.item.min,\n            maxLimitObject = calendar.item.max,\n\n\n        // Check if we’ve reached the limit during shifting.\n        reachedMin,\n            reachedMax,\n\n\n        // Check if the calendar is inverted and at least one weekday is enabled.\n        hasEnabledWeekdays = isFlippedBase && calendar.item.disable.filter(function (value) {\n\n            // If there’s a date, check where it is relative to the target.\n            if ($.isArray(value)) {\n                var dateTime = calendar.create(value).pick;\n                if (dateTime < dateObject.pick) hasEnabledBeforeTarget = true;else if (dateTime > dateObject.pick) hasEnabledAfterTarget = true;\n            }\n\n            // Return only integers for enabled weekdays.\n            return _.isInteger(value);\n        }).length;\n        /*,\r\n           safety = 100*/\n\n        // Cases to validate for:\n        // [1] Not inverted and date disabled.\n        // [2] Inverted and some dates enabled.\n        // [3] Not inverted and out of range.\n        //\n        // Cases to **not** validate for:\n        // • Navigating months.\n        // • Not inverted and date enabled.\n        // • Inverted and all dates disabled.\n        // • ..and anything else.\n        if (!options || !options.nav) if (\n        /* 1 */\n        !isFlippedBase && calendar.disabled(dateObject) ||\n        /* 2 */\n        isFlippedBase && calendar.disabled(dateObject) && (hasEnabledWeekdays || hasEnabledBeforeTarget || hasEnabledAfterTarget) ||\n        /* 3 */\n        !isFlippedBase && (dateObject.pick <= minLimitObject.pick || dateObject.pick >= maxLimitObject.pick)) {\n\n            // When inverted, flip the direction if there aren’t any enabled weekdays\n            // and there are no enabled dates in the direction of the interval.\n            if (isFlippedBase && !hasEnabledWeekdays && (!hasEnabledAfterTarget && interval > 0 || !hasEnabledBeforeTarget && interval < 0)) {\n                interval *= -1;\n            }\n\n            // Keep looping until we reach an enabled date.\n            while ( /*safety &&*/calendar.disabled(dateObject)) {\n\n                /*safety -= 1\r\n                 if ( !safety ) {\r\n                 throw 'Fell into an infinite loop while validating ' + dateObject.obj + '.'\r\n                 }*/\n\n                // If we’ve looped into the next/prev month with a large interval, return to the original date and flatten the interval.\n                if (Math.abs(interval) > 1 && (dateObject.month < originalDateObject.month || dateObject.month > originalDateObject.month)) {\n                    dateObject = originalDateObject;\n                    interval = interval > 0 ? 1 : -1;\n                }\n\n                // If we’ve reached the min/max limit, reverse the direction, flatten the interval and set it to the limit.\n                if (dateObject.pick <= minLimitObject.pick) {\n                    reachedMin = true;\n                    interval = 1;\n                    dateObject = calendar.create([minLimitObject.year, minLimitObject.month, minLimitObject.date + (dateObject.pick === minLimitObject.pick ? 0 : -1)]);\n                } else if (dateObject.pick >= maxLimitObject.pick) {\n                    reachedMax = true;\n                    interval = -1;\n                    dateObject = calendar.create([maxLimitObject.year, maxLimitObject.month, maxLimitObject.date + (dateObject.pick === maxLimitObject.pick ? 0 : 1)]);\n                }\n\n                // If we’ve reached both limits, just break out of the loop.\n                if (reachedMin && reachedMax) {\n                    break;\n                }\n\n                // Finally, create the shifted date using the interval and keep looping.\n                dateObject = calendar.create([dateObject.year, dateObject.month, dateObject.date + interval]);\n            }\n        } //endif\n\n\n        // Return the date object settled on.\n        return dateObject;\n    }; //DatePicker.prototype.validate\n\n\n    /**\r\n     * Check if a date is disabled.\r\n     */\n    DatePicker.prototype.disabled = function (dateToVerify) {\n\n        var calendar = this,\n\n\n        // Filter through the disabled dates to check if this is one.\n        isDisabledMatch = calendar.item.disable.filter(function (dateToDisable) {\n\n            // If the date is a number, match the weekday with 0index and `firstDay` check.\n            if (_.isInteger(dateToDisable)) {\n                return dateToVerify.day === (calendar.settings.firstDay ? dateToDisable : dateToDisable - 1) % 7;\n            }\n\n            // If it’s an array or a native JS date, create and match the exact date.\n            if ($.isArray(dateToDisable) || _.isDate(dateToDisable)) {\n                return dateToVerify.pick === calendar.create(dateToDisable).pick;\n            }\n\n            // If it’s an object, match a date within the “from” and “to” range.\n            if ($.isPlainObject(dateToDisable)) {\n                return calendar.withinRange(dateToDisable, dateToVerify);\n            }\n        });\n\n        // If this date matches a disabled date, confirm it’s not inverted.\n        isDisabledMatch = isDisabledMatch.length && !isDisabledMatch.filter(function (dateToDisable) {\n            return $.isArray(dateToDisable) && dateToDisable[3] == 'inverted' || $.isPlainObject(dateToDisable) && dateToDisable.inverted;\n        }).length;\n\n        // Check the calendar “enabled” flag and respectively flip the\n        // disabled state. Then also check if it’s beyond the min/max limits.\n        return calendar.item.enable === -1 ? !isDisabledMatch : isDisabledMatch || dateToVerify.pick < calendar.item.min.pick || dateToVerify.pick > calendar.item.max.pick;\n    }; //DatePicker.prototype.disabled\n\n\n    /**\r\n     * Parse a string into a usable type.\r\n     */\n    DatePicker.prototype.parse = function (type, value, options) {\n\n        var calendar = this,\n            parsingObject = {};\n\n        // If it’s already parsed, we’re good.\n        if (!value || typeof value != 'string') {\n            return value;\n        }\n\n        // We need a `.format` to parse the value with.\n        if (!(options && options.format)) {\n            options = options || {};\n            options.format = calendar.settings.format;\n        }\n\n        // Convert the format into an array and then map through it.\n        calendar.formats.toArray(options.format).map(function (label) {\n\n            var\n            // Grab the formatting label.\n            formattingLabel = calendar.formats[label],\n\n\n            // The format length is from the formatting label function or the\n            // label length without the escaping exclamation (!) mark.\n            formatLength = formattingLabel ? _.trigger(formattingLabel, calendar, [value, parsingObject]) : label.replace(/^!/, '').length;\n\n            // If there's a format label, split the value up to the format length.\n            // Then add it to the parsing object with appropriate label.\n            if (formattingLabel) {\n                parsingObject[label] = value.substr(0, formatLength);\n            }\n\n            // Update the value as the substring from format length to end.\n            value = value.substr(formatLength);\n        });\n\n        // Compensate for month 0index.\n        return [parsingObject.yyyy || parsingObject.yy, +(parsingObject.mm || parsingObject.m) - 1, parsingObject.dd || parsingObject.d];\n    }; //DatePicker.prototype.parse\n\n\n    /**\r\n     * Various formats to display the object in.\r\n     */\n    DatePicker.prototype.formats = function () {\n\n        // Return the length of the first word in a collection.\n        function getWordLengthFromCollection(string, collection, dateObject) {\n\n            // Grab the first word from the string.\n            var word = string.match(/\\w+/)[0];\n\n            // If there's no month index, add it to the date object\n            if (!dateObject.mm && !dateObject.m) {\n                dateObject.m = collection.indexOf(word) + 1;\n            }\n\n            // Return the length of the word.\n            return word.length;\n        }\n\n        // Get the length of the first word in a string.\n        function getFirstWordLength(string) {\n            return string.match(/\\w+/)[0].length;\n        }\n\n        return {\n\n            d: function d(string, dateObject) {\n\n                // If there's string, then get the digits length.\n                // Otherwise return the selected date.\n                return string ? _.digits(string) : dateObject.date;\n            },\n            dd: function dd(string, dateObject) {\n\n                // If there's a string, then the length is always 2.\n                // Otherwise return the selected date with a leading zero.\n                return string ? 2 : _.lead(dateObject.date);\n            },\n            ddd: function ddd(string, dateObject) {\n\n                // If there's a string, then get the length of the first word.\n                // Otherwise return the short selected weekday.\n                return string ? getFirstWordLength(string) : this.settings.weekdaysShort[dateObject.day];\n            },\n            dddd: function dddd(string, dateObject) {\n\n                // If there's a string, then get the length of the first word.\n                // Otherwise return the full selected weekday.\n                return string ? getFirstWordLength(string) : this.settings.weekdaysFull[dateObject.day];\n            },\n            m: function m(string, dateObject) {\n\n                // If there's a string, then get the length of the digits\n                // Otherwise return the selected month with 0index compensation.\n                return string ? _.digits(string) : dateObject.month + 1;\n            },\n            mm: function mm(string, dateObject) {\n\n                // If there's a string, then the length is always 2.\n                // Otherwise return the selected month with 0index and leading zero.\n                return string ? 2 : _.lead(dateObject.month + 1);\n            },\n            mmm: function mmm(string, dateObject) {\n\n                var collection = this.settings.monthsShort;\n\n                // If there's a string, get length of the relevant month from the short\n                // months collection. Otherwise return the selected month from that collection.\n                return string ? getWordLengthFromCollection(string, collection, dateObject) : collection[dateObject.month];\n            },\n            mmmm: function mmmm(string, dateObject) {\n\n                var collection = this.settings.monthsFull;\n\n                // If there's a string, get length of the relevant month from the full\n                // months collection. Otherwise return the selected month from that collection.\n                return string ? getWordLengthFromCollection(string, collection, dateObject) : collection[dateObject.month];\n            },\n            yy: function yy(string, dateObject) {\n\n                // If there's a string, then the length is always 2.\n                // Otherwise return the selected year by slicing out the first 2 digits.\n                return string ? 2 : ('' + dateObject.year).slice(2);\n            },\n            yyyy: function yyyy(string, dateObject) {\n\n                // If there's a string, then the length is always 4.\n                // Otherwise return the selected year.\n                return string ? 4 : dateObject.year;\n            },\n\n            // Create an array by splitting the formatting string passed.\n            toArray: function toArray(formatString) {\n                return formatString.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);\n            },\n\n            // Format an object into a string using the formatting options.\n            toString: function toString(formatString, itemObject) {\n                var calendar = this;\n                return calendar.formats.toArray(formatString).map(function (label) {\n                    return _.trigger(calendar.formats[label], calendar, [0, itemObject]) || label.replace(/^!/, '');\n                }).join('');\n            }\n        };\n    }(); //DatePicker.prototype.formats\n\n\n    /**\r\n     * Check if two date units are the exact.\r\n     */\n    DatePicker.prototype.isDateExact = function (one, two) {\n\n        var calendar = this;\n\n        // When we’re working with weekdays, do a direct comparison.\n        if (_.isInteger(one) && _.isInteger(two) || typeof one == 'boolean' && typeof two == 'boolean') {\n            return one === two;\n        }\n\n        // When we’re working with date representations, compare the “pick” value.\n        if ((_.isDate(one) || $.isArray(one)) && (_.isDate(two) || $.isArray(two))) {\n            return calendar.create(one).pick === calendar.create(two).pick;\n        }\n\n        // When we’re working with range objects, compare the “from” and “to”.\n        if ($.isPlainObject(one) && $.isPlainObject(two)) {\n            return calendar.isDateExact(one.from, two.from) && calendar.isDateExact(one.to, two.to);\n        }\n\n        return false;\n    };\n\n    /**\r\n     * Check if two date units overlap.\r\n     */\n    DatePicker.prototype.isDateOverlap = function (one, two) {\n\n        var calendar = this,\n            firstDay = calendar.settings.firstDay ? 1 : 0;\n\n        // When we’re working with a weekday index, compare the days.\n        if (_.isInteger(one) && (_.isDate(two) || $.isArray(two))) {\n            one = one % 7 + firstDay;\n            return one === calendar.create(two).day + 1;\n        }\n        if (_.isInteger(two) && (_.isDate(one) || $.isArray(one))) {\n            two = two % 7 + firstDay;\n            return two === calendar.create(one).day + 1;\n        }\n\n        // When we’re working with range objects, check if the ranges overlap.\n        if ($.isPlainObject(one) && $.isPlainObject(two)) {\n            return calendar.overlapRanges(one, two);\n        }\n\n        return false;\n    };\n\n    /**\r\n     * Flip the “enabled” state.\r\n     */\n    DatePicker.prototype.flipEnable = function (val) {\n        var itemObject = this.item;\n        itemObject.enable = val || (itemObject.enable == -1 ? 1 : -1);\n    };\n\n    /**\r\n     * Mark a collection of dates as “disabled”.\r\n     */\n    DatePicker.prototype.deactivate = function (type, datesToDisable) {\n\n        var calendar = this,\n            disabledItems = calendar.item.disable.slice(0);\n\n        // If we’re flipping, that’s all we need to do.\n        if (datesToDisable == 'flip') {\n            calendar.flipEnable();\n        } else if (datesToDisable === false) {\n            calendar.flipEnable(1);\n            disabledItems = [];\n        } else if (datesToDisable === true) {\n            calendar.flipEnable(-1);\n            disabledItems = [];\n        }\n\n        // Otherwise go through the dates to disable.\n        else {\n\n                datesToDisable.map(function (unitToDisable) {\n\n                    var matchFound;\n\n                    // When we have disabled items, check for matches.\n                    // If something is matched, immediately break out.\n                    for (var index = 0; index < disabledItems.length; index += 1) {\n                        if (calendar.isDateExact(unitToDisable, disabledItems[index])) {\n                            matchFound = true;\n                            break;\n                        }\n                    }\n\n                    // If nothing was found, add the validated unit to the collection.\n                    if (!matchFound) {\n                        if (_.isInteger(unitToDisable) || _.isDate(unitToDisable) || $.isArray(unitToDisable) || $.isPlainObject(unitToDisable) && unitToDisable.from && unitToDisable.to) {\n                            disabledItems.push(unitToDisable);\n                        }\n                    }\n                });\n            }\n\n        // Return the updated collection.\n        return disabledItems;\n    }; //DatePicker.prototype.deactivate\n\n\n    /**\r\n     * Mark a collection of dates as “enabled”.\r\n     */\n    DatePicker.prototype.activate = function (type, datesToEnable) {\n\n        var calendar = this,\n            disabledItems = calendar.item.disable,\n            disabledItemsCount = disabledItems.length;\n\n        // If we’re flipping, that’s all we need to do.\n        if (datesToEnable == 'flip') {\n            calendar.flipEnable();\n        } else if (datesToEnable === true) {\n            calendar.flipEnable(1);\n            disabledItems = [];\n        } else if (datesToEnable === false) {\n            calendar.flipEnable(-1);\n            disabledItems = [];\n        }\n\n        // Otherwise go through the disabled dates.\n        else {\n\n                datesToEnable.map(function (unitToEnable) {\n\n                    var matchFound, disabledUnit, index, isExactRange;\n\n                    // Go through the disabled items and try to find a match.\n                    for (index = 0; index < disabledItemsCount; index += 1) {\n\n                        disabledUnit = disabledItems[index];\n\n                        // When an exact match is found, remove it from the collection.\n                        if (calendar.isDateExact(disabledUnit, unitToEnable)) {\n                            matchFound = disabledItems[index] = null;\n                            isExactRange = true;\n                            break;\n                        }\n\n                        // When an overlapped match is found, add the “inverted” state to it.\n                        else if (calendar.isDateOverlap(disabledUnit, unitToEnable)) {\n                                if ($.isPlainObject(unitToEnable)) {\n                                    unitToEnable.inverted = true;\n                                    matchFound = unitToEnable;\n                                } else if ($.isArray(unitToEnable)) {\n                                    matchFound = unitToEnable;\n                                    if (!matchFound[3]) matchFound.push('inverted');\n                                } else if (_.isDate(unitToEnable)) {\n                                    matchFound = [unitToEnable.getFullYear(), unitToEnable.getMonth(), unitToEnable.getDate(), 'inverted'];\n                                }\n                                break;\n                            }\n                    }\n\n                    // If a match was found, remove a previous duplicate entry.\n                    if (matchFound) for (index = 0; index < disabledItemsCount; index += 1) {\n                        if (calendar.isDateExact(disabledItems[index], unitToEnable)) {\n                            disabledItems[index] = null;\n                            break;\n                        }\n                    }\n\n                    // In the event that we’re dealing with an exact range of dates,\n                    // make sure there are no “inverted” dates because of it.\n                    if (isExactRange) for (index = 0; index < disabledItemsCount; index += 1) {\n                        if (calendar.isDateOverlap(disabledItems[index], unitToEnable)) {\n                            disabledItems[index] = null;\n                            break;\n                        }\n                    }\n\n                    // If something is still matched, add it into the collection.\n                    if (matchFound) {\n                        disabledItems.push(matchFound);\n                    }\n                });\n            }\n\n        // Return the updated collection.\n        return disabledItems.filter(function (val) {\n            return val != null;\n        });\n    }; //DatePicker.prototype.activate\n\n\n    /**\r\n     * Create a string for the nodes in the picker.\r\n     */\n    DatePicker.prototype.nodes = function (isOpen) {\n\n        var calendar = this,\n            settings = calendar.settings,\n            calendarItem = calendar.item,\n            nowObject = calendarItem.now,\n            selectedObject = calendarItem.select,\n            highlightedObject = calendarItem.highlight,\n            viewsetObject = calendarItem.view,\n            disabledCollection = calendarItem.disable,\n            minLimitObject = calendarItem.min,\n            maxLimitObject = calendarItem.max,\n\n\n        // Create the calendar table head using a copy of weekday labels collection.\n        // * We do a copy so we don't mutate the original array.\n        tableHead = function (collection, fullCollection) {\n\n            // If the first day should be Monday, move Sunday to the end.\n            if (settings.firstDay) {\n                collection.push(collection.shift());\n                fullCollection.push(fullCollection.shift());\n            }\n\n            // Create and return the table head group.\n            return _.node('thead', _.node('tr', _.group({\n                min: 0,\n                max: DAYS_IN_WEEK - 1,\n                i: 1,\n                node: 'th',\n                item: function item(counter) {\n                    return [collection[counter], settings.klass.weekdays, 'scope=col title=\"' + fullCollection[counter] + '\"'];\n                }\n            }))); //endreturn\n\n            // Materialize modified\n        }((settings.showWeekdaysFull ? settings.weekdaysFull : settings.weekdaysLetter).slice(0), settings.weekdaysFull.slice(0)),\n            //tableHead\n\n\n        // Create the nav for next/prev month.\n        createMonthNav = function createMonthNav(next) {\n\n            // Otherwise, return the created month tag.\n            return _.node('div', ' ', settings.klass['nav' + (next ? 'Next' : 'Prev')] + (\n\n            // If the focused month is outside the range, disabled the button.\n            next && viewsetObject.year >= maxLimitObject.year && viewsetObject.month >= maxLimitObject.month || !next && viewsetObject.year <= minLimitObject.year && viewsetObject.month <= minLimitObject.month ? ' ' + settings.klass.navDisabled : ''), 'data-nav=' + (next || -1) + ' ' + _.ariaAttr({\n                role: 'button',\n                controls: calendar.$node[0].id + '_table'\n            }) + ' ' + 'title=\"' + (next ? settings.labelMonthNext : settings.labelMonthPrev) + '\"'); //endreturn\n        },\n            //createMonthNav\n\n\n        // Create the month label.\n        //Materialize modified\n        createMonthLabel = function createMonthLabel(override) {\n\n            var monthsCollection = settings.showMonthsShort ? settings.monthsShort : settings.monthsFull;\n\n            // Materialize modified\n            if (override == \"short_months\") {\n                monthsCollection = settings.monthsShort;\n            }\n\n            // If there are months to select, add a dropdown menu.\n            if (settings.selectMonths && override == undefined) {\n\n                return _.node('select', _.group({\n                    min: 0,\n                    max: 11,\n                    i: 1,\n                    node: 'option',\n                    item: function item(loopedMonth) {\n\n                        return [\n\n                        // The looped month and no classes.\n                        monthsCollection[loopedMonth], 0,\n\n                        // Set the value and selected index.\n                        'value=' + loopedMonth + (viewsetObject.month == loopedMonth ? ' selected' : '') + (viewsetObject.year == minLimitObject.year && loopedMonth < minLimitObject.month || viewsetObject.year == maxLimitObject.year && loopedMonth > maxLimitObject.month ? ' disabled' : '')];\n                    }\n                }), settings.klass.selectMonth + ' browser-default', (isOpen ? '' : 'disabled') + ' ' + _.ariaAttr({\n                    controls: calendar.$node[0].id + '_table'\n                }) + ' ' + 'title=\"' + settings.labelMonthSelect + '\"');\n            }\n\n            // Materialize modified\n            if (override == \"short_months\") if (selectedObject != null) return _.node('div', monthsCollection[selectedObject.month]);else return _.node('div', monthsCollection[viewsetObject.month]);\n\n            // If there's a need for a month selector\n            return _.node('div', monthsCollection[viewsetObject.month], settings.klass.month);\n        },\n            //createMonthLabel\n\n\n        // Create the year label.\n        // Materialize modified\n        createYearLabel = function createYearLabel(override) {\n\n            var focusedYear = viewsetObject.year,\n\n\n            // If years selector is set to a literal \"true\", set it to 5. Otherwise\n            // divide in half to get half before and half after focused year.\n            numberYears = settings.selectYears === true ? 5 : ~~(settings.selectYears / 2);\n\n            // If there are years to select, add a dropdown menu.\n            if (numberYears) {\n\n                var minYear = minLimitObject.year,\n                    maxYear = maxLimitObject.year,\n                    lowestYear = focusedYear - numberYears,\n                    highestYear = focusedYear + numberYears;\n\n                // If the min year is greater than the lowest year, increase the highest year\n                // by the difference and set the lowest year to the min year.\n                if (minYear > lowestYear) {\n                    highestYear += minYear - lowestYear;\n                    lowestYear = minYear;\n                }\n\n                // If the max year is less than the highest year, decrease the lowest year\n                // by the lower of the two: available and needed years. Then set the\n                // highest year to the max year.\n                if (maxYear < highestYear) {\n\n                    var availableYears = lowestYear - minYear,\n                        neededYears = highestYear - maxYear;\n\n                    lowestYear -= availableYears > neededYears ? neededYears : availableYears;\n                    highestYear = maxYear;\n                }\n\n                if (settings.selectYears && override == undefined) {\n                    return _.node('select', _.group({\n                        min: lowestYear,\n                        max: highestYear,\n                        i: 1,\n                        node: 'option',\n                        item: function item(loopedYear) {\n                            return [\n\n                            // The looped year and no classes.\n                            loopedYear, 0,\n\n                            // Set the value and selected index.\n                            'value=' + loopedYear + (focusedYear == loopedYear ? ' selected' : '')];\n                        }\n                    }), settings.klass.selectYear + ' browser-default', (isOpen ? '' : 'disabled') + ' ' + _.ariaAttr({\n                        controls: calendar.$node[0].id + '_table'\n                    }) + ' ' + 'title=\"' + settings.labelYearSelect + '\"');\n                }\n            }\n\n            // Materialize modified\n            if (override == \"raw\") return _.node('div', focusedYear);\n\n            // Otherwise just return the year focused\n            return _.node('div', focusedYear, settings.klass.year);\n        }; //createYearLabel\n\n\n        // Materialize modified\n        var createDayLabel = function createDayLabel() {\n            if (selectedObject != null) return _.node('div', selectedObject.date);else return _.node('div', nowObject.date);\n        };\n        var createWeekdayLabel = function createWeekdayLabel() {\n            var display_day;\n\n            if (selectedObject != null) display_day = selectedObject.day;else display_day = nowObject.day;\n            var weekday = settings.weekdaysFull[display_day];\n            return weekday;\n        };\n\n        // Create and return the entire calendar.\n        return _.node(\n        // Date presentation View\n        'div', _.node('div', createWeekdayLabel(), \"picker__weekday-display\") + _.node(\n        // Div for short Month\n        'div', createMonthLabel(\"short_months\"), settings.klass.month_display) + _.node(\n        // Div for Day\n        'div', createDayLabel(), settings.klass.day_display) + _.node(\n        // Div for Year\n        'div', createYearLabel(\"raw\"), settings.klass.year_display), settings.klass.date_display) +\n        // Calendar container\n        _.node('div', _.node('div', (settings.selectYears ? createMonthLabel() + createYearLabel() : createMonthLabel() + createYearLabel()) + createMonthNav() + createMonthNav(1), settings.klass.header) + _.node('table', tableHead + _.node('tbody', _.group({\n            min: 0,\n            max: WEEKS_IN_CALENDAR - 1,\n            i: 1,\n            node: 'tr',\n            item: function item(rowCounter) {\n\n                // If Monday is the first day and the month starts on Sunday, shift the date back a week.\n                var shiftDateBy = settings.firstDay && calendar.create([viewsetObject.year, viewsetObject.month, 1]).day === 0 ? -7 : 0;\n\n                return [_.group({\n                    min: DAYS_IN_WEEK * rowCounter - viewsetObject.day + shiftDateBy + 1, // Add 1 for weekday 0index\n                    max: function max() {\n                        return this.min + DAYS_IN_WEEK - 1;\n                    },\n                    i: 1,\n                    node: 'td',\n                    item: function item(targetDate) {\n\n                        // Convert the time date from a relative date to a target date.\n                        targetDate = calendar.create([viewsetObject.year, viewsetObject.month, targetDate + (settings.firstDay ? 1 : 0)]);\n\n                        var isSelected = selectedObject && selectedObject.pick == targetDate.pick,\n                            isHighlighted = highlightedObject && highlightedObject.pick == targetDate.pick,\n                            isDisabled = disabledCollection && calendar.disabled(targetDate) || targetDate.pick < minLimitObject.pick || targetDate.pick > maxLimitObject.pick,\n                            formattedDate = _.trigger(calendar.formats.toString, calendar, [settings.format, targetDate]);\n\n                        return [_.node('div', targetDate.date, function (klasses) {\n\n                            // Add the `infocus` or `outfocus` classes based on month in view.\n                            klasses.push(viewsetObject.month == targetDate.month ? settings.klass.infocus : settings.klass.outfocus);\n\n                            // Add the `today` class if needed.\n                            if (nowObject.pick == targetDate.pick) {\n                                klasses.push(settings.klass.now);\n                            }\n\n                            // Add the `selected` class if something's selected and the time matches.\n                            if (isSelected) {\n                                klasses.push(settings.klass.selected);\n                            }\n\n                            // Add the `highlighted` class if something's highlighted and the time matches.\n                            if (isHighlighted) {\n                                klasses.push(settings.klass.highlighted);\n                            }\n\n                            // Add the `disabled` class if something's disabled and the object matches.\n                            if (isDisabled) {\n                                klasses.push(settings.klass.disabled);\n                            }\n\n                            return klasses.join(' ');\n                        }([settings.klass.day]), 'data-pick=' + targetDate.pick + ' ' + _.ariaAttr({\n                            role: 'gridcell',\n                            label: formattedDate,\n                            selected: isSelected && calendar.$node.val() === formattedDate ? true : null,\n                            activedescendant: isHighlighted ? true : null,\n                            disabled: isDisabled ? true : null\n                        })), '', _.ariaAttr({\n                            role: 'presentation'\n                        })]; //endreturn\n                    }\n                })]; //endreturn\n            }\n        })), settings.klass.table, 'id=\"' + calendar.$node[0].id + '_table' + '\" ' + _.ariaAttr({\n            role: 'grid',\n            controls: calendar.$node[0].id,\n            readonly: true\n        })), settings.klass.calendar_container) // end calendar\n\n        +\n\n        // * For Firefox forms to submit, make sure to set the buttons’ `type` attributes as “button”.\n        _.node('div', _.node('button', settings.today, \"btn-flat picker__today\", 'type=button data-pick=' + nowObject.pick + (isOpen && !calendar.disabled(nowObject) ? '' : ' disabled') + ' ' + _.ariaAttr({\n            controls: calendar.$node[0].id\n        })) + _.node('button', settings.clear, \"btn-flat picker__clear\", 'type=button data-clear=1' + (isOpen ? '' : ' disabled') + ' ' + _.ariaAttr({\n            controls: calendar.$node[0].id\n        })) + _.node('button', settings.close, \"btn-flat picker__close\", 'type=button data-close=true ' + (isOpen ? '' : ' disabled') + ' ' + _.ariaAttr({\n            controls: calendar.$node[0].id\n        })), settings.klass.footer); //endreturn\n    }; //DatePicker.prototype.nodes\n\n\n    /**\r\n     * The date picker defaults.\r\n     */\n    DatePicker.defaults = function (prefix) {\n\n        return {\n\n            // The title label to use for the month nav buttons\n            labelMonthNext: 'Next month',\n            labelMonthPrev: 'Previous month',\n\n            // The title label to use for the dropdown selectors\n            labelMonthSelect: 'Select a month',\n            labelYearSelect: 'Select a year',\n\n            // Months and weekdays\n            monthsFull: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n            monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            weekdaysFull: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n            weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n\n            // Materialize modified\n            weekdaysLetter: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n\n            // Today and clear\n            today: 'Today',\n            clear: 'Clear',\n            close: 'Close',\n\n            // The format to show on the `input` element\n            format: 'd mmmm, yyyy',\n\n            // Classes\n            klass: {\n\n                table: prefix + 'table',\n\n                header: prefix + 'header',\n\n                // Materialize Added klasses\n                date_display: prefix + 'date-display',\n                day_display: prefix + 'day-display',\n                month_display: prefix + 'month-display',\n                year_display: prefix + 'year-display',\n                calendar_container: prefix + 'calendar-container',\n                // end\n\n\n                navPrev: prefix + 'nav--prev',\n                navNext: prefix + 'nav--next',\n                navDisabled: prefix + 'nav--disabled',\n\n                month: prefix + 'month',\n                year: prefix + 'year',\n\n                selectMonth: prefix + 'select--month',\n                selectYear: prefix + 'select--year',\n\n                weekdays: prefix + 'weekday',\n\n                day: prefix + 'day',\n                disabled: prefix + 'day--disabled',\n                selected: prefix + 'day--selected',\n                highlighted: prefix + 'day--highlighted',\n                now: prefix + 'day--today',\n                infocus: prefix + 'day--infocus',\n                outfocus: prefix + 'day--outfocus',\n\n                footer: prefix + 'footer',\n\n                buttonClear: prefix + 'button--clear',\n                buttonToday: prefix + 'button--today',\n                buttonClose: prefix + 'button--close'\n            }\n        };\n    }(Picker.klasses().picker + '__');\n\n    /**\r\n     * Extend the picker to add the date picker.\r\n     */\n    Picker.extend('pickadate', DatePicker);\n});\n\n;\n(function ($) {\n\n    $.fn.characterCounter = function () {\n        return this.each(function () {\n            var $input = $(this);\n            var $counterElement = $input.parent().find('span[class=\"character-counter\"]');\n\n            // character counter has already been added appended to the parent container\n            if ($counterElement.length) {\n                return;\n            }\n\n            var itHasLengthAttribute = $input.attr('length') !== undefined;\n\n            if (itHasLengthAttribute) {\n                $input.on('input', updateCounter);\n                $input.on('focus', updateCounter);\n                $input.on('blur', removeCounterElement);\n\n                addCounterElement($input);\n            }\n        });\n    };\n\n    function updateCounter() {\n        var maxLength = +$(this).attr('length'),\n            actualLength = +$(this).val().length,\n            isValidLength = actualLength <= maxLength;\n\n        $(this).parent().find('span[class=\"character-counter\"]').html(actualLength + '/' + maxLength);\n\n        addInputStyle(isValidLength, $(this));\n    }\n\n    function addCounterElement($input) {\n        var $counterElement = $input.parent().find('span[class=\"character-counter\"]');\n\n        if ($counterElement.length) {\n            return;\n        }\n\n        $counterElement = $('<span/>').addClass('character-counter').css('float', 'right').css('font-size', '12px').css('height', 1);\n\n        $input.parent().append($counterElement);\n    }\n\n    function removeCounterElement() {\n        $(this).parent().find('span[class=\"character-counter\"]').html('');\n    }\n\n    function addInputStyle(isValidLength, $input) {\n        var inputHasInvalidClass = $input.hasClass('invalid');\n        if (isValidLength && inputHasInvalidClass) {\n            $input.removeClass('invalid');\n        } else if (!isValidLength && !inputHasInvalidClass) {\n            $input.removeClass('valid');\n            $input.addClass('invalid');\n        }\n    }\n\n    $(document).ready(function () {\n        $('input, textarea').characterCounter();\n    });\n})(jQuery);\n(function ($) {\n\n    var methods = {\n\n        init: function init(options) {\n            var defaults = {\n                time_constant: 200, // ms\n                dist: -100, // zoom scale TODO: make this more intuitive as an option\n                shift: 0, // spacing for center image\n                padding: 0, // Padding between non center items\n                full_width: false // Change to full width styles\n            };\n\n            options = $.extend(defaults, options);\n\n            return this.each(function () {\n\n                var images, tweenedOpacity, zTranslation, item_width, offset, center, pressed, dim, count, reference, referenceY, amplitude, target, velocity, xform, frame, timestamp, ticker, dragged, vertical_dragged;\n\n                // Initialize\n                var view = $(this);\n                // Don't double initialize.\n                if (view.hasClass('initialized')) {\n                    return true;\n                }\n\n                // Options\n                if (options.full_width) {\n                    options.dist = 0;\n                    options.spacing = 0;\n                    options.padding = 0;\n\n                    view.find('.carousel-item').first().load(function () {\n                        view.css('height', $(this).height());\n                    });\n                }\n\n                view.addClass('initialized');\n                pressed = false;\n                offset = target = 0;\n                images = [];\n                item_width = view.find('.carousel-item').first().innerWidth();\n                dim = item_width * 2 + options.padding;\n\n                view.find('.carousel-item').each(function () {\n                    images.push($(this)[0]);\n                });\n\n                count = images.length;\n\n                function setupEvents() {\n                    if (typeof window.ontouchstart !== 'undefined') {\n                        view[0].addEventListener('touchstart', tap);\n                        view[0].addEventListener('touchmove', drag);\n                        view[0].addEventListener('touchend', release);\n                    }\n                    view[0].addEventListener('mousedown', tap);\n                    view[0].addEventListener('mousemove', drag);\n                    view[0].addEventListener('mouseup', release);\n                    view[0].addEventListener('click', click);\n                }\n\n                function xpos(e) {\n                    // touch event\n                    if (e.targetTouches && e.targetTouches.length >= 1) {\n                        return e.targetTouches[0].clientX;\n                    }\n\n                    // mouse event\n                    return e.clientX;\n                }\n\n                function ypos(e) {\n                    // touch event\n                    if (e.targetTouches && e.targetTouches.length >= 1) {\n                        return e.targetTouches[0].clientY;\n                    }\n\n                    // mouse event\n                    return e.clientY;\n                }\n\n                function wrap(x) {\n                    return x >= count ? x % count : x < 0 ? wrap(count + x % count) : x;\n                }\n\n                function scroll(x) {\n                    var i, half, delta, dir, tween, el, alignment, xTranslation;\n\n                    offset = typeof x === 'number' ? x : offset;\n                    center = Math.floor((offset + dim / 2) / dim);\n                    delta = offset - center * dim;\n                    dir = delta < 0 ? 1 : -1;\n                    tween = -dir * delta * 2 / dim;\n\n                    if (!options.full_width) {\n                        alignment = 'translateX(' + (view[0].clientWidth - item_width) / 2 + 'px) ';\n                        if (parseInt(options.dist) > 0) {\n                            alignment += 'translateY(' + (view[0].clientHeight - item_width) / 2 + 'px)';\n                        }\n                    } else {\n                        alignment = 'translateX(0)';\n                    }\n\n                    // center\n                    el = images[wrap(center)];\n                    el.style[xform] = alignment + ' translateX(' + -delta / 2 + 'px)' + ' translateX(' + dir * options.shift * tween * i + 'px)' + ' translateZ(' + options.dist * tween + 'px)';\n                    el.style.zIndex = 0;\n                    if (options.full_width) {\n                        tweenedOpacity = 1;\n                    } else {\n                        tweenedOpacity = 1 - 0.2 * tween;\n                    }\n                    el.style.opacity = tweenedOpacity;\n                    half = count >> 1;\n\n                    for (i = 1; i <= half; ++i) {\n                        // right side\n                        if (options.full_width) {\n                            zTranslation = options.dist;\n                            tweenedOpacity = i === half && delta < 0 ? 1 - tween : 1;\n                        } else {\n                            zTranslation = options.dist * (i * 2 + tween * dir);\n                            tweenedOpacity = 1 - 0.2 * (i * 2 + tween * dir);\n                        }\n                        el = images[wrap(center + i)];\n                        el.style[xform] = alignment + ' translateX(' + (options.shift + (dim * i - delta) / 2) + 'px)' + ' translateZ(' + zTranslation + 'px)';\n                        el.style.zIndex = -i;\n                        el.style.opacity = tweenedOpacity;\n\n                        // left side\n                        if (options.full_width) {\n                            zTranslation = options.dist;\n                            tweenedOpacity = i === half && delta > 0 ? 1 - tween : 1;\n                        } else {\n                            zTranslation = options.dist * (i * 2 - tween * dir);\n                            tweenedOpacity = 1 - 0.2 * (i * 2 - tween * dir);\n                        }\n                        el = images[wrap(center - i)];\n                        el.style[xform] = alignment + ' translateX(' + (-options.shift + (-dim * i - delta) / 2) + 'px)' + ' translateZ(' + zTranslation + 'px)';\n                        el.style.zIndex = -i;\n                        el.style.opacity = tweenedOpacity;\n                    }\n\n                    // center\n                    el = images[wrap(center)];\n                    el.style[xform] = alignment + ' translateX(' + -delta / 2 + 'px)' + ' translateX(' + dir * options.shift * tween + 'px)' + ' translateZ(' + options.dist * tween + 'px)';\n                    el.style.zIndex = 0;\n                    if (options.full_width) {\n                        tweenedOpacity = 1;\n                    } else {\n                        tweenedOpacity = 1 - 0.2 * tween;\n                    }\n                    el.style.opacity = tweenedOpacity;\n                }\n\n                function track() {\n                    var now, elapsed, delta, v;\n\n                    now = Date.now();\n                    elapsed = now - timestamp;\n                    timestamp = now;\n                    delta = offset - frame;\n                    frame = offset;\n\n                    v = 1000 * delta / (1 + elapsed);\n                    velocity = 0.8 * v + 0.2 * velocity;\n                }\n\n                function autoScroll() {\n                    var elapsed, delta;\n\n                    if (amplitude) {\n                        elapsed = Date.now() - timestamp;\n                        delta = amplitude * Math.exp(-elapsed / options.time_constant);\n                        if (delta > 2 || delta < -2) {\n                            scroll(target - delta);\n                            requestAnimationFrame(autoScroll);\n                        } else {\n                            scroll(target);\n                        }\n                    }\n                }\n\n                function click(e) {\n                    // Disable clicks if carousel was dragged.\n                    if (dragged) {\n                        //e.preventDefault();\n                        e.stopPropagation();\n                        //return false;\n                    } else if (!options.full_width) {\n                        var clickedIndex = $(e.target).closest('.carousel-item').index();\n                        var diff = center % count - clickedIndex;\n                        // Account for wraparound.\n                        if (diff < 0) {\n                            if (Math.abs(diff + count) < Math.abs(diff)) {\n                                diff += count;\n                            }\n                        } else if (diff > 0) {\n                            if (Math.abs(diff - count) < diff) {\n                                diff -= count;\n                            }\n                        }\n\n                        // Call prev or next accordingly.\n                        if (diff < 0) {\n                            $(this).trigger('carouselNext', [Math.abs(diff)]);\n                        } else if (diff > 0) {\n                            $(this).trigger('carouselPrev', [diff]);\n                        }\n                    }\n                }\n\n                function tap(e) {\n                    pressed = true;\n                    dragged = false;\n                    vertical_dragged = false;\n                    reference = xpos(e);\n                    referenceY = ypos(e);\n\n                    velocity = amplitude = 0;\n                    frame = offset;\n                    timestamp = Date.now();\n                    clearInterval(ticker);\n                    ticker = setInterval(track, 100);\n                }\n\n                function drag(e) {\n                    var x, y, delta, deltaY;\n                    if (pressed) {\n                        x = xpos(e);\n                        y = ypos(e);\n                        delta = reference - x;\n                        deltaY = Math.abs(referenceY - y);\n                        if (deltaY < 30 && !vertical_dragged) {\n                            // If vertical scrolling don't allow dragging.\n                            if (delta > 20 || delta < -20) {\n                                dragged = true;\n                                reference = x;\n                                scroll(offset + delta);\n                            }\n                        } else if (dragged) {\n                            // If dragging don't allow vertical scroll.\n                            e.preventDefault();\n                            e.stopPropagation();\n                            return false;\n                        } else {\n                            // Vertical scrolling.\n                            vertical_dragged = true;\n                        }\n                    }\n\n                    if (dragged) {\n                        // If dragging don't allow vertical scroll.\n                        e.preventDefault();\n                        e.stopPropagation();\n                        return false;\n                    }\n                }\n\n                function release(e) {\n                    pressed = false;\n\n                    clearInterval(ticker);\n                    target = offset;\n                    if (velocity > 10 || velocity < -10) {\n                        amplitude = 0.9 * velocity;\n                        target = offset + amplitude;\n                    }\n\n                    target = Math.round(target / dim) * dim;\n                    amplitude = target - offset;\n                    timestamp = Date.now();\n                    requestAnimationFrame(autoScroll);\n\n                    //e.preventDefault();\n                    e.stopPropagation();\n                    //return false;\n                }\n\n                xform = 'transform';\n                ['webkit', 'Moz', 'O', 'ms'].every(function (prefix) {\n                    var e = prefix + 'Transform';\n                    if (typeof document.body.style[e] !== 'undefined') {\n                        xform = e;\n                        return false;\n                    }\n                    return true;\n                });\n\n                window.onresize = scroll;\n\n                setupEvents();\n                scroll(offset);\n\n                $(this).on('carouselNext', function (e, n) {\n                    if (n === undefined) {\n                        n = 1;\n                    }\n                    target = offset + dim * n;\n                    if (offset !== target) {\n                        amplitude = target - offset;\n                        timestamp = Date.now();\n                        requestAnimationFrame(autoScroll);\n                    }\n                });\n\n                $(this).on('carouselPrev', function (e, n) {\n                    if (n === undefined) {\n                        n = 1;\n                    }\n                    target = offset - dim * n;\n                    if (offset !== target) {\n                        amplitude = target - offset;\n                        timestamp = Date.now();\n                        requestAnimationFrame(autoScroll);\n                    }\n                });\n            });\n        },\n        next: function next(n) {\n            $(this).trigger('carouselNext', [n]);\n        },\n        prev: function prev(n) {\n            $(this).trigger('carouselPrev', [n]);\n        }\n    };\n\n    $.fn.carousel = function (methodOrOptions) {\n        if (methods[methodOrOptions]) {\n            return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));\n        } else if ((typeof methodOrOptions === 'undefined' ? 'undefined' : _typeof(methodOrOptions)) === 'object' || !methodOrOptions) {\n            // Default to \"init\"\n            return methods.init.apply(this, arguments);\n        } else {\n            $.error('Method ' + methodOrOptions + ' does not exist on jQuery.carousel');\n        }\n    }; // Plugin end\n})(jQuery);\n\nmodule.exports = Materialize;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! ./../../../../../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./wp-content/themes/wappsnet/assets/js/partials/materialize.js */ \"./wp-content/themes/wappsnet/assets/js/partials/materialize.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/assets/js/partials/materialize.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/assets/js/partials/validate.js":
/*!*******************************************************************!*\
  !*** ./wp-content/themes/wappsnet/assets/js/partials/validate.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction Validate() {\n    var _self = this;\n    this.rules = {\n        ruleRegex: /^(.+?)\\[(.+)\\]$/,\n        numericRegex: /^[0-9]+$/,\n        mobileNumberRegex: /^([+()0-9-\\s\\.]{0,20})$/i,\n        integerRegex: /^\\-?[0-9]+$/,\n        decimalRegex: /^\\-?[0-9]*\\.?[0-9]+$/,\n        emailRegex: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,\n        alphaRegex: /^[a-zа-я]+$/i,\n        alphaNumericRegex: /^[a-zа-я0-9]+$/i,\n        alphaDashRegex: /^[a-zа-я0-9_\\-]+$/i,\n        naturalRegex: /^[0-9]+$/i,\n        naturalNoZeroRegex: /^[1-9][0-9]*$/i,\n        ipRegex: /^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})$/i,\n        base64Regex: /[^a-zA-Z0-9\\/\\+=]/i,\n        numericDashRegex: /^[\\d\\-\\s]+$/,\n        urlRegex: /^((http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)|)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/,\n        dateRegex: /\\d{4}-\\d{1,2}-\\d{1,2}/,\n        dateTimeRegex: /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/,\n        timeRegex: /([01]\\d|2[0-3]):([0-5]\\d)/\n    };\n\n    this.hooks = {\n        getValidDate: function getValidDate(date) {\n            if (!date.match('today') && !date.match(this.dateRegex)) {\n                return false;\n            }\n\n            var validDate = new Date(),\n                validDateArray = void 0;\n\n            if (!date.match('today')) {\n                validDateArray = date.split('-');\n                validDate.setFullYear(validDateArray[0]);\n                validDate.setMonth(validDateArray[1] - 1);\n                validDate.setDate(validDateArray[2]);\n            }\n            return validDate;\n        },\n\n        required: function required(field) {\n            return field.value !== null && field.value !== '';\n        },\n\n        defaultField: function defaultField(field, defaultName) {\n            return field.value !== defaultName;\n        },\n\n        matches: function matches(field, matchName) {\n            var el = _self.GetElementInsideContainer(matchName);\n            if (el) {\n                return field.value === el.value;\n            }\n            return false;\n        },\n\n        mobileNumber: function mobileNumber(field) {\n            return _self.rules.mobileNumberRegex.test(field.value);\n        },\n\n        valid_email: function valid_email(field) {\n            return _self.rules.emailRegex.test(field.value);\n        },\n\n        valid_emails: function valid_emails(field) {\n            var result = field.value.split(/\\s*,\\s*/g);\n            for (var i = 0, resultLength = result.length; i < resultLength; i++) {\n                if (!_self.rules.emailRegex.test(result[i])) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        password: function password(field) {\n            if (!_self.hooks.alpha_numeric(field.value)) {\n                return false;\n            }\n            return field.value.length >= parseInt(2, 10);\n        },\n\n        min_length: function min_length(field, length) {\n            return field.value.length >= parseInt(length, 10);\n        },\n\n        max_length: function max_length(field, length) {\n            return field.value.length <= parseInt(length, 10);\n        },\n\n        exact_length: function exact_length(field, length) {\n            return field.value.length === parseInt(length, 10);\n        },\n\n        greater_than: function greater_than(field, param) {\n            if (!_self.rules.decimalRegex.test(field.value)) {\n                return false;\n            }\n            return parseFloat(field.value) > parseFloat(param);\n        },\n\n        less_than: function less_than(field, param) {\n            if (!_self.rules.decimalRegex.test(field.value)) {\n                return false;\n            }\n            return parseFloat(field.value) < parseFloat(param);\n        },\n\n        alpha: function alpha(field) {\n            return _self.rules.alphaRegex.test(field.value);\n        },\n\n        alpha_numeric: function alpha_numeric(field) {\n            return _self.rules.alphaNumericRegex.test(field.value);\n        },\n\n        alpha_dash: function alpha_dash(field) {\n            return _self.rules.alphaDashRegex.test(field.value);\n        },\n\n        text_area: function text_area(field) {\n            return field.value.length > 0;\n        },\n\n        numeric: function numeric(field) {\n            return _self.rules.numericRegex.test(field.value);\n        },\n\n        integer: function integer(field) {\n            return _self.rules.integerRegex.test(field.value);\n        },\n\n        decimal: function decimal(field) {\n            return _self.rules.decimalRegex.test(field.value);\n        },\n\n        is_natural: function is_natural(field) {\n            return _self.rules.naturalRegex.test(field.value);\n        },\n\n        is_natural_no_zero: function is_natural_no_zero(field) {\n            return _self.rules.naturalNoZeroRegex.test(field.value);\n        },\n\n        valid_ip: function valid_ip(field) {\n            return _self.rules.ipRegex.test(field.value);\n        },\n\n        valid_base64: function valid_base64(field) {\n            return _self.rules.base64Regex.test(field.value);\n        },\n\n        valid_url: function valid_url(field) {\n            return _self.rules.urlRegex.test(field.value);\n        },\n\n        valid_credit_card: function valid_credit_card(field) {\n            if (!_self.rules.numericDashRegex.test(field.value)) return false;\n            var nCheck = 0,\n                nDigit = 0,\n                bEven = false;\n            var strippedField = field.value.replace(/\\D/g, \"\");\n            for (var n = strippedField.length - 1; n >= 0; n--) {\n                var cDigit = strippedField.charAt(n);\n                nDigit = parseInt(cDigit, 10);\n                if (bEven) {\n                    if ((nDigit *= 2) > 9) nDigit -= 9;\n                }\n                nCheck += nDigit;\n                bEven = !bEven;\n            }\n            return nCheck % 10 === 0;\n        },\n\n        is_file_type: function is_file_type(field, type) {\n            if (field.type !== 'file') {\n                return true;\n            }\n            var ext = field.value.substr(field.value.lastIndexOf('.') + 1),\n                typeArray = type.split(','),\n                inArray = false,\n                i = 0,\n                len = typeArray.length;\n            for (i; i < len; i++) {\n                if (ext == typeArray[i]) inArray = true;\n            }\n            return inArray;\n        },\n\n        greater_than_date: function greater_than_date(field, date) {\n            var enteredDate = this.getValidDate(field.value),\n                validDate = this.getValidDate(date);\n            if (!validDate || !enteredDate) {\n                return false;\n            }\n            return enteredDate > validDate;\n        },\n\n        less_than_date: function less_than_date(field, date) {\n            var enteredDate = this.getValidDate(field.value),\n                validDate = this.getValidDate(date);\n\n            if (!validDate || !enteredDate) {\n                return false;\n            }\n            return enteredDate < validDate;\n        },\n\n        greater_than_or_equal_date: function greater_than_or_equal_date(field, date) {\n            var enteredDate = this.getValidDate(field.value),\n                validDate = this.getValidDate(date);\n            if (!validDate || !enteredDate) {\n                return false;\n            }\n            return enteredDate >= validDate;\n        },\n\n        less_than_or_equal_date: function less_than_or_equal_date(field, date) {\n            var enteredDate = this.getValidDate(field.value),\n                validDate = this.getValidDate(date);\n\n            if (!validDate || !enteredDate) {\n                return false;\n            }\n            return enteredDate <= validDate;\n        },\n\n        existing_email: function existing_email() {\n            return _self.messages['am']['existing_email'];\n        },\n\n        existing_mobile: function existing_mobile() {\n            return _self.messages['am']['existing_mobile'];\n        }\n    };\n}\n\nexports.default = Validate;\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/assets/js/partials/validate.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/modules/artarchive/index.js":
/*!****************************************************************!*\
  !*** ./wp-content/themes/wappsnet/modules/artarchive/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/modules/artarchive/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/modules/artwork/index.js":
/*!*************************************************************!*\
  !*** ./wp-content/themes/wappsnet/modules/artwork/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub) {\n\nvar _magnifier = __webpack_require__(/*! magnifier */ \"./node_modules/magnifier/index.es5.js\");\n\nvar _magnifier2 = _interopRequireDefault(_magnifier);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPubSub.subscribe('document.ready', function () {\n    var magnifier = new _magnifier2.default('.zoom-view-box');\n    magnifier.width(300);\n    magnifier.height(300);\n    magnifier.borderRadius(300);\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/modules/artwork/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/modules/footer/index.js":
/*!************************************************************!*\
  !*** ./wp-content/themes/wappsnet/modules/footer/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/modules/footer/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/modules/header/index.js":
/*!************************************************************!*\
  !*** ./wp-content/themes/wappsnet/modules/header/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub, $) {\n\nPubSub.subscribe('document.ready', function () {\n    $(\"#side-menu-toggle\").sideNav({\n        edge: 'left',\n        menuWidth: 230,\n        closeOnClick: true\n    });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/modules/header/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/modules/page/index.js":
/*!**********************************************************!*\
  !*** ./wp-content/themes/wappsnet/modules/page/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub) {\n\nPubSub.subscribe('document.ready', function () {});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/modules/page/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/modules/popular/index.js":
/*!*************************************************************!*\
  !*** ./wp-content/themes/wappsnet/modules/popular/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub) {\n\nPubSub.subscribe('document.ready', function () {});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/modules/popular/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/modules/post/index.js":
/*!**********************************************************!*\
  !*** ./wp-content/themes/wappsnet/modules/post/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub) {\n\nPubSub.subscribe('document.ready', function () {});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/modules/post/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/modules/profile/index.js":
/*!*************************************************************!*\
  !*** ./wp-content/themes/wappsnet/modules/profile/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub) {\n\nPubSub.subscribe('document.ready', function () {});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/modules/profile/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/modules/search/index.js":
/*!************************************************************!*\
  !*** ./wp-content/themes/wappsnet/modules/search/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub) {\n\nPubSub.subscribe('document.ready', function () {});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/modules/search/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/modules/subscribe/index.js":
/*!***************************************************************!*\
  !*** ./wp-content/themes/wappsnet/modules/subscribe/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub, $) {\n\nvar _auth = __webpack_require__(/*! ../../assets/js/partials/auth */ \"./wp-content/themes/wappsnet/assets/js/partials/auth.js\");\n\nvar _auth2 = _interopRequireDefault(_auth);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPubSub.subscribe('document.ready', function () {\n    $('#subscribe-submit').click(function () {\n        _auth2.default.subscribe();\n    });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/modules/subscribe/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/artwork/index.js":
/*!*************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/artwork/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/artwork/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/cabinet/index.js":
/*!*************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/cabinet/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub) {\n\nvar _auth = __webpack_require__(/*! ../../assets/js/partials/auth */ \"./wp-content/themes/wappsnet/assets/js/partials/auth.js\");\n\nvar _auth2 = _interopRequireDefault(_auth);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPubSub.subscribe('document.ready', function () {});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/cabinet/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/carousel/index.js":
/*!**************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/carousel/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub, $) {\n\nPubSub.subscribe('document.ready', function () {\n    $('.carousel-block').each(function () {\n        $(this).slick({\n            infinite: true,\n            autoplay: true,\n            autoplaySpeed: 5000,\n            slidesToShow: 4,\n            slidesToScroll: 4,\n            responsive: [{\n                breakpoint: 1024,\n                settings: {\n                    slidesToShow: 3,\n                    slidesToScroll: 3\n                }\n            }, {\n                breakpoint: 630,\n                settings: {\n                    slidesToShow: 2,\n                    slidesToScroll: 2\n                }\n            }, {\n                breakpoint: 530,\n                settings: {\n                    slidesToShow: 1,\n                    slidesToScroll: 1\n                }\n            }]\n        });\n    });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/carousel/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/categories/index.js":
/*!****************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/categories/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/categories/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/comments/index.js":
/*!**************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/comments/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub, $) {\n\nvar _auth = __webpack_require__(/*! ../../assets/js/partials/auth */ \"./wp-content/themes/wappsnet/assets/js/partials/auth.js\");\n\nvar _auth2 = _interopRequireDefault(_auth);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPubSub.subscribe('document.ready', function () {\n    $('#user-comment').click(function () {\n        _auth2.default.actionUser('user_comment');\n    });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/comments/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/contact/index.js":
/*!*************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/contact/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub, $) {\n\nvar _auth = __webpack_require__(/*! ../../assets/js/partials/auth */ \"./wp-content/themes/wappsnet/assets/js/partials/auth.js\");\n\nvar _auth2 = _interopRequireDefault(_auth);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPubSub.subscribe('document.ready', function () {\n    $('#contact-submit').click(function () {\n        _auth2.default.actionUser('contact-field');\n    });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/contact/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/copyrights/index.js":
/*!****************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/copyrights/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/copyrights/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/forgot/index.js":
/*!************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/forgot/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub, $) {\n\nvar _auth = __webpack_require__(/*! ../../assets/js/partials/auth */ \"./wp-content/themes/wappsnet/assets/js/partials/auth.js\");\n\nvar _auth2 = _interopRequireDefault(_auth);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPubSub.subscribe('document.ready', function () {\n    $('#user-forgot').click(function () {\n        _auth2.default.actionUser('user_forgot');\n    });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/forgot/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/login/index.js":
/*!***********************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/login/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub, $) {\n\nvar _auth = __webpack_require__(/*! ../../assets/js/partials/auth */ \"./wp-content/themes/wappsnet/assets/js/partials/auth.js\");\n\nvar _auth2 = _interopRequireDefault(_auth);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPubSub.subscribe('document.ready', function () {\n    $('.plugin-login .action-button').click(function () {\n        var actionName = $(this).attr('data-action');\n        _auth2.default.actionUser(actionName);\n        return false;\n    });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/login/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/mobileIcons/index.js":
/*!*****************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/mobileIcons/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/mobileIcons/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/navigation/index.js":
/*!****************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/navigation/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/navigation/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/pagination/index.js":
/*!****************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/pagination/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub) {\n\nPubSub.subscribe('document.ready', function () {});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/pagination/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/post/index.js":
/*!**********************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/post/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub) {\n\nPubSub.subscribe('document.ready', function () {});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/post/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/product/index.js":
/*!*************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/product/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub) {\n\nPubSub.subscribe('document.ready', function () {});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/product/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/register/index.js":
/*!**************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/register/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(PubSub, $) {\n\nvar _auth = __webpack_require__(/*! ../../assets/js/partials/auth */ \"./wp-content/themes/wappsnet/assets/js/partials/auth.js\");\n\nvar _auth2 = _interopRequireDefault(_auth);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPubSub.subscribe('document.ready', function () {\n    $('.plugin-register .action-button').click(function () {\n        var actionName = $(this).attr('data-action');\n\n        console.log(actionName);\n\n        _auth2.default.actionUser(actionName);\n        return false;\n    });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pubsub-js */ \"./node_modules/pubsub-js/src/pubsub.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/register/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/socialicons/index.js":
/*!*****************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/socialicons/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/socialicons/index.js?");

/***/ }),

/***/ "./wp-content/themes/wappsnet/plugins/socialshare/index.js":
/*!*****************************************************************!*\
  !*** ./wp-content/themes/wappsnet/plugins/socialshare/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//# sourceURL=webpack:///./wp-content/themes/wappsnet/plugins/socialshare/index.js?");

/***/ })

/******/ });